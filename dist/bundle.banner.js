(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __exportStar = (target, module, desc) => {
    __markAsModule(target);
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module) => {
    if (module && module.__esModule)
      return module;
    return __exportStar(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", {value: module, enumerable: true}), module);
  };

  // node_modules/es6-tween/bundled/Tween.min.js
  var require_Tween_min = __commonJS((exports, module) => {
    !function(t, e) {
      typeof exports == "object" && typeof module != "undefined" ? e(exports) : typeof define == "function" && define.amd ? define(["exports"], e) : e((t = t || self).TWEEN = {});
    }(exports, function(t) {
      "use strict";
      function s(t2) {
        var e2 = u.indexOf(t2);
        -1 < e2 && u.splice(e2, 1), u.push(t2), p = 0, l && !f && (o = c(i), f = true);
      }
      function e(t2) {
        for (var e2 = 0; e2 < u.length; e2++)
          if (t2 === u[e2])
            return u[e2];
        return null;
      }
      function F() {
        return f;
      }
      function x() {
        return d;
      }
      var o, r = typeof self != "undefined" ? self : typeof window != "undefined" ? window : typeof global != "undefined" ? global : this || (t !== void 0 ? t : {}), n = r.requestAnimationFrame || function(t2) {
        return r.setTimeout(t2, 50 / 3);
      }, a = r.cancelAnimationFrame || function(t2) {
        return r.clearTimeout(t2);
      }, C = function() {
        if (typeof process == "undefined" || process.hrtime === void 0 || process.versions && process.versions.electron !== void 0) {
          if (r.performance !== void 0 && r.performance.now !== void 0)
            return r.performance.now.bind(r.performance);
          var t2 = r.performance && r.performance.timing && r.performance.timing.navigationStart ? r.performance.timing.navigationStart : Date.now();
          return function() {
            return Date.now() - t2;
          };
        }
        return function() {
          var t3 = process.hrtime();
          return 1e3 * t3[0] + t3[1] / 1e6;
        };
      }(), u = [], f = false, l = false, h = [], c = n, p = 0, y = 120, d = true, N = function(t2) {
        var e2 = u.indexOf(t2);
        e2 !== -1 && u.splice(e2, 1), u.length === 0 && (a(o), f = false);
      }, i = function t2() {
        var e2 = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : C(), r2 = 1 < arguments.length ? arguments[1] : void 0;
        if (y <= p && d)
          return f = false, p = 0, a(o), false;
        l && f ? o = c(t2) : function() {
          for (var t3 = 0; t3 < h.length; t3++)
            h[t3]();
        }(), u.length || p++;
        for (var n2 = 0, i2 = u.length; n2 < i2; )
          u[n2++].update(e2, r2), i2 > u.length && n2--, i2 = u.length;
        return true;
      }, q = {}, v = {Linear: {None: function(t2) {
        return t2;
      }}, Quadratic: {In: function(t2) {
        return Math.pow(t2, 2);
      }, Out: function(t2) {
        return t2 * (2 - t2);
      }, InOut: function(t2) {
        return (t2 *= 2) < 1 ? 0.5 * Math.pow(t2, 2) : -0.5 * (--t2 * (t2 - 2) - 1);
      }}, Cubic: {In: function(t2) {
        return Math.pow(t2, 3);
      }, Out: function(t2) {
        return --t2 * t2 * t2 + 1;
      }, InOut: function(t2) {
        return (t2 *= 2) < 1 ? 0.5 * Math.pow(t2, 3) : 0.5 * ((t2 -= 2) * t2 * t2 + 2);
      }}, Quartic: {In: function(t2) {
        return Math.pow(t2, 4);
      }, Out: function(t2) {
        return 1 - --t2 * t2 * t2 * t2;
      }, InOut: function(t2) {
        return (t2 *= 2) < 1 ? 0.5 * Math.pow(t2, 4) : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2);
      }}, Quintic: {In: function(t2) {
        return Math.pow(t2, 5);
      }, Out: function(t2) {
        return --t2 * t2 * t2 * t2 * t2 + 1;
      }, InOut: function(t2) {
        return (t2 *= 2) < 1 ? 0.5 * Math.pow(t2, 5) : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2);
      }}, Sinusoidal: {In: function(t2) {
        return 1 - Math.cos(t2 * Math.PI / 2);
      }, Out: function(t2) {
        return Math.sin(t2 * Math.PI / 2);
      }, InOut: function(t2) {
        return 0.5 * (1 - Math.cos(Math.PI * t2));
      }}, Exponential: {In: function(t2) {
        return t2 === 0 ? 0 : Math.pow(1024, t2 - 1);
      }, Out: function(t2) {
        return t2 === 1 ? 1 : 1 - Math.pow(2, -10 * t2);
      }, InOut: function(t2) {
        return t2 === 0 ? 0 : t2 === 1 ? 1 : (t2 *= 2) < 1 ? 0.5 * Math.pow(1024, t2 - 1) : 0.5 * (2 - Math.pow(2, -10 * (t2 - 1)));
      }}, Circular: {In: function(t2) {
        return 1 - Math.sqrt(1 - t2 * t2);
      }, Out: function(t2) {
        return Math.sqrt(1 - --t2 * t2);
      }, InOut: function(t2) {
        return (t2 *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1);
      }}, Elastic: {In: function(t2) {
        return t2 === 0 ? 0 : t2 === 1 ? 1 : -Math.pow(2, 10 * (t2 - 1)) * Math.sin(5 * (t2 - 1.1) * Math.PI);
      }, Out: function(t2) {
        return t2 === 0 ? 0 : t2 === 1 ? 1 : Math.pow(2, -10 * t2) * Math.sin(5 * (t2 - 0.1) * Math.PI) + 1;
      }, InOut: function(t2) {
        return t2 === 0 ? 0 : t2 === 1 ? 1 : (t2 *= 2) < 1 ? -0.5 * Math.pow(2, 10 * (t2 - 1)) * Math.sin(5 * (t2 - 1.1) * Math.PI) : 0.5 * Math.pow(2, -10 * (t2 - 1)) * Math.sin(5 * (t2 - 1.1) * Math.PI) + 1;
      }}, Back: {In: function(t2) {
        return t2 * t2 * (2.70158 * t2 - 1.70158);
      }, Out: function(t2) {
        return --t2 * t2 * (2.70158 * t2 + 1.70158) + 1;
      }, InOut: function(t2) {
        var e2 = 2.5949095;
        return (t2 *= 2) < 1 ? t2 * t2 * ((1 + e2) * t2 - e2) * 0.5 : 0.5 * ((t2 -= 2) * t2 * ((1 + e2) * t2 + e2) + 2);
      }}, Bounce: {In: function(t2) {
        return 1 - v.Bounce.Out(1 - t2);
      }, Out: function(t2) {
        var e2 = 2.75, r2 = 7.5625;
        return t2 < 1 / e2 ? r2 * t2 * t2 : t2 < 2 / e2 ? r2 * (t2 -= 1.5 / e2) * t2 + 0.75 : t2 < 2.5 / e2 ? r2 * (t2 -= 2.25 / e2) * t2 + 0.9375 : r2 * (t2 -= 2.625 / e2) * t2 + 0.984375;
      }, InOut: function(t2) {
        return t2 < 0.5 ? 0.5 * v.Bounce.In(2 * t2) : 0.5 * v.Bounce.Out(2 * t2 - 1) + 0.5;
      }}, Stepped: {steps: function(e2) {
        return function(t2) {
          return (t2 * e2 | 0) / e2;
        };
      }}};
      function m(t2) {
        return (m = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      function _(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function g(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      function b(t2, e2, r2) {
        return e2 && g(t2.prototype, e2), r2 && g(t2, r2), t2;
      }
      function T(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function O(i2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var o2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? T(Object(o2), true).forEach(function(t3) {
            var e2, r2, n2;
            e2 = i2, n2 = o2[r2 = t3], r2 in e2 ? Object.defineProperty(e2, r2, {value: n2, enumerable: true, configurable: true, writable: true}) : e2[r2] = n2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i2, Object.getOwnPropertyDescriptors(o2)) : T(Object(o2)).forEach(function(t3) {
            Object.defineProperty(i2, t3, Object.getOwnPropertyDescriptor(o2, t3));
          });
        }
        return i2;
      }
      function w(t2) {
        return (w = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      function k(t2, e2) {
        return (k = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      function j(t2) {
        if (t2 === void 0)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t2;
      }
      function A(t2, e2) {
        return !e2 || typeof e2 != "object" && typeof e2 != "function" ? j(t2) : e2;
      }
      function S(t2, e2) {
        return function(t3) {
          if (Array.isArray(t3))
            return t3;
        }(t2) || function(t3, e3) {
          if (!(Symbol.iterator in Object(t3) || Object.prototype.toString.call(t3) === "[object Arguments]"))
            return;
          var r2 = [], n2 = true, i2 = false, o2 = void 0;
          try {
            for (var s2, a2 = t3[Symbol.iterator](); !(n2 = (s2 = a2.next()).done) && (r2.push(s2.value), !e3 || r2.length !== e3); n2 = true)
              ;
          } catch (t4) {
            i2 = true, o2 = t4;
          } finally {
            try {
              n2 || a2.return == null || a2.return();
            } finally {
              if (i2)
                throw o2;
            }
          }
          return r2;
        }(t2, e2) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }();
      }
      var D = 50 / 3, U = "_chainedTweens", E = "Callback", V = "update", B = "complete", G = "start", z = "repeat", Q = "reverse", P = "restart", M = "STRING_PROP", R = /\s+|([A-Za-z?().,{}:""[\]#%]+)|([-+]=+)?([-+]+)?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]=?\d+)?/g;
      function I(t2) {
        if (t2 && t2.nodeType || t2 === void 0 || m(t2) !== "object")
          return t2;
        if (Array.isArray(t2))
          return [].concat(t2);
        if (m(t2) !== "object")
          return t2;
        var e2 = {};
        for (var r2 in t2)
          e2[r2] = I(t2[r2]);
        return e2;
      }
      var L = function(t2) {
        return isNaN(+t2) || (t2[0] === "+" || t2[0] === "-") && t2[1] === "=" || t2 === "" || t2 === " ";
      }, K = /^#([0-9a-f]{6}|[0-9a-f]{3})$/gi, W = function(t2, e2) {
        var r2, n2, i2;
        e2.length === 3 && (e2 = (r2 = e2[0]) + r2 + (n2 = e2[1]) + n2 + (i2 = e2[2]) + i2);
        var o2 = parseInt(e2, 16);
        return "rgb(" + (r2 = o2 >> 16 & 255) + ", " + (n2 = o2 >> 8 & 255) + ", " + (i2 = 255 & o2) + ")";
      };
      function H(t2) {
        if (t2 && t2.splice && t2.isString)
          return t2;
        if (typeof t2 != "string")
          return t2;
        if (t2.charAt(1) === "=")
          return t2;
        var e2 = t2.replace(K, W).match(R).map(function(t3) {
          return L(t3) ? t3 : +t3;
        });
        return e2.isString = true, e2;
      }
      function X(r2, n2, t2, e2) {
        var i2 = t2[r2], o2 = e2[r2];
        if (i2 === o2)
          return true;
        if (Array.isArray(i2) && Array.isArray(o2) && i2.length === o2.length)
          for (var s2 = 0, a2 = o2.length; s2 < a2; s2++) {
            var u2 = i2[s2], f2 = o2[s2];
            u2 === f2 || typeof u2 == "number" && typeof f2 == "number" || X(s2, n2[r2], i2, o2);
          }
        if (!(typeof i2 == "number" && typeof o2 == "number" || i2 && i2.splice && i2.isString && o2 && o2.splice && o2.isString)) {
          if (typeof i2 == "string" && Array.isArray(o2)) {
            var l2 = H(i2), h2 = o2.map(H);
            return t2[r2] = l2, e2[r2] = h2, true;
          }
          if (typeof i2 == "string" || typeof o2 == "string") {
            var c2 = Array.isArray(i2) && i2[0] === M ? i2 : H(i2), p2 = Array.isArray(o2) && o2[0] === M ? o2 : H(o2);
            if (c2 === void 0)
              return;
            for (var y2 = 1; y2 < c2.length; )
              c2[y2] === p2[y2] && typeof c2[y2 - 1] == "string" ? (c2.splice(y2 - 1, 2, c2[y2 - 1] + c2[y2]), p2.splice(y2 - 1, 2, p2[y2 - 1] + p2[y2])) : y2++;
            return c2[y2 = 0] === M && c2.shift(), p2[0] === M && p2.shift(), t2[r2] = c2, e2[r2] = p2, true;
          }
          if (m(i2) === "object" && m(o2) === "object") {
            if (Array.isArray(i2) && !i2.isString)
              return i2.map(function(t3, e3) {
                return X(e3, n2[r2], i2, o2);
              });
            for (var d2 in o2)
              X(d2, n2[r2], i2, o2);
            return true;
          }
        }
        return false;
      }
      var Y = "rgba(", Z = function(t2, e2, r2) {
        var n2 = 2 < arguments.length && r2 !== void 0 ? r2 : "rgb(";
        return typeof t2[e2] == "number" && (t2[e2 - 1] === n2 || t2[e2 - 3] === n2 || t2[e2 - 5] === n2);
      };
      function $(t2, e2, r2, n2, i2, o2, s2) {
        var a2 = s2 ? r2 : r2[t2], u2 = s2 ? n2 : n2[t2];
        if (u2 === void 0)
          return a2;
        if (a2 === void 0 || typeof a2 == "string" || a2 === u2)
          return u2;
        if (m(a2) === "object" && m(u2) === "object") {
          if (!a2 || !u2)
            return e2[t2];
          if (m(a2) === "object" && a2 && a2.isString && u2 && u2.splice && u2.isString) {
            for (var f2 = "", l2 = 0, h2 = a2.length; l2 < h2; l2++)
              if (a2[l2] !== u2[l2] || typeof a2[l2] != "number" || typeof u2[l2] == "number") {
                var c2 = typeof a2[l2] == "number" && typeof u2[l2] == "string" && u2[l2][1] === "=", p2 = typeof a2[l2] != "number" ? a2[l2] : c2 ? a2[l2] + parseFloat(u2[l2][0] + u2[l2].substr(2)) * i2 : a2[l2] + (u2[l2] - a2[l2]) * i2;
                (Z(a2, l2) || Z(a2, l2, Y)) && (p2 |= 0), f2 += p2, c2 && o2 === 1 && (a2[l2] = a2[l2] + parseFloat(u2[l2][0] + u2[l2].substr(2)));
              } else
                f2 += a2[l2];
            return s2 || (e2[t2] = f2), f2;
          }
          if (Array.isArray(a2) && a2[0] !== M)
            for (var y2 = 0, d2 = a2.length; y2 < d2; y2++)
              a2[y2] !== u2[y2] && typeof e2[t2] != "string" && $(y2, e2[t2], a2, u2, i2, o2);
          else if (m(a2) === "object" && a2 && !a2.isString)
            for (var v2 in a2)
              a2[v2] !== u2[v2] && $(v2, e2[t2], a2, u2, i2, o2);
        } else if (typeof a2 == "number") {
          var _2 = typeof u2 == "string";
          e2[t2] = _2 ? a2 + parseFloat(u2[0] + u2.substr(2)) * i2 : a2 + (u2 - a2) * i2, _2 && o2 === 1 && (r2[t2] = e2[t2]);
        } else
          typeof u2 == "function" && (e2[t2] = u2(i2));
        return e2[t2];
      }
      function J(t2, e2) {
        var i2 = t2[e2], o2 = e2.replace(nt, "").split(rt), s2 = o2.length - 1, a2 = Array.isArray(t2), u2 = m(t2) === "object" && !a2;
        return u2 ? (t2[e2] = null, delete t2[e2]) : a2 && t2.splice(e2, 1), o2.reduce(function(t3, e3, r2) {
          a2 && e3 !== "." && e3 !== "[" && (e3 *= 1);
          var n2 = o2[r2 + 1] === "[";
          if (e3 === "." || e3 === "[")
            return e3 === "." ? a2 = !(u2 = true) : e3 === "[" && (a2 = !(u2 = false)), t3;
          if (t3[e3] === void 0) {
            if (a2 || u2)
              return t3[e3] = r2 === s2 ? i2 : a2 || n2 ? [] : u2 ? {} : null, u2 = a2 = false, t3[e3];
          } else if (t3[e3] !== void 0)
            return r2 === s2 && (t3[e3] = i2), t3[e3];
          return t3;
        }, t2);
      }
      function tt(t2) {
        if (m(t2) === "object" && t2) {
          for (var e2 in t2)
            if (e2.indexOf(".") !== -1 || e2.indexOf("[") !== -1)
              J(t2, e2);
            else if (m(t2[e2]) === "object" && t2[e2]) {
              var r2 = t2[e2];
              for (var n2 in r2)
                if (n2.indexOf(".") !== -1 || n2.indexOf("[") !== -1)
                  J(r2, n2);
                else if (m(r2[n2]) === "object" && r2[n2]) {
                  var i2 = r2[n2];
                  for (var o2 in i2)
                    o2.indexOf(".") === -1 && o2.indexOf("[") === -1 || J(i2, o2);
                }
            }
        }
        return t2;
      }
      var et, rt = /([.[])/g, nt = /\]/g, it = Object.freeze({__proto__: null, FRAME_MS: D, TOO_LONG_FRAME_MS: 250, CHAINED_TWEENS: U, EVENT_CALLBACK: E, EVENT_UPDATE: V, EVENT_COMPLETE: B, EVENT_START: G, EVENT_REPEAT: z, EVENT_REVERSE: Q, EVENT_PAUSE: "pause", EVENT_PLAY: "play", EVENT_RESTART: P, EVENT_STOP: "stop", EVENT_SEEK: "seek", STRING_PROP: M, NUM_REGEX: R, deepCopy: I, decomposeString: H, decompose: X, RGB: "rgb(", RGBA: Y, isRGBColor: Z, recompose: $, SET_NESTED: tt}), ot = {Linear: function(t2, e2, r2) {
        var n2 = t2.length - 1, i2 = n2 * e2, o2 = Math.floor(i2), s2 = ot.Utils.Linear;
        return e2 < 0 ? s2(t2[0], t2[1], i2, r2) : 1 < e2 ? s2(t2[n2], t2[n2 - 1], n2 - i2, r2) : s2(t2[o2], t2[n2 < o2 + 1 ? n2 : o2 + 1], i2 - o2, r2);
      }, Bezier: function(t2, e2, r2) {
        for (var n2 = ot.Utils.Reset(r2), i2 = t2.length - 1, o2 = Math.pow, s2 = ot.Utils.Bernstein, a2 = Array.isArray(n2), u2 = 0; u2 <= i2; u2++)
          if (typeof n2 == "number")
            n2 += o2(1 - e2, i2 - u2) * o2(e2, u2) * t2[u2] * s2(i2, u2);
          else if (a2)
            for (var f2 = 0, l2 = n2.length; f2 < l2; f2++)
              typeof n2[f2] == "number" ? n2[f2] += o2(1 - e2, i2 - u2) * o2(e2, u2) * t2[u2][f2] * s2(i2, u2) : n2[f2] = t2[u2][f2];
          else if (m(n2) === "object")
            for (var h2 in n2)
              typeof n2[h2] == "number" ? n2[h2] += o2(1 - e2, i2 - u2) * o2(e2, u2) * t2[u2][h2] * s2(i2, u2) : n2[h2] = t2[u2][h2];
          else if (typeof n2 == "string") {
            for (var c2 = "", p2 = t2[Math.round(i2 * e2)], y2 = 1, d2 = p2.length; y2 < d2; y2++)
              c2 += p2[y2];
            return c2;
          }
        return n2;
      }, CatmullRom: function(t2, e2, r2) {
        var n2 = t2.length - 1, i2 = n2 * e2, o2 = Math.floor(i2), s2 = ot.Utils.CatmullRom;
        return t2[0] === t2[n2] ? (e2 < 0 && (o2 = Math.floor(i2 = n2 * (1 + e2))), s2(t2[(o2 - 1 + n2) % n2], t2[o2], t2[(o2 + 1) % n2], t2[(o2 + 2) % n2], i2 - o2, r2)) : e2 < 0 ? s2(t2[1], t2[1], t2[0], t2[0], -e2, r2) : 1 < e2 ? s2(t2[n2 - 1], t2[n2 - 1], t2[n2], t2[n2], (0 | e2) - e2, r2) : s2(t2[o2 ? o2 - 1 : 0], t2[o2], t2[n2 < o2 + 1 ? n2 : o2 + 1], t2[n2 < o2 + 2 ? n2 : o2 + 2], i2 - o2, r2);
      }, Utils: {Linear: function(t2, e2, r2, n2) {
        if (t2 === e2 || typeof t2 == "string") {
          if (e2.length && e2.splice && e2.isString) {
            e2 = "";
            for (var i2 = 0, o2 = t2.length; i2 < o2; i2++)
              e2 += t2[i2];
          }
          return e2;
        }
        if (typeof t2 == "number")
          return typeof t2 == "function" ? t2(r2) : t2 + (e2 - t2) * r2;
        if (m(t2) === "object") {
          if (t2.length !== void 0) {
            var s2 = typeof t2[0] == "string" || t2.isString;
            if (s2 || t2[0] === M) {
              for (var a2 = "", u2 = s2 ? 0 : 1, f2 = t2.length; u2 < f2; u2++) {
                var l2 = r2 === 0 ? t2[u2] : r2 !== 1 && typeof t2[u2] == "number" ? t2[u2] + (e2[u2] - t2[u2]) * r2 : e2[u2];
                (0 < r2 && r2 < 1 && Z(t2, u2) || Z(t2, u2, Y)) && (l2 |= 0), a2 += l2;
              }
              return a2;
            }
            if (n2 && n2.length && n2.splice)
              for (var h2 = 0, c2 = n2.length; h2 < c2; h2++)
                n2[h2] = ot.Utils.Linear(t2[h2], e2[h2], r2, n2[h2]);
          } else
            for (var p2 in n2)
              n2[p2] = ot.Utils.Linear(t2[p2], e2[p2], r2, n2[p2]);
          return n2;
        }
      }, Reset: function(t2) {
        if (Array.isArray(t2)) {
          for (var e2 = 0, r2 = t2.length; e2 < r2; e2++)
            t2[e2] = ot.Utils.Reset(t2[e2]);
          return t2;
        }
        if (m(t2) !== "object")
          return typeof t2 == "number" ? 0 : t2;
        for (var n2 in t2)
          t2[n2] = ot.Utils.Reset(t2[n2]);
        return t2;
      }, Bernstein: function(t2, e2) {
        var r2 = ot.Utils.Factorial;
        return r2(t2) / r2(e2) / r2(t2 - e2);
      }, Factorial: (et = [1], function(t2) {
        var e2 = 1;
        if (et[t2])
          return et[t2];
        for (var r2 = t2; 1 < r2; r2--)
          e2 *= r2;
        return et[t2] = e2;
      }), CatmullRom: function(t2, e2, r2, n2, i2, o2) {
        if (typeof t2 == "string")
          return e2;
        if (typeof t2 == "number") {
          var s2 = 0.5 * (r2 - t2), a2 = 0.5 * (n2 - e2), u2 = i2 * i2;
          return (2 * e2 - 2 * r2 + s2 + a2) * (i2 * u2) + (-3 * e2 + 3 * r2 - 2 * s2 - a2) * u2 + s2 * i2 + e2;
        }
        if (m(t2) === "object") {
          if (t2.length !== void 0) {
            if (t2[0] === M) {
              for (var f2 = "", l2 = 1, h2 = t2.length; l2 < h2; l2++) {
                var c2 = typeof t2[l2] == "number" ? ot.Utils.CatmullRom(t2[l2], e2[l2], r2[l2], n2[l2], i2) : n2[l2];
                (Z(t2, l2) || Z(t2, l2, Y)) && (c2 |= 0), f2 += c2;
              }
              return f2;
            }
            for (var p2 = 0, y2 = o2.length; p2 < y2; p2++)
              o2[p2] = ot.Utils.CatmullRom(t2[p2], e2[p2], r2[p2], n2[p2], i2, o2[p2]);
          } else
            for (var d2 in o2)
              o2[d2] = ot.Utils.CatmullRom(t2[d2], e2[d2], r2[d2], n2[d2], i2, o2[d2]);
          return o2;
        }
      }}}, st = {};
      function at(t2, e2, r2) {
        if (!t2 || !t2.nodeType)
          return e2;
        var n2 = t2.queueID || "q_" + Date.now();
        t2.queueID || (t2.queueID = n2);
        var i2 = st[n2];
        if (i2) {
          if (i2.object === e2 && t2 === i2.tween.node && r2._startTime === i2.tween._startTime)
            N(i2.tween);
          else if (m(e2) === "object" && e2 && i2.object) {
            for (var o2 in e2)
              o2 in i2.object && (r2._startTime === i2.tween._startTime ? delete i2.object[o2] : i2.propNormaliseRequired = true);
            Object.assign(i2.object, e2);
          }
          return i2.object;
        }
        return m(e2) === "object" && e2 ? (st[n2] = {tween: r2, object: e2, propNormaliseRequired: false}, st[n2].object) : e2;
      }
      function ut(t2, e2, r2) {
        return e2 ? t2 ? typeof window != "undefined" && t2 === window || typeof document != "undefined" && t2 === document ? [t2] : typeof t2 == "string" ? !!document.querySelectorAll && document.querySelectorAll(t2) : Array.isArray(t2) ? t2 : t2.nodeType ? [t2] : r2 ? t2 : [] : null : t2 ? typeof window != "undefined" && t2 === window || typeof document != "undefined" && t2 === document ? t2 : typeof t2 == "string" ? !!document.querySelector && document.querySelector(t2) : Array.isArray(t2) ? t2[0] : t2.nodeType || r2 ? t2 : null : null;
      }
      var ft = 0, lt = v.Linear.None, ht = function() {
        function L2(t2, e2) {
          return _(this, L2), this.id = ft++, !t2 || m(t2) !== "object" || e2 || t2.nodeType ? t2 && (t2.nodeType || t2.length || typeof t2 == "string") && (t2 = this.node = ut(t2), e2 = this.object = at(t2, e2, this)) : (e2 = this.object = t2, t2 = null), this._valuesEnd = null, this._valuesStart = Array.isArray(e2) ? [] : {}, this._duration = 1e3, this._easingFunction = lt, this._easingReverse = lt, this._interpolationFunction = ot.Linear, this._startTime = 0, this._initTime = 0, this._delayTime = 0, this._repeat = 0, this._r = 0, this._isPlaying = false, this._yoyo = false, this._reversed = false, this._onStartCallbackFired = false, this._pausedTime = null, this._isFinite = true, this._maxListener = 15, this._chainedTweensCount = 0, this._prevTime = null, this;
        }
        return b(L2, null, [{key: "fromTo", value: function(t2, e2, r2, n2) {
          var i2 = 3 < arguments.length && n2 !== void 0 ? n2 : {};
          i2.quickRender = i2.quickRender ? i2.quickRender : !r2;
          var o2 = new L2(t2, e2).to(r2, i2);
          return i2.quickRender && (o2.render().update(o2._startTime), o2._rendered = false, o2._onStartCallbackFired = false), o2;
        }}, {key: "to", value: function(t2, e2, r2) {
          return L2.fromTo(t2, null, e2, r2);
        }}, {key: "from", value: function(t2, e2, r2) {
          return L2.fromTo(t2, e2, null, r2);
        }}]), b(L2, [{key: "setMaxListener", value: function(t2) {
          var e2 = 0 < arguments.length && t2 !== void 0 ? t2 : 15;
          return this._maxListener = e2, this;
        }}, {key: "on", value: function(t2, e2) {
          for (var r2 = this._maxListener, n2 = t2 + E, i2 = 0; i2 < r2; i2++) {
            var o2 = n2 + i2;
            if (!this[o2]) {
              this[o2] = e2;
              break;
            }
          }
          return this;
        }}, {key: "once", value: function(t2, i2) {
          for (var o2 = this, e2 = this._maxListener, r2 = t2 + E, n2 = function(t3) {
            var n3 = r2 + t3;
            if (!o2[n3])
              return o2[n3] = function() {
                for (var t4 = arguments.length, e3 = new Array(t4), r3 = 0; r3 < t4; r3++)
                  e3[r3] = arguments[r3];
                i2.apply(o2, e3), o2[n3] = null;
              }, "break";
          }, s2 = 0; s2 < e2; s2++) {
            if (n2(s2) === "break")
              break;
          }
          return this;
        }}, {key: "off", value: function(t2, e2) {
          for (var r2 = this._maxListener, n2 = t2 + E, i2 = 0; i2 < r2; i2++) {
            var o2 = n2 + i2;
            this[o2] === e2 && (this[o2] = null);
          }
          return this;
        }}, {key: "emit", value: function(t2, e2, r2, n2) {
          var i2 = this._maxListener, o2 = t2 + E;
          if (!this[o2 + 0])
            return this;
          for (var s2 = 0; s2 < i2; s2++) {
            var a2 = o2 + s2;
            this[a2] && this[a2](e2, r2, n2);
          }
          return this;
        }}, {key: "isPlaying", value: function() {
          return this._isPlaying;
        }}, {key: "isStarted", value: function() {
          return this._onStartCallbackFired;
        }}, {key: "reverse", value: function(t2) {
          var e2 = this._reversed;
          return this._reversed = t2 !== void 0 ? t2 : !e2, this;
        }}, {key: "reversed", value: function() {
          return this._reversed;
        }}, {key: "pause", value: function() {
          return this._isPlaying ? (this._isPlaying = false, N(this), this._pausedTime = C(), this.emit("pause", this.object)) : this;
        }}, {key: "play", value: function() {
          return this._isPlaying ? this : (this._isPlaying = true, this._startTime += C() - this._pausedTime, this._initTime = this._startTime, s(this), this._pausedTime = C(), this.emit("play", this.object));
        }}, {key: "restart", value: function() {
          return this._repeat = this._r, this.reassignValues(), s(this), this.emit(P, this.object);
        }}, {key: "seek", value: function(t2, e2) {
          var r2 = this._duration, n2 = this._initTime, i2 = this._startTime, o2 = this._reversed, s2 = n2 + t2;
          return this._isPlaying = true, s2 < i2 && n2 <= i2 && (this._startTime -= r2, this._reversed = !o2), this.update(t2, false), this.emit("seek", t2, this.object), e2 ? this : this.pause();
        }}, {key: "duration", value: function(t2) {
          return this._duration = typeof t2 == "function" ? t2(this._duration) : t2, this;
        }}, {key: "to", value: function(t2, e2) {
          var r2 = 1 < arguments.length && e2 !== void 0 ? e2 : 1e3;
          if (this._valuesEnd = t2, typeof r2 == "number" || typeof r2 == "function")
            this._duration = typeof r2 == "function" ? r2(this._duration) : r2;
          else if (m(r2) === "object") {
            for (var n2 in r2)
              if (typeof this[n2] == "function") {
                var i2 = S(Array.isArray(r2[n2]) ? r2[n2] : [r2[n2]], 4), o2 = i2[0], s2 = o2 === void 0 ? null : o2, a2 = i2[1], u2 = a2 === void 0 ? null : a2, f2 = i2[2], l2 = f2 === void 0 ? null : f2, h2 = i2[3], c2 = h2 === void 0 ? null : h2;
                this[n2](s2, u2, l2, c2);
              }
          }
          return this;
        }}, {key: "render", value: function() {
          if (this._rendered)
            return this;
          var t2 = this._valuesStart, e2 = this._valuesEnd, r2 = this.object, n2 = this.node, i2 = this.InitialValues;
          if (tt(r2), tt(e2), n2 && n2.queueID && st[n2.queueID]) {
            var o2 = st[n2.queueID];
            if (o2.propNormaliseRequired && o2.tween !== this) {
              for (var s2 in e2)
                o2.tween._valuesEnd[s2];
              o2.normalisedProp = true, o2.propNormaliseRequired = false;
            }
          }
          if (n2 && i2 && (r2 && Object.keys(r2).length !== 0 ? e2 && Object.keys(e2).length !== 0 || (e2 = this._valuesEnd = i2(n2, r2)) : r2 = this.object = at(n2, i2(n2, e2), this)), !t2.processed) {
            for (var a2 in e2) {
              var u2 = r2 && r2[a2] && I(r2[a2]), f2 = e2[a2];
              if (!(q[a2] && q[a2].init && (q[a2].init.call(this, u2, f2, a2, r2), u2 === void 0 && t2[a2] && (u2 = t2[a2]), q[a2].skipProcess)) && !(typeof u2 == "number" && isNaN(u2) || u2 === null || f2 === null || u2 === false || f2 === false || u2 === void 0 || f2 === void 0 || u2 === f2)) {
                if (t2[a2] = u2, Array.isArray(f2))
                  if (Array.isArray(u2))
                    f2.isString && r2[a2].isString && !u2.isString ? u2.isString = true : X(a2, r2, t2, e2);
                  else {
                    f2.unshift(u2);
                    for (var l2 = 0, h2 = f2.length; l2 < h2; l2++)
                      typeof f2[l2] == "string" && (f2[l2] = H(f2[l2]));
                  }
                else
                  X(a2, r2, t2, e2);
                typeof u2 != "number" || typeof f2 != "string" || f2[1];
              }
            }
            t2.processed = true;
          }
          return L2.Renderer && this.node && L2.Renderer.init && (L2.Renderer.init.call(this, r2, t2, e2), this.__render = true), this._rendered = true, this;
        }}, {key: "start", value: function(t2) {
          return this._startTime = t2 !== void 0 ? typeof t2 == "string" ? C() + parseFloat(t2) : t2 : C(), this._startTime += this._delayTime, this._initTime = this._prevTime = this._startTime, this._onStartCallbackFired = false, this._rendered = false, this._isPlaying = true, s(this), this;
        }}, {key: "stop", value: function() {
          var t2 = this._isPlaying, e2 = this._isFinite, r2 = this.object, n2 = this._startTime, i2 = this._duration, o2 = this._r, s2 = this._yoyo, a2 = this._reversed;
          if (!t2)
            return this;
          var u2 = e2 ? (o2 + 1) % 2 == 1 : !a2;
          return this._reversed = false, s2 && u2 ? this.update(n2) : this.update(n2 + i2), N(this), this.emit("stop", r2);
        }}, {key: "delay", value: function(t2) {
          return this._delayTime = typeof t2 == "function" ? t2(this._delayTime) : t2, this;
        }}, {key: "chainedTweens", value: function() {
          if (this._chainedTweensCount = arguments.length, !this._chainedTweensCount)
            return this;
          for (var t2 = 0, e2 = this._chainedTweensCount; t2 < e2; t2++)
            this[U + t2] = arguments[t2];
          return this;
        }}, {key: "repeat", value: function(t2) {
          return this._repeat = this._duration ? typeof t2 == "function" ? t2(this._repeat) : t2 : 0, this._r = this._repeat, this._isFinite = isFinite(t2), this;
        }}, {key: "reverseDelay", value: function(t2) {
          return this._reverseDelayTime = typeof t2 == "function" ? t2(this._reverseDelayTime) : t2, this;
        }}, {key: "yoyo", value: function(t2, e2) {
          return this._yoyo = typeof t2 == "function" ? t2(this._yoyo) : t2 === null ? this._yoyo : t2, t2 || (this._reversed = false), this._easingReverse = e2 || null, this;
        }}, {key: "easing", value: function(t2) {
          return this._easingFunction = t2, this;
        }}, {key: "interpolation", value: function(t2) {
          return typeof t2 == "function" && (this._interpolationFunction = t2), this;
        }}, {key: "reassignValues", value: function(t2) {
          var e2 = this._valuesStart, r2 = this.object, n2 = this._delayTime;
          for (var i2 in this._isPlaying = true, this._startTime = t2 !== void 0 ? t2 : C(), this._startTime += n2, this._reversed = false, s(this), e2) {
            var o2 = e2[i2];
            r2[i2] = o2;
          }
          return this;
        }}, {key: "update", value: function(t2, e2, r2) {
          var n2, i2, o2, s2 = this._onStartCallbackFired, a2 = this._easingFunction, u2 = this._interpolationFunction, f2 = this._easingReverse, l2 = this._repeat, h2 = this._delayTime, c2 = this._reverseDelayTime, p2 = this._yoyo, y2 = this._reversed, d2 = this._startTime, v2 = this._prevTime, _2 = this._duration, m2 = this._valuesStart, g2 = this._valuesEnd, b2 = this.object, T2 = this._isFinite, O2 = this._isPlaying, w2 = this.__render, k2 = this._chainedTweensCount, j2 = 0;
          if (_2) {
            var A2 = (t2 = t2 !== void 0 ? t2 : C()) - v2;
            if (this._prevTime = t2, 250 < A2 && F() && x() && (t2 -= A2 - D), !O2 || t2 < d2 && !r2)
              return true;
            n2 = 1 < (n2 = (t2 - d2) / _2) ? 1 : n2, n2 = y2 ? 1 - n2 : n2;
          } else
            n2 = 1, l2 = 0;
          if (s2 || (this._rendered || (this.render(), this._rendered = true), this.emit(G, b2), this._onStartCallbackFired = true), i2 = y2 && f2 || a2, !b2)
            return true;
          for (o2 in g2) {
            var S2 = m2[o2];
            if (S2 != null || q[o2] && q[o2].update) {
              var E2 = g2[o2], P2 = i2[o2] ? i2[o2](n2) : (typeof i2 == "function" ? i2 : lt)(n2), M2 = u2[o2] ? u2[o2] : typeof u2 == "function" ? u2 : ot.Linear;
              typeof E2 == "number" ? b2[o2] = S2 + (E2 - S2) * P2 : !Array.isArray(E2) || E2.isString || Array.isArray(S2) ? E2 && E2.update ? E2.update(P2) : typeof E2 == "function" ? b2[o2] = E2(P2) : typeof E2 == "string" && typeof S2 == "number" ? b2[o2] = S2 + parseFloat(E2[0] + E2.substr(2)) * P2 : $(o2, b2, m2, g2, P2, n2) : b2[o2] = M2(E2, P2, b2[o2]), q[o2] && q[o2].update && q[o2].update.call(this, b2[o2], S2, E2, P2, n2, o2), j2++;
            }
          }
          if (!j2)
            return N(this), false;
          if (w2 && L2.Renderer && L2.Renderer.update && L2.Renderer.update.call(this, b2, n2), this.emit(V, b2, n2, t2), n2 === 1 || y2 && n2 === 0) {
            if (0 < l2 && 0 < _2) {
              if (T2 && this._repeat--, p2)
                this._reversed = !y2;
              else
                for (o2 in g2) {
                  var R2 = g2[o2];
                  typeof R2 == "string" && typeof m2[o2] == "number" && (m2[o2] += parseFloat(R2[0] + R2.substr(2)));
                }
              return this.emit(p2 && !y2 ? Q : z, b2), this._startTime = y2 && c2 ? t2 - c2 : t2 + h2, true;
            }
            if (e2 || (this._isPlaying = false, N(this), ft--), this.emit(B, b2), this._repeat = this._r, k2)
              for (var I2 = 0; I2 < k2; I2++)
                this[U + I2].start(t2 + _2);
            return false;
          }
          return true;
        }}]), L2;
      }(), ct = function() {
        function t2() {
          _(this, t2), this.totalTime = 0, this.labels = [], this.offsets = [];
        }
        return b(t2, [{key: "parseLabel", value: function(t3, e2) {
          var r2 = this.offsets, n2 = this.labels, i2 = n2.indexOf(t3);
          if (typeof t3 == "string" && t3.indexOf("=") !== -1 && !e2 && i2 === -1) {
            var o2 = t3.substr(t3.indexOf("=") - 1, 2), s2 = t3.split(o2);
            e2 = s2.length === 2 ? o2 + s2[1] : null, t3 = s2[0], i2 = n2.indexOf(t3);
          }
          if (i2 !== -1 && t3) {
            var a2 = r2[i2] || 0;
            if (typeof e2 == "number")
              a2 = e2;
            else if (typeof e2 == "string" && e2.indexOf("=") !== -1) {
              var u2 = e2.charAt(0);
              e2 = Number(e2.substr(2)), u2 === "+" || u2 === "-" ? a2 += parseFloat(u2 + e2) : u2 === "*" ? a2 *= e2 : u2 === "/" ? a2 /= e2 : u2 === "%" && (a2 *= e2 / 100);
            }
            return a2;
          }
          return typeof e2 == "number" ? e2 : 0;
        }}, {key: "addLabel", value: function(t3, e2) {
          return this.labels.push(t3), this.offsets.push(this.parseLabel(t3, e2)), this;
        }}, {key: "setLabel", value: function(t3, e2) {
          var r2 = this.labels.indexOf(t3);
          return r2 !== -1 && this.offsets.splice(r2, 1, this.parseLabel(t3, e2)), this;
        }}, {key: "eraseLabel", value: function(t3) {
          var e2 = this.labels.indexOf(t3);
          return e2 !== -1 && (this.labels.splice(e2, 1), this.offsets.splice(e2, 1)), this;
        }}]), t2;
      }(), pt = 0, yt = function() {
        function r2(t2) {
          var e2;
          return _(this, r2), (e2 = A(this, w(r2).call(this)))._duration = 0, e2._startTime = t2 && t2.startTime !== void 0 ? t2.startTime : C(), e2._tweens = [], e2.elapsed = 0, e2._id = pt++, e2._defaultParams = t2, e2.position = new ct(), e2.position.addLabel("afterLast", e2._duration), e2.position.addLabel("afterInit", e2._startTime), e2._onStartCallbackFired = false, A(e2, j(e2));
        }
        return function(t2, e2) {
          if (typeof e2 != "function" && e2 !== null)
            throw new TypeError("Super expression must either be null or a function");
          t2.prototype = Object.create(e2 && e2.prototype, {constructor: {value: t2, writable: true, configurable: true}}), e2 && k(t2, e2);
        }(r2, ht), b(r2, [{key: "mapTotal", value: function(t2) {
          return t2.call(this, this._tweens), this;
        }}, {key: "timingOrder", value: function(t2) {
          var r3 = t2(this._tweens.map(function(t3) {
            return t3._startTime;
          }));
          return this._tweens.map(function(t3, e2) {
            t3._startTime = r3[e2];
          }), this;
        }}, {key: "getTiming", value: function(t2, e2, r3, n2) {
          var i2 = 3 < arguments.length && n2 !== void 0 ? n2 : 0;
          if (t2 === "reverse") {
            var o2 = r3.stagger, s2 = (o2 || 0) * (e2.length - 1);
            return e2.map(function(t3, e3) {
              return s2 - (o2 || 0) * e3 + i2;
            });
          }
          if (t2 === "async")
            return e2.map(function(t3) {
              return i2;
            });
          if (t2 === "sequence" || t2 === "delayed") {
            var a2 = r3.stagger;
            return a2 = a2 || (r3.duration || 1e3) / (e2.length - 1), e2.map(function(t3, e3) {
              return a2 * e3 + i2;
            });
          }
          if (t2 === "oneByOne")
            return e2.map(function(t3) {
              return r3.duration;
            });
          if (t2 === "shuffle") {
            var u2 = r3.stagger;
            return function(t3) {
              var e3, r4, n3;
              for (n3 = t3.length; n3; --n3)
                e3 = Math.floor(Math.random() * n3), r4 = t3[n3 - 1], t3[n3 - 1] = t3[e3], t3[e3] = r4;
              return t3;
            }(e2.map(function(t3, e3) {
              return (u2 || 0) * e3 + i2;
            }));
          }
          var f2 = r3.stagger;
          return e2.map(function(t3, e3) {
            return (f2 || 0) * e3 + i2;
          });
        }}, {key: "fromTo", value: function(t2, e2, r3, n2) {
          if ((t2 = ut(t2, true, true)) && t2.length) {
            this._defaultParams && (n2 = n2 ? O({}, this._defaultParams, {}, n2) : this._defaultParams);
            for (var i2, o2 = n2.label, s2 = typeof o2 == "number" ? o2 : this.position.parseLabel(o2 !== void 0 ? o2 : "afterLast", null), a2 = this.getTiming(n2.mode, t2, n2, s2), u2 = 0, f2 = t2.length; u2 < f2; u2++)
              i2 = t2[u2], this.add(ht.fromTo(i2, typeof e2 == "function" ? e2(u2, t2.length) : m(e2) === "object" && e2 ? O({}, e2) : null, typeof r3 == "function" ? r3(u2, t2.length) : r3, typeof n2 == "function" ? n2(u2, t2.length) : n2), a2[u2]);
          }
          return this.start();
        }}, {key: "from", value: function(t2, e2, r3) {
          return this.fromTo(t2, e2, null, r3);
        }}, {key: "to", value: function(t2, e2, r3) {
          return this.fromTo(t2, null, e2, r3);
        }}, {key: "addLabel", value: function(t2, e2) {
          return this.position.addLabel(t2, e2), this;
        }}, {key: "map", value: function(t2) {
          for (var e2 = 0, r3 = this._tweens.length; e2 < r3; e2++) {
            var n2 = this._tweens[e2];
            t2(n2, e2), this._duration = Math.max(this._duration, n2._duration + n2._startTime);
          }
          return this;
        }}, {key: "add", value: function(t2, e2) {
          var r3 = this;
          if (Array.isArray(t2))
            return t2.map(function(t3) {
              r3.add(t3, e2);
            }), this;
          m(t2) !== "object" || t2 instanceof ht || (t2 = new ht(t2.from).to(t2.to, t2));
          var n2 = this._defaultParams, i2 = this._duration;
          if (n2)
            for (var o2 in n2)
              typeof t2[o2] == "function" && t2[o2](n2[o2]);
          var s2 = typeof e2 == "number" ? e2 : this.position.parseLabel(e2 !== void 0 ? e2 : "afterLast", null);
          return t2._startTime = Math.max(this._startTime, t2._delayTime, s2), t2._delayTime = s2, t2._isPlaying = true, this._duration = Math.max(i2, Math.max(t2._startTime + t2._delayTime, t2._duration)), this._tweens.push(t2), this.position.setLabel("afterLast", this._duration), this;
        }}, {key: "restart", value: function() {
          return this._startTime += C(), s(this), this.emit(P);
        }}, {key: "easing", value: function(e2) {
          return this.map(function(t2) {
            return t2.easing(e2);
          });
        }}, {key: "interpolation", value: function(e2) {
          return this.map(function(t2) {
            return t2.interpolation(e2);
          });
        }}, {key: "update", value: function(t2) {
          var e2, r3 = this._tweens, n2 = this._duration, i2 = this._reverseDelayTime, o2 = this._startTime, s2 = this._reversed, a2 = this._yoyo, u2 = this._repeat, f2 = this._isFinite, l2 = this._isPlaying, h2 = this._prevTime, c2 = this._onStartCallbackFired, p2 = (t2 = t2 !== void 0 ? t2 : C()) - h2;
          if (this._prevTime = t2, 250 < p2 && F() && x() && (t2 -= p2 - D), !l2 || t2 < o2)
            return true;
          e2 = 1 < (e2 = (t2 - o2) / n2) ? 1 : e2, e2 = s2 ? 1 - e2 : e2, this.elapsed = e2, c2 || (this.emit(G), this._onStartCallbackFired = true);
          for (var y2 = t2 - o2, d2 = s2 ? n2 - y2 : y2, v2 = 0; v2 < r3.length; )
            r3[v2].update(d2), v2++;
          if (this.emit(V, e2, y2), e2 === 1 || s2 && e2 === 0) {
            if (u2) {
              for (f2 && this._repeat--, this.emit(s2 ? Q : z), a2 && (this._reversed = !s2, this.timingOrder(function(t3) {
                return t3.reverse();
              })), this._startTime = s2 && i2 ? t2 + i2 : t2, v2 = 0; v2 < r3.length; )
                r3[v2].reassignValues(t2), v2++;
              return true;
            }
            return this.emit(B), this._repeat = this._r, N(this), this._isPlaying = false;
          }
          return true;
        }}, {key: "progress", value: function(t2) {
          return t2 !== void 0 ? this.update(t2 * this._duration) : this.elapsed;
        }}]), r2;
      }();
      t.Easing = v, t.FrameThrottle = function(t2) {
        y = 1.05 * (0 < arguments.length && t2 !== void 0 ? t2 : 120);
      }, t.Interpolation = ot, t.Interpolator = function(i2, o2) {
        var s2 = Array.isArray(i2) && !i2.isString, a2 = typeof i2 == "string" ? i2 : s2 ? i2.slice() : O({}, i2);
        if (s2)
          for (var t2 = 0, e2 = i2.length; t2 < e2; t2++)
            i2[t2] === o2[t2] && typeof i2[t2] == "number" && typeof o2[t2] != "number" || X(t2, a2, i2, o2);
        else if (m(i2) === "object")
          for (var r2 in i2)
            i2[r2] === o2[r2] && typeof i2[r2] == "number" && typeof o2[r2] != "number" || X(r2, a2, i2, o2);
        else if (typeof i2 == "string") {
          i2 = H(i2), o2 = H(o2);
          for (var n2 = 1; n2 < i2.length; )
            i2[n2] === o2[n2] && typeof i2[n2 - 1] == "string" ? (i2.splice(n2 - 1, 2, i2[n2 - 1] + i2[n2]), o2.splice(n2 - 1, 2, o2[n2 - 1] + o2[n2])) : n2++;
        }
        return function(t3) {
          if (s2)
            for (var e3 = 0, r3 = i2.length; e3 < r3; e3++)
              $(e3, a2, i2, o2, t3);
          else if (m(a2) === "object")
            for (var n3 in i2)
              $(n3, a2, i2, o2, t3);
          else
            typeof a2 == "string" && (a2 = $(0, 0, i2, o2, t3, t3, true));
          return a2;
        };
      }, t.Plugins = q, t.Selector = ut, t.Timeline = yt, t.ToggleLagSmoothing = function(t2) {
        d = !(0 < arguments.length && t2 !== void 0) || t2;
      }, t.Tween = ht, t.add = s, t.autoPlay = function(t2) {
        l = t2;
      }, t.get = e, t.getAll = function() {
        return u;
      }, t.has = function(t2) {
        return e(t2) !== null;
      }, t.isRunning = F, t.now = C, t.onRequestTick = function(t2) {
        h.push(t2);
      }, t.onTick = function(t2) {
        return u.push({update: t2});
      }, t.remove = N, t.removeAll = function() {
        u.length = 0, a(o), f = false;
      }, t.update = i, t.utils = it, Object.defineProperty(t, "__esModule", {value: true});
    });
  });

  // app/settings.js
  var settings = {
    document_title: "PROCESSING ARCHITECTURE - AAA21",
    title: `//&nbsp;2021 //&nbsp;PROCESSING //&nbsp;ARCHITECTURE`,
    background_color: "#000000"
  };

  // node_modules/three/build/three.module.js
  var REVISION = "123";
  var MOUSE = {LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2};
  var TOUCH = {ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3};
  var CullFaceNone = 0;
  var CullFaceBack = 1;
  var CullFaceFront = 2;
  var PCFShadowMap = 1;
  var PCFSoftShadowMap = 2;
  var VSMShadowMap = 3;
  var FrontSide = 0;
  var BackSide = 1;
  var DoubleSide = 2;
  var FlatShading = 1;
  var NoBlending = 0;
  var NormalBlending = 1;
  var AdditiveBlending = 2;
  var SubtractiveBlending = 3;
  var MultiplyBlending = 4;
  var CustomBlending = 5;
  var AddEquation = 100;
  var SubtractEquation = 101;
  var ReverseSubtractEquation = 102;
  var MinEquation = 103;
  var MaxEquation = 104;
  var ZeroFactor = 200;
  var OneFactor = 201;
  var SrcColorFactor = 202;
  var OneMinusSrcColorFactor = 203;
  var SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = 205;
  var DstAlphaFactor = 206;
  var OneMinusDstAlphaFactor = 207;
  var DstColorFactor = 208;
  var OneMinusDstColorFactor = 209;
  var SrcAlphaSaturateFactor = 210;
  var NeverDepth = 0;
  var AlwaysDepth = 1;
  var LessDepth = 2;
  var LessEqualDepth = 3;
  var EqualDepth = 4;
  var GreaterEqualDepth = 5;
  var GreaterDepth = 6;
  var NotEqualDepth = 7;
  var MultiplyOperation = 0;
  var MixOperation = 1;
  var AddOperation = 2;
  var NoToneMapping = 0;
  var LinearToneMapping = 1;
  var ReinhardToneMapping = 2;
  var CineonToneMapping = 3;
  var ACESFilmicToneMapping = 4;
  var CustomToneMapping = 5;
  var UVMapping = 300;
  var CubeReflectionMapping = 301;
  var CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = 304;
  var CubeUVReflectionMapping = 306;
  var CubeUVRefractionMapping = 307;
  var RepeatWrapping = 1e3;
  var ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = 1002;
  var NearestFilter = 1003;
  var NearestMipmapNearestFilter = 1004;
  var NearestMipmapLinearFilter = 1005;
  var LinearFilter = 1006;
  var LinearMipmapNearestFilter = 1007;
  var LinearMipmapLinearFilter = 1008;
  var UnsignedByteType = 1009;
  var ByteType = 1010;
  var ShortType = 1011;
  var UnsignedShortType = 1012;
  var IntType = 1013;
  var UnsignedIntType = 1014;
  var FloatType = 1015;
  var HalfFloatType = 1016;
  var UnsignedShort4444Type = 1017;
  var UnsignedShort5551Type = 1018;
  var UnsignedShort565Type = 1019;
  var UnsignedInt248Type = 1020;
  var AlphaFormat = 1021;
  var RGBFormat = 1022;
  var RGBAFormat = 1023;
  var LuminanceFormat = 1024;
  var LuminanceAlphaFormat = 1025;
  var DepthFormat = 1026;
  var DepthStencilFormat = 1027;
  var RedFormat = 1028;
  var RedIntegerFormat = 1029;
  var RGFormat = 1030;
  var RGIntegerFormat = 1031;
  var RGBIntegerFormat = 1032;
  var RGBAIntegerFormat = 1033;
  var RGB_S3TC_DXT1_Format = 33776;
  var RGBA_S3TC_DXT1_Format = 33777;
  var RGBA_S3TC_DXT3_Format = 33778;
  var RGBA_S3TC_DXT5_Format = 33779;
  var RGB_PVRTC_4BPPV1_Format = 35840;
  var RGB_PVRTC_2BPPV1_Format = 35841;
  var RGBA_PVRTC_4BPPV1_Format = 35842;
  var RGBA_PVRTC_2BPPV1_Format = 35843;
  var RGB_ETC1_Format = 36196;
  var RGB_ETC2_Format = 37492;
  var RGBA_ETC2_EAC_Format = 37496;
  var RGBA_ASTC_4x4_Format = 37808;
  var RGBA_ASTC_5x4_Format = 37809;
  var RGBA_ASTC_5x5_Format = 37810;
  var RGBA_ASTC_6x5_Format = 37811;
  var RGBA_ASTC_6x6_Format = 37812;
  var RGBA_ASTC_8x5_Format = 37813;
  var RGBA_ASTC_8x6_Format = 37814;
  var RGBA_ASTC_8x8_Format = 37815;
  var RGBA_ASTC_10x5_Format = 37816;
  var RGBA_ASTC_10x6_Format = 37817;
  var RGBA_ASTC_10x8_Format = 37818;
  var RGBA_ASTC_10x10_Format = 37819;
  var RGBA_ASTC_12x10_Format = 37820;
  var RGBA_ASTC_12x12_Format = 37821;
  var RGBA_BPTC_Format = 36492;
  var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
  var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
  var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
  var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
  var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
  var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
  var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
  var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
  var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
  var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
  var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
  var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
  var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
  var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
  var LoopOnce = 2200;
  var LoopRepeat = 2201;
  var LoopPingPong = 2202;
  var InterpolateDiscrete = 2300;
  var InterpolateLinear = 2301;
  var InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = 2401;
  var WrapAroundEnding = 2402;
  var NormalAnimationBlendMode = 2500;
  var AdditiveAnimationBlendMode = 2501;
  var TrianglesDrawMode = 0;
  var LinearEncoding = 3e3;
  var sRGBEncoding = 3001;
  var GammaEncoding = 3007;
  var RGBEEncoding = 3002;
  var LogLuvEncoding = 3003;
  var RGBM7Encoding = 3004;
  var RGBM16Encoding = 3005;
  var RGBDEncoding = 3006;
  var BasicDepthPacking = 3200;
  var RGBADepthPacking = 3201;
  var TangentSpaceNormalMap = 0;
  var ObjectSpaceNormalMap = 1;
  var KeepStencilOp = 7680;
  var AlwaysStencilFunc = 519;
  var StaticDrawUsage = 35044;
  var DynamicDrawUsage = 35048;
  var GLSL3 = "300 es";
  function EventDispatcher() {
  }
  Object.assign(EventDispatcher.prototype, {
    addEventListener: function(type, listener) {
      if (this._listeners === void 0)
        this._listeners = {};
      const listeners = this._listeners;
      if (listeners[type] === void 0) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    },
    hasEventListener: function(type, listener) {
      if (this._listeners === void 0)
        return false;
      const listeners = this._listeners;
      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
    },
    removeEventListener: function(type, listener) {
      if (this._listeners === void 0)
        return;
      const listeners = this._listeners;
      const listenerArray = listeners[type];
      if (listenerArray !== void 0) {
        const index = listenerArray.indexOf(listener);
        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    },
    dispatchEvent: function(event) {
      if (this._listeners === void 0)
        return;
      const listeners = this._listeners;
      const listenerArray = listeners[event.type];
      if (listenerArray !== void 0) {
        event.target = this;
        const array = listenerArray.slice(0);
        for (let i = 0, l = array.length; i < l; i++) {
          array[i].call(this, event);
        }
      }
    }
  });
  var _lut = [];
  for (let i = 0; i < 256; i++) {
    _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
  }
  var _seed = 1234567;
  var MathUtils = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
      const d0 = Math.random() * 4294967295 | 0;
      const d1 = Math.random() * 4294967295 | 0;
      const d2 = Math.random() * 4294967295 | 0;
      const d3 = Math.random() * 4294967295 | 0;
      const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
      return uuid.toUpperCase();
    },
    clamp: function(value, min, max) {
      return Math.max(min, Math.min(max, value));
    },
    euclideanModulo: function(n, m) {
      return (n % m + m) % m;
    },
    mapLinear: function(x, a1, a2, b1, b2) {
      return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    },
    lerp: function(x, y, t) {
      return (1 - t) * x + t * y;
    },
    smoothstep: function(x, min, max) {
      if (x <= min)
        return 0;
      if (x >= max)
        return 1;
      x = (x - min) / (max - min);
      return x * x * (3 - 2 * x);
    },
    smootherstep: function(x, min, max) {
      if (x <= min)
        return 0;
      if (x >= max)
        return 1;
      x = (x - min) / (max - min);
      return x * x * x * (x * (x * 6 - 15) + 10);
    },
    randInt: function(low, high) {
      return low + Math.floor(Math.random() * (high - low + 1));
    },
    randFloat: function(low, high) {
      return low + Math.random() * (high - low);
    },
    randFloatSpread: function(range) {
      return range * (0.5 - Math.random());
    },
    seededRandom: function(s) {
      if (s !== void 0)
        _seed = s % 2147483647;
      _seed = _seed * 16807 % 2147483647;
      return (_seed - 1) / 2147483646;
    },
    degToRad: function(degrees) {
      return degrees * MathUtils.DEG2RAD;
    },
    radToDeg: function(radians) {
      return radians * MathUtils.RAD2DEG;
    },
    isPowerOfTwo: function(value) {
      return (value & value - 1) === 0 && value !== 0;
    },
    ceilPowerOfTwo: function(value) {
      return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    },
    floorPowerOfTwo: function(value) {
      return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    },
    setQuaternionFromProperEuler: function(q, a, b, c, order) {
      const cos = Math.cos;
      const sin = Math.sin;
      const c2 = cos(b / 2);
      const s2 = sin(b / 2);
      const c13 = cos((a + c) / 2);
      const s13 = sin((a + c) / 2);
      const c1_3 = cos((a - c) / 2);
      const s1_3 = sin((a - c) / 2);
      const c3_1 = cos((c - a) / 2);
      const s3_1 = sin((c - a) / 2);
      switch (order) {
        case "XYX":
          q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
          break;
        case "YZY":
          q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
          break;
        case "ZXZ":
          q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
          break;
        case "XZX":
          q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
          break;
        case "YXY":
          q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
          break;
        case "ZYZ":
          q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
          break;
        default:
          console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
      }
    }
  };
  var Vector2 = class {
    constructor(x = 0, y = 0) {
      Object.defineProperty(this, "isVector2", {value: true});
      this.x = x;
      this.y = y;
    }
    get width() {
      return this.x;
    }
    set width(value) {
      this.x = value;
    }
    get height() {
      return this.y;
    }
    set height(value) {
      this.y = value;
    }
    set(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    }
    add(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      return this;
    }
    sub(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
      const x = this.x, y = this.y;
      const e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6];
      this.y = e[1] * x + e[4] * y + e[7];
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y;
    }
    cross(v) {
      return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      const angle = Math.atan2(-this.y, -this.x) + Math.PI;
      return angle;
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y;
      return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    }
    rotateAround(center, angle) {
      const c = Math.cos(angle), s = Math.sin(angle);
      const x = this.x - center.x;
      const y = this.y - center.y;
      this.x = x * c - y * s + center.x;
      this.y = x * s + y * c + center.y;
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      return this;
    }
  };
  var Matrix3 = class {
    constructor() {
      Object.defineProperty(this, "isMatrix3", {value: true});
      this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      if (arguments.length > 0) {
        console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
      }
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      const te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    }
    identity() {
      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
      return this;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
    setFromMatrix4(m) {
      const me = m.elements;
      this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
      return this;
    }
    multiply(m) {
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
      const ae = a.elements;
      const be = b.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[3], a13 = ae[6];
      const a21 = ae[1], a22 = ae[4], a23 = ae[7];
      const a31 = ae[2], a32 = ae[5], a33 = ae[8];
      const b11 = be[0], b12 = be[3], b13 = be[6];
      const b21 = be[1], b22 = be[4], b23 = be[7];
      const b31 = be[2], b32 = be[5], b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    }
    determinant() {
      const te = this.elements;
      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    }
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
    transpose() {
      let tmp2;
      const m = this.elements;
      tmp2 = m[1];
      m[1] = m[3];
      m[3] = tmp2;
      tmp2 = m[2];
      m[2] = m[6];
      m[6] = tmp2;
      tmp2 = m[5];
      m[5] = m[7];
      m[7] = tmp2;
      return this;
    }
    getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).copy(this).invert().transpose();
    }
    transposeIntoArray(r) {
      const m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      const c = Math.cos(rotation);
      const s = Math.sin(rotation);
      this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    }
    scale(sx, sy) {
      const te = this.elements;
      te[0] *= sx;
      te[3] *= sx;
      te[6] *= sx;
      te[1] *= sy;
      te[4] *= sy;
      te[7] *= sy;
      return this;
    }
    rotate(theta) {
      const c = Math.cos(theta);
      const s = Math.sin(theta);
      const te = this.elements;
      const a11 = te[0], a12 = te[3], a13 = te[6];
      const a21 = te[1], a22 = te[4], a23 = te[7];
      te[0] = c * a11 + s * a21;
      te[3] = c * a12 + s * a22;
      te[6] = c * a13 + s * a23;
      te[1] = -s * a11 + c * a21;
      te[4] = -s * a12 + c * a22;
      te[7] = -s * a13 + c * a23;
      return this;
    }
    translate(tx, ty) {
      const te = this.elements;
      te[0] += tx * te[2];
      te[3] += tx * te[5];
      te[6] += tx * te[8];
      te[1] += ty * te[2];
      te[4] += ty * te[5];
      te[7] += ty * te[8];
      return this;
    }
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i = 0; i < 9; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < 9; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
  };
  var _canvas;
  var ImageUtils = {
    getDataURL: function(image) {
      if (/^data:/i.test(image.src)) {
        return image.src;
      }
      if (typeof HTMLCanvasElement == "undefined") {
        return image.src;
      }
      let canvas;
      if (image instanceof HTMLCanvasElement) {
        canvas = image;
      } else {
        if (_canvas === void 0)
          _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        _canvas.width = image.width;
        _canvas.height = image.height;
        const context = _canvas.getContext("2d");
        if (image instanceof ImageData) {
          context.putImageData(image, 0, 0);
        } else {
          context.drawImage(image, 0, 0, image.width, image.height);
        }
        canvas = _canvas;
      }
      if (canvas.width > 2048 || canvas.height > 2048) {
        return canvas.toDataURL("image/jpeg", 0.6);
      } else {
        return canvas.toDataURL("image/png");
      }
    }
  };
  var textureId = 0;
  function Texture(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    Object.defineProperty(this, "id", {value: textureId++});
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.version = 0;
    this.onUpdate = null;
  }
  Texture.DEFAULT_IMAGE = void 0;
  Texture.DEFAULT_MAPPING = UVMapping;
  Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Texture,
    isTexture: true,
    updateMatrix: function() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.name = source.name;
      this.image = source.image;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.internalFormat = source.internalFormat;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.encoding = source.encoding;
      return this;
    },
    toJSON: function(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.textures[this.uuid] !== void 0) {
        return meta.textures[this.uuid];
      }
      const output = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (this.image !== void 0) {
        const image = this.image;
        if (image.uuid === void 0) {
          image.uuid = MathUtils.generateUUID();
        }
        if (!isRootObject && meta.images[image.uuid] === void 0) {
          let url;
          if (Array.isArray(image)) {
            url = [];
            for (let i = 0, l = image.length; i < l; i++) {
              if (image[i].isDataTexture) {
                url.push(serializeImage(image[i].image));
              } else {
                url.push(serializeImage(image[i]));
              }
            }
          } else {
            url = serializeImage(image);
          }
          meta.images[image.uuid] = {
            uuid: image.uuid,
            url
          };
        }
        output.image = image.uuid;
      }
      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }
      return output;
    },
    dispose: function() {
      this.dispatchEvent({type: "dispose"});
    },
    transformUv: function(uv) {
      if (this.mapping !== UVMapping)
        return uv;
      uv.applyMatrix3(this.matrix);
      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;
          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }
            break;
        }
      }
      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;
          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }
            break;
        }
      }
      if (this.flipY) {
        uv.y = 1 - uv.y;
      }
      return uv;
    }
  });
  Object.defineProperty(Texture.prototype, "needsUpdate", {
    set: function(value) {
      if (value === true)
        this.version++;
    }
  });
  function serializeImage(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return ImageUtils.getDataURL(image);
    } else {
      if (image.data) {
        return {
          data: Array.prototype.slice.call(image.data),
          width: image.width,
          height: image.height,
          type: image.data.constructor.name
        };
      } else {
        console.warn("THREE.Texture: Unable to serialize Texture.");
        return {};
      }
    }
  }
  var Vector4 = class {
    constructor(x = 0, y = 0, z = 0, w = 1) {
      Object.defineProperty(this, "isVector4", {value: true});
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    get width() {
      return this.z;
    }
    set width(value) {
      this.z = value;
    }
    get height() {
      return this.w;
    }
    set height(value) {
      this.w = value;
    }
    set(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setZ(z) {
      this.z = z;
      return this;
    }
    setW(w) {
      this.w = w;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        case 3:
          this.w = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.w !== void 0 ? v.w : 1;
      return this;
    }
    add(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      this.w += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      this.w += v.w * s;
      return this;
    }
    sub(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      this.w -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    }
    applyMatrix4(m) {
      const x = this.x, y = this.y, z = this.z, w = this.w;
      const e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
      this.w = 2 * Math.acos(q.w);
      const s = Math.sqrt(1 - q.w * q.w);
      if (s < 1e-4) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q.x / s;
        this.y = q.y / s;
        this.z = q.z / s;
      }
      return this;
    }
    setAxisAngleFromRotationMatrix(m) {
      let angle, x, y, z;
      const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          this.set(1, 0, 0, 0);
          return this;
        }
        angle = Math.PI;
        const xx = (m11 + 1) / 2;
        const yy = (m22 + 1) / 2;
        const zz = (m33 + 1) / 2;
        const xy = (m12 + m21) / 4;
        const xz = (m13 + m31) / 4;
        const yz = (m23 + m32) / 4;
        if (xx > yy && xx > zz) {
          if (xx < epsilon) {
            x = 0;
            y = 0.707106781;
            z = 0.707106781;
          } else {
            x = Math.sqrt(xx);
            y = xy / x;
            z = xz / x;
          }
        } else if (yy > zz) {
          if (yy < epsilon) {
            x = 0.707106781;
            y = 0;
            z = 0.707106781;
          } else {
            y = Math.sqrt(yy);
            x = xy / y;
            z = yz / y;
          }
        } else {
          if (zz < epsilon) {
            x = 0.707106781;
            y = 0.707106781;
            z = 0;
          } else {
            z = Math.sqrt(zz);
            x = xz / z;
            y = yz / z;
          }
        }
        this.set(x, y, z, angle);
        return this;
      }
      let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
      if (Math.abs(s) < 1e-3)
        s = 1;
      this.x = (m32 - m23) / s;
      this.y = (m13 - m31) / s;
      this.z = (m21 - m12) / s;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      this.w = Math.min(this.w, v.w);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      this.w = Math.max(this.w, v.w);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      this.w = Math.max(min.w, Math.min(max.w, this.w));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      this.w = Math.max(minVal, Math.min(maxVal, this.w));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      this.w += (v.w - this.w) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      this.w = v1.w + (v2.w - v1.w) * alpha;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      this.w = attribute.getW(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      this.w = Math.random();
      return this;
    }
  };
  function WebGLRenderTarget(width, height, options) {
    this.width = width;
    this.height = height;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options = options || {};
    this.texture = new Texture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.image = {};
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
  }
  WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: WebGLRenderTarget,
    isWebGLRenderTarget: true,
    setSize: function(width, height) {
      if (this.width !== width || this.height !== height) {
        this.width = width;
        this.height = height;
        this.texture.image.width = width;
        this.texture.image.height = height;
        this.dispose();
      }
      this.viewport.set(0, 0, width, height);
      this.scissor.set(0, 0, width, height);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.width = source.width;
      this.height = source.height;
      this.viewport.copy(source.viewport);
      this.texture = source.texture.clone();
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.depthTexture = source.depthTexture;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({type: "dispose"});
    }
  });
  function WebGLMultisampleRenderTarget(width, height, options) {
    WebGLRenderTarget.call(this, width, height, options);
    this.samples = 4;
  }
  WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
    constructor: WebGLMultisampleRenderTarget,
    isWebGLMultisampleRenderTarget: true,
    copy: function(source) {
      WebGLRenderTarget.prototype.copy.call(this, source);
      this.samples = source.samples;
      return this;
    }
  });
  var Quaternion = class {
    constructor(x = 0, y = 0, z = 0, w = 1) {
      Object.defineProperty(this, "isQuaternion", {value: true});
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
    }
    static slerp(qa, qb, qm, t) {
      return qm.copy(qa).slerp(qb, t);
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        let s = 1 - t;
        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
        if (sqrSin > Number.EPSILON) {
          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
          s = Math.sin(s * len) / sin;
          t = Math.sin(t * len) / sin;
        }
        const tDir = t * dir;
        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir;
        if (s === 1 - t) {
          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      const x0 = src0[srcOffset0];
      const y0 = src0[srcOffset0 + 1];
      const z0 = src0[srcOffset0 + 2];
      const w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1];
      const y1 = src1[srcOffset1 + 1];
      const z1 = src1[srcOffset1 + 2];
      const w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(value) {
      this._w = value;
      this._onChangeCallback();
    }
    set(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this._onChangeCallback();
      return this;
    }
    setFromEuler(euler, update2) {
      if (!(euler && euler.isEuler)) {
        throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
      const cos = Math.cos;
      const sin = Math.sin;
      const c1 = cos(x / 2);
      const c2 = cos(y / 2);
      const c3 = cos(z / 2);
      const s1 = sin(x / 2);
      const s2 = sin(y / 2);
      const s3 = sin(z / 2);
      switch (order) {
        case "XYZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "YXZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "ZXY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "ZYX":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "YZX":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "XZY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
      }
      if (update2 !== false)
        this._onChangeCallback();
      return this;
    }
    setFromAxisAngle(axis, angle) {
      const halfAngle = angle / 2, s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m) {
      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
      if (trace > 0) {
        const s = 0.5 / Math.sqrt(trace + 1);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this._w = (m32 - m23) / s;
        this._x = 0.25 * s;
        this._y = (m12 + m21) / s;
        this._z = (m13 + m31) / s;
      } else if (m22 > m33) {
        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this._w = (m13 - m31) / s;
        this._x = (m12 + m21) / s;
        this._y = 0.25 * s;
        this._z = (m23 + m32) / s;
      } else {
        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this._w = (m21 - m12) / s;
        this._x = (m13 + m31) / s;
        this._y = (m23 + m32) / s;
        this._z = 0.25 * s;
      }
      this._onChangeCallback();
      return this;
    }
    setFromUnitVectors(vFrom, vTo) {
      const EPS = 1e-6;
      let r = vFrom.dot(vTo) + 1;
      if (r < EPS) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }
      return this.normalize();
    }
    angleTo(q) {
      return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
      const angle = this.angleTo(q);
      if (angle === 0)
        return this;
      const t = Math.min(1, step / angle);
      this.slerp(q, t);
      return this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    }
    dot(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this._onChangeCallback();
      return this;
    }
    multiply(q, p) {
      if (p !== void 0) {
        console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
        return this.multiplyQuaternions(q, p);
      }
      return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
      return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this._onChangeCallback();
      return this;
    }
    slerp(qb, t) {
      if (t === 0)
        return this;
      if (t === 1)
        return this.copy(qb);
      const x = this._x, y = this._y, z = this._z, w = this._w;
      let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1) {
        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;
        return this;
      }
      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        const s = 1 - t;
        this._w = s * w + t * this._w;
        this._x = s * x + t * this._x;
        this._y = s * y + t * this._y;
        this._z = s * z + t * this._z;
        this.normalize();
        this._onChangeCallback();
        return this;
      }
      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;
      this._onChangeCallback();
      return this;
    }
    equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this._x = attribute.getX(index);
      this._y = attribute.getY(index);
      this._z = attribute.getZ(index);
      this._w = attribute.getW(index);
      return this;
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
  };
  var Vector3 = class {
    constructor(x = 0, y = 0, z = 0) {
      Object.defineProperty(this, "isVector3", {value: true});
      this.x = x;
      this.y = y;
      this.z = z;
    }
    set(x, y, z) {
      if (z === void 0)
        z = this.z;
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setZ(z) {
      this.z = z;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    }
    add(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    }
    sub(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    }
    multiply(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
        return this.multiplyVectors(v, w);
      }
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
    multiplyVectors(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    }
    applyEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      return this.applyQuaternion(_quaternion.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    }
    applyNormalMatrix(m) {
      return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
    applyQuaternion(q) {
      const x = this.x, y = this.y, z = this.z;
      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
      const ix = qw * x + qy * z - qz * y;
      const iy = qw * y + qz * x - qx * z;
      const iz = qw * z + qx * y - qy * x;
      const iw = -qx * x - qy * y - qz * z;
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    }
    project(camera2) {
      return this.applyMatrix4(camera2.matrixWorldInverse).applyMatrix4(camera2.projectionMatrix);
    }
    unproject(camera2) {
      return this.applyMatrix4(camera2.projectionMatrixInverse).applyMatrix4(camera2.matrixWorld);
    }
    transformDirection(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
    cross(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
        return this.crossVectors(v, w);
      }
      return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
      const ax = a.x, ay = a.y, az = a.z;
      const bx = b.x, by = b.y, bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
    projectOnVector(v) {
      const denominator = v.lengthSq();
      if (denominator === 0)
        return this.set(0, 0, 0);
      const scalar = v.dot(this) / denominator;
      return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
      _vector.copy(this).projectOnVector(planeNormal);
      return this.sub(_vector);
    }
    reflect(normal) {
      return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0)
        return Math.PI / 2;
      const theta = this.dot(v) / denominator;
      return Math.acos(MathUtils.clamp(theta, -1, 1));
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
      const sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
    setFromCylindrical(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    }
    setFromMatrixPosition(m) {
      const e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    }
    setFromMatrixScale(m) {
      const sx = this.setFromMatrixColumn(m, 0).length();
      const sy = this.setFromMatrixColumn(m, 1).length();
      const sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
    setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
      return this.fromArray(m.elements, index * 3);
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
  };
  var _vector = /* @__PURE__ */ new Vector3();
  var _quaternion = /* @__PURE__ */ new Quaternion();
  var Box3 = class {
    constructor(min, max) {
      Object.defineProperty(this, "isBox3", {value: true});
      this.min = min !== void 0 ? min : new Vector3(Infinity, Infinity, Infinity);
      this.max = max !== void 0 ? max : new Vector3(-Infinity, -Infinity, -Infinity);
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromArray(array) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const x = array[i];
        const y = array[i + 1];
        const z = array[i + 2];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (z < minZ)
          minZ = z;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
        if (z > maxZ)
          maxZ = z;
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
    setFromBufferAttribute(attribute) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i = 0, l = attribute.count; i < l; i++) {
        const x = attribute.getX(i);
        const y = attribute.getY(i);
        const z = attribute.getZ(i);
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (z < minZ)
          minZ = z;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
        if (z > maxZ)
          maxZ = z;
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
    setFromCenterAndSize(center, size) {
      const halfSize = _vector$1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    setFromObject(object) {
      this.makeEmpty();
      return this.expandByObject(object);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .getCenter() target is now required");
        target = new Vector3();
      }
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .getSize() target is now required");
        target = new Vector3();
      }
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    expandByObject(object) {
      object.updateWorldMatrix(false, false);
      const geometry = object.geometry;
      if (geometry !== void 0) {
        if (geometry.boundingBox === null) {
          geometry.computeBoundingBox();
        }
        _box.copy(geometry.boundingBox);
        _box.applyMatrix4(object.matrixWorld);
        this.union(_box);
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        this.expandByObject(children[i]);
      }
      return this;
    }
    containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .getParameter() target is now required");
        target = new Vector3();
      }
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
    intersectsSphere(sphere) {
      this.clampPoint(sphere.center, _vector$1);
      return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
      let min, max;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max >= -plane.constant;
    }
    intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(_center);
      _extents.subVectors(this.max, _center);
      _v0.subVectors(triangle.a, _center);
      _v1.subVectors(triangle.b, _center);
      _v2.subVectors(triangle.c, _center);
      _f0.subVectors(_v1, _v0);
      _f1.subVectors(_v2, _v1);
      _f2.subVectors(_v0, _v2);
      let axes = [
        0,
        -_f0.z,
        _f0.y,
        0,
        -_f1.z,
        _f1.y,
        0,
        -_f2.z,
        _f2.y,
        _f0.z,
        0,
        -_f0.x,
        _f1.z,
        0,
        -_f1.x,
        _f2.z,
        0,
        -_f2.x,
        -_f0.y,
        _f0.x,
        0,
        -_f1.y,
        _f1.x,
        0,
        -_f2.y,
        _f2.x,
        0
      ];
      if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
        return false;
      }
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
        return false;
      }
      _triangleNormal.crossVectors(_f0, _f1);
      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0, _v1, _v2, _extents);
    }
    clampPoint(point, target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .clampPoint() target is now required");
        target = new Vector3();
      }
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    }
    getBoundingSphere(target) {
      if (target === void 0) {
        console.error("THREE.Box3: .getBoundingSphere() target is now required");
      }
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$1).length() * 0.5;
      return target;
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty())
        this.makeEmpty();
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    applyMatrix4(matrix) {
      if (this.isEmpty())
        return this;
      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.setFromPoints(_points);
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  function satForAxes(axes, v0, v1, v2, extents) {
    for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
      _testAxis.fromArray(axes, i);
      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p2 = v2.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
        return false;
      }
    }
    return true;
  }
  var _points = [
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3()
  ];
  var _vector$1 = /* @__PURE__ */ new Vector3();
  var _box = /* @__PURE__ */ new Box3();
  var _v0 = /* @__PURE__ */ new Vector3();
  var _v1 = /* @__PURE__ */ new Vector3();
  var _v2 = /* @__PURE__ */ new Vector3();
  var _f0 = /* @__PURE__ */ new Vector3();
  var _f1 = /* @__PURE__ */ new Vector3();
  var _f2 = /* @__PURE__ */ new Vector3();
  var _center = /* @__PURE__ */ new Vector3();
  var _extents = /* @__PURE__ */ new Vector3();
  var _triangleNormal = /* @__PURE__ */ new Vector3();
  var _testAxis = /* @__PURE__ */ new Vector3();
  var _box$1 = /* @__PURE__ */ new Box3();
  var Sphere = class {
    constructor(center, radius) {
      this.center = center !== void 0 ? center : new Vector3();
      this.radius = radius !== void 0 ? radius : -1;
    }
    set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    }
    setFromPoints(points, optionalCenter) {
      const center = this.center;
      if (optionalCenter !== void 0) {
        center.copy(optionalCenter);
      } else {
        _box$1.setFromPoints(points).getCenter(center);
      }
      let maxRadiusSq = 0;
      for (let i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      this.center.set(0, 0, 0);
      this.radius = -1;
      return this;
    }
    containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
      const radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
      return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
      const deltaLengthSq = this.center.distanceToSquared(point);
      if (target === void 0) {
        console.warn("THREE.Sphere: .clampPoint() target is now required");
        target = new Vector3();
      }
      target.copy(point);
      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }
      return target;
    }
    getBoundingBox(target) {
      if (target === void 0) {
        console.warn("THREE.Sphere: .getBoundingBox() target is now required");
        target = new Box3();
      }
      if (this.isEmpty()) {
        target.makeEmpty();
        return target;
      }
      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    }
    applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    }
    translate(offset) {
      this.center.add(offset);
      return this;
    }
    equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
  };
  var _vector$2 = /* @__PURE__ */ new Vector3();
  var _segCenter = /* @__PURE__ */ new Vector3();
  var _segDir = /* @__PURE__ */ new Vector3();
  var _diff = /* @__PURE__ */ new Vector3();
  var _edge1 = /* @__PURE__ */ new Vector3();
  var _edge2 = /* @__PURE__ */ new Vector3();
  var _normal = /* @__PURE__ */ new Vector3();
  var Ray = class {
    constructor(origin, direction) {
      this.origin = origin !== void 0 ? origin : new Vector3();
      this.direction = direction !== void 0 ? direction : new Vector3(0, 0, -1);
    }
    set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    }
    at(t, target) {
      if (target === void 0) {
        console.warn("THREE.Ray: .at() target is now required");
        target = new Vector3();
      }
      return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
      this.direction.copy(v).sub(this.origin).normalize();
      return this;
    }
    recast(t) {
      this.origin.copy(this.at(t, _vector$2));
      return this;
    }
    closestPointToPoint(point, target) {
      if (target === void 0) {
        console.warn("THREE.Ray: .closestPointToPoint() target is now required");
        target = new Vector3();
      }
      target.subVectors(point, this.origin);
      const directionDistance = target.dot(this.direction);
      if (directionDistance < 0) {
        return target.copy(this.origin);
      }
      return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
      const directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return _vector$2.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      _segDir.copy(v1).sub(v0).normalize();
      _diff.copy(this.origin).sub(_segCenter);
      const segExtent = v0.distanceTo(v1) * 0.5;
      const a01 = -this.direction.dot(_segDir);
      const b0 = _diff.dot(this.direction);
      const b1 = -_diff.dot(_segDir);
      const c = _diff.lengthSq();
      const det = Math.abs(1 - a01 * a01);
      let s0, s1, sqrDist, extDet;
      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              const invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
      }
      return sqrDist;
    }
    intersectSphere(sphere, target) {
      _vector$2.subVectors(sphere.center, this.origin);
      const tca = _vector$2.dot(this.direction);
      const d2 = _vector$2.dot(_vector$2) - tca * tca;
      const radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2)
        return null;
      const thc = Math.sqrt(radius2 - d2);
      const t0 = tca - thc;
      const t1 = tca + thc;
      if (t0 < 0 && t1 < 0)
        return null;
      if (t0 < 0)
        return this.at(t1, target);
      return this.at(t0, target);
    }
    intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
      const denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }
        return null;
      }
      const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
      return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {
      const t = this.distanceToPlane(plane);
      if (t === null) {
        return null;
      }
      return this.at(t, target);
    }
    intersectsPlane(plane) {
      const distToPoint = plane.distanceToPoint(this.origin);
      if (distToPoint === 0) {
        return true;
      }
      const denominator = plane.normal.dot(this.direction);
      if (denominator * distToPoint < 0) {
        return true;
      }
      return false;
    }
    intersectBox(box, target) {
      let tmin, tmax, tymin, tymax, tzmin, tzmax;
      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
      const origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if (tmin > tymax || tymin > tmax)
        return null;
      if (tymin > tmin || tmin !== tmin)
        tmin = tymin;
      if (tymax < tmax || tmax !== tmax)
        tmax = tymax;
      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }
      if (tmin > tzmax || tzmin > tmax)
        return null;
      if (tzmin > tmin || tmin !== tmin)
        tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax)
        tmax = tzmax;
      if (tmax < 0)
        return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
      return this.intersectBox(box, _vector$2) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {
      _edge1.subVectors(b, a);
      _edge2.subVectors(c, a);
      _normal.crossVectors(_edge1, _edge2);
      let DdN = this.direction.dot(_normal);
      let sign2;
      if (DdN > 0) {
        if (backfaceCulling)
          return null;
        sign2 = 1;
      } else if (DdN < 0) {
        sign2 = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      _diff.subVectors(this.origin, a);
      const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      const QdN = -sign2 * _diff.dot(_normal);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    }
    equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
  };
  var Matrix4 = class {
    constructor() {
      Object.defineProperty(this, "isMatrix4", {value: true});
      this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
      if (arguments.length > 0) {
        console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
      }
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      const te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    }
    identity() {
      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
    clone() {
      return new Matrix4().fromArray(this.elements);
    }
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      te[9] = me[9];
      te[10] = me[10];
      te[11] = me[11];
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      te[15] = me[15];
      return this;
    }
    copyPosition(m) {
      const te = this.elements, me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      return this;
    }
    extractRotation(m) {
      const te = this.elements;
      const me = m.elements;
      const scaleX = 1 / _v1$1.setFromMatrixColumn(m, 0).length();
      const scaleY = 1 / _v1$1.setFromMatrixColumn(m, 1).length();
      const scaleZ = 1 / _v1$1.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      }
      const te = this.elements;
      const x = euler.x, y = euler.y, z = euler.z;
      const a = Math.cos(x), b = Math.sin(x);
      const c = Math.cos(y), d = Math.sin(y);
      const e = Math.cos(z), f = Math.sin(z);
      if (euler.order === "XYZ") {
        const ae = a * e, af = a * f, be = b * e, bf = b * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler.order === "YXZ") {
        const ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce + df * b;
        te[4] = de * b - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b;
        te[2] = cf * b - de;
        te[6] = df + ce * b;
        te[10] = a * c;
      } else if (euler.order === "ZXY") {
        const ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce - df * b;
        te[4] = -a * f;
        te[8] = de + cf * b;
        te[1] = cf + de * b;
        te[5] = a * e;
        te[9] = df - ce * b;
        te[2] = -a * d;
        te[6] = b;
        te[10] = a * c;
      } else if (euler.order === "ZYX") {
        const ae = a * e, af = a * f, be = b * e, bf = b * f;
        te[0] = c * e;
        te[4] = be * d - af;
        te[8] = ae * d + bf;
        te[1] = c * f;
        te[5] = bf * d + ae;
        te[9] = af * d - be;
        te[2] = -d;
        te[6] = b * c;
        te[10] = a * c;
      } else if (euler.order === "YZX") {
        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler.order === "XZY") {
        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = ac * f + bd;
        te[5] = a * e;
        te[9] = ad * f - bc;
        te[2] = bc * f - ad;
        te[6] = b * e;
        te[10] = bd * f + ac;
      }
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromQuaternion(q) {
      return this.compose(_zero, q, _one);
    }
    lookAt(eye, target, up) {
      const te = this.elements;
      _z.subVectors(eye, target);
      if (_z.lengthSq() === 0) {
        _z.z = 1;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
      if (_x.lengthSq() === 0) {
        if (Math.abs(up.z) === 1) {
          _z.x += 1e-4;
        } else {
          _z.z += 1e-4;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
      }
      _x.normalize();
      _y.crossVectors(_z, _x);
      te[0] = _x.x;
      te[4] = _y.x;
      te[8] = _z.x;
      te[1] = _x.y;
      te[5] = _y.y;
      te[9] = _z.y;
      te[2] = _x.z;
      te[6] = _y.z;
      te[10] = _z.z;
      return this;
    }
    multiply(m, n) {
      if (n !== void 0) {
        console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
        return this.multiplyMatrices(m, n);
      }
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
      const ae = a.elements;
      const be = b.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[4] *= s;
      te[8] *= s;
      te[12] *= s;
      te[1] *= s;
      te[5] *= s;
      te[9] *= s;
      te[13] *= s;
      te[2] *= s;
      te[6] *= s;
      te[10] *= s;
      te[14] *= s;
      te[3] *= s;
      te[7] *= s;
      te[11] *= s;
      te[15] *= s;
      return this;
    }
    determinant() {
      const te = this.elements;
      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
      const te = this.elements;
      let tmp2;
      tmp2 = te[1];
      te[1] = te[4];
      te[4] = tmp2;
      tmp2 = te[2];
      te[2] = te[8];
      te[8] = tmp2;
      tmp2 = te[6];
      te[6] = te[9];
      te[9] = tmp2;
      tmp2 = te[3];
      te[3] = te[12];
      te[12] = tmp2;
      tmp2 = te[7];
      te[7] = te[13];
      te[13] = tmp2;
      tmp2 = te[11];
      te[11] = te[14];
      te[14] = tmp2;
      return this;
    }
    setPosition(x, y, z) {
      const te = this.elements;
      if (x.isVector3) {
        te[12] = x.x;
        te[13] = x.y;
        te[14] = x.z;
      } else {
        te[12] = x;
        te[13] = y;
        te[14] = z;
      }
      return this;
    }
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
    scale(v) {
      const te = this.elements;
      const x = v.x, y = v.y, z = v.z;
      te[0] *= x;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x;
      te[7] *= y;
      te[11] *= z;
      return this;
    }
    getMaxScaleOnAxis() {
      const te = this.elements;
      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
      return this;
    }
    makeRotationX(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationY(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationZ(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationAxis(axis, angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      const t = 1 - c;
      const x = axis.x, y = axis.y, z = axis.z;
      const tx = t * x, ty = t * y;
      this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
      return this;
    }
    makeScale(x, y, z) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
      return this;
    }
    makeShear(x, y, z) {
      this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
      return this;
    }
    compose(position, quaternion, scale) {
      const te = this.elements;
      const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
      const x2 = x + x, y2 = y + y, z2 = z + z;
      const xx = x * x2, xy = x * y2, xz = x * z2;
      const yy = y * y2, yz = y * z2, zz = z * z2;
      const wx = w * x2, wy = w * y2, wz = w * z2;
      const sx = scale.x, sy = scale.y, sz = scale.z;
      te[0] = (1 - (yy + zz)) * sx;
      te[1] = (xy + wz) * sx;
      te[2] = (xz - wy) * sx;
      te[3] = 0;
      te[4] = (xy - wz) * sy;
      te[5] = (1 - (xx + zz)) * sy;
      te[6] = (yz + wx) * sy;
      te[7] = 0;
      te[8] = (xz + wy) * sz;
      te[9] = (yz - wx) * sz;
      te[10] = (1 - (xx + yy)) * sz;
      te[11] = 0;
      te[12] = position.x;
      te[13] = position.y;
      te[14] = position.z;
      te[15] = 1;
      return this;
    }
    decompose(position, quaternion, scale) {
      const te = this.elements;
      let sx = _v1$1.set(te[0], te[1], te[2]).length();
      const sy = _v1$1.set(te[4], te[5], te[6]).length();
      const sz = _v1$1.set(te[8], te[9], te[10]).length();
      const det = this.determinant();
      if (det < 0)
        sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      _m1.copy(this);
      const invSX = 1 / sx;
      const invSY = 1 / sy;
      const invSZ = 1 / sz;
      _m1.elements[0] *= invSX;
      _m1.elements[1] *= invSX;
      _m1.elements[2] *= invSX;
      _m1.elements[4] *= invSY;
      _m1.elements[5] *= invSY;
      _m1.elements[6] *= invSY;
      _m1.elements[8] *= invSZ;
      _m1.elements[9] *= invSZ;
      _m1.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(_m1);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
      if (far === void 0) {
        console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      }
      const te = this.elements;
      const x = 2 * near / (right - left);
      const y = 2 * near / (top - bottom);
      const a = (right + left) / (right - left);
      const b = (top + bottom) / (top - bottom);
      const c = -(far + near) / (far - near);
      const d = -2 * far * near / (far - near);
      te[0] = x;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
      const te = this.elements;
      const w = 1 / (right - left);
      const h = 1 / (top - bottom);
      const p = 1 / (far - near);
      const x = (right + left) * w;
      const y = (top + bottom) * h;
      const z = (far + near) * p;
      te[0] = 2 * w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = 2 * h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = -2 * p;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    }
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i = 0; i < 16; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < 16; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
  };
  var _v1$1 = /* @__PURE__ */ new Vector3();
  var _m1 = /* @__PURE__ */ new Matrix4();
  var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
  var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
  var _x = /* @__PURE__ */ new Vector3();
  var _y = /* @__PURE__ */ new Vector3();
  var _z = /* @__PURE__ */ new Vector3();
  var Euler = class {
    constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
      Object.defineProperty(this, "isEuler", {value: true});
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(value) {
      this._order = value;
      this._onChangeCallback();
    }
    set(x, y, z, order) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order || this._order;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m, order, update2) {
      const clamp = MathUtils.clamp;
      const te = m.elements;
      const m11 = te[0], m12 = te[4], m13 = te[8];
      const m21 = te[1], m22 = te[5], m23 = te[9];
      const m31 = te[2], m32 = te[6], m33 = te[10];
      order = order || this._order;
      switch (order) {
        case "XYZ":
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.9999999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
          break;
        case "YXZ":
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.9999999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
          break;
        case "ZXY":
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.9999999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
          break;
        case "ZYX":
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.9999999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
          break;
        case "YZX":
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.9999999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
          break;
        case "XZY":
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.9999999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
      }
      this._order = order;
      if (update2 !== false)
        this._onChangeCallback();
      return this;
    }
    setFromQuaternion(q, order, update2) {
      _matrix.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(_matrix, order, update2);
    }
    setFromVector3(v, order) {
      return this.set(v.x, v.y, v.z, order || this._order);
    }
    reorder(newOrder) {
      _quaternion$1.setFromEuler(this);
      return this.setFromQuaternion(_quaternion$1, newOrder);
    }
    equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== void 0)
        this._order = array[3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    }
    toVector3(optionalResult) {
      if (optionalResult) {
        return optionalResult.set(this._x, this._y, this._z);
      } else {
        return new Vector3(this._x, this._y, this._z);
      }
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
  };
  Euler.DefaultOrder = "XYZ";
  Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  var _matrix = /* @__PURE__ */ new Matrix4();
  var _quaternion$1 = /* @__PURE__ */ new Quaternion();
  var Layers = class {
    constructor() {
      this.mask = 1 | 0;
    }
    set(channel) {
      this.mask = 1 << channel | 0;
    }
    enable(channel) {
      this.mask |= 1 << channel | 0;
    }
    enableAll() {
      this.mask = 4294967295 | 0;
    }
    toggle(channel) {
      this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
      this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(layers) {
      return (this.mask & layers.mask) !== 0;
    }
  };
  var _object3DId = 0;
  var _v1$2 = new Vector3();
  var _q1 = new Quaternion();
  var _m1$1 = new Matrix4();
  var _target = new Vector3();
  var _position = new Vector3();
  var _scale = new Vector3();
  var _quaternion$2 = new Quaternion();
  var _xAxis = new Vector3(1, 0, 0);
  var _yAxis = new Vector3(0, 1, 0);
  var _zAxis = new Vector3(0, 0, 1);
  var _addedEvent = {type: "added"};
  var _removedEvent = {type: "removed"};
  function Object3D() {
    Object.defineProperty(this, "id", {value: _object3DId++});
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  Object3D.DefaultUp = new Vector3(0, 1, 0);
  Object3D.DefaultMatrixAutoUpdate = true;
  Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Object3D,
    isObject3D: true,
    onBeforeRender: function() {
    },
    onAfterRender: function() {
    },
    applyMatrix4: function(matrix) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      this.matrix.premultiply(matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(q) {
      this.quaternion.premultiply(q);
      return this;
    },
    setRotationFromAxisAngle: function(axis, angle) {
      this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function(euler) {
      this.quaternion.setFromEuler(euler, true);
    },
    setRotationFromMatrix: function(m) {
      this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function(q) {
      this.quaternion.copy(q);
    },
    rotateOnAxis: function(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(_q1);
      return this;
    },
    rotateOnWorldAxis: function(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(_q1);
      return this;
    },
    rotateX: function(angle) {
      return this.rotateOnAxis(_xAxis, angle);
    },
    rotateY: function(angle) {
      return this.rotateOnAxis(_yAxis, angle);
    },
    rotateZ: function(angle) {
      return this.rotateOnAxis(_zAxis, angle);
    },
    translateOnAxis: function(axis, distance) {
      _v1$2.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(_v1$2.multiplyScalar(distance));
      return this;
    },
    translateX: function(distance) {
      return this.translateOnAxis(_xAxis, distance);
    },
    translateY: function(distance) {
      return this.translateOnAxis(_yAxis, distance);
    },
    translateZ: function(distance) {
      return this.translateOnAxis(_zAxis, distance);
    },
    localToWorld: function(vector) {
      return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function(vector) {
      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
    },
    lookAt: function(x, y, z) {
      if (x.isVector3) {
        _target.copy(x);
      } else {
        _target.set(x, y, z);
      }
      const parent = this.parent;
      this.updateWorldMatrix(true, false);
      _position.setFromMatrixPosition(this.matrixWorld);
      if (this.isCamera || this.isLight) {
        _m1$1.lookAt(_position, _target, this.up);
      } else {
        _m1$1.lookAt(_target, _position, this.up);
      }
      this.quaternion.setFromRotationMatrix(_m1$1);
      if (parent) {
        _m1$1.extractRotation(parent.matrixWorld);
        _q1.setFromRotationMatrix(_m1$1);
        this.quaternion.premultiply(_q1.invert());
      }
    },
    add: function(object) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (object === this) {
        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
        return this;
      }
      if (object && object.isObject3D) {
        if (object.parent !== null) {
          object.parent.remove(object);
        }
        object.parent = this;
        this.children.push(object);
        object.dispatchEvent(_addedEvent);
      } else {
        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
      }
      return this;
    },
    remove: function(object) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) {
          this.remove(arguments[i]);
        }
        return this;
      }
      const index = this.children.indexOf(object);
      if (index !== -1) {
        object.parent = null;
        this.children.splice(index, 1);
        object.dispatchEvent(_removedEvent);
      }
      return this;
    },
    clear: function() {
      for (let i = 0; i < this.children.length; i++) {
        const object = this.children[i];
        object.parent = null;
        object.dispatchEvent(_removedEvent);
      }
      this.children.length = 0;
      return this;
    },
    attach: function(object) {
      this.updateWorldMatrix(true, false);
      _m1$1.copy(this.matrixWorld).invert();
      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);
        _m1$1.multiply(object.parent.matrixWorld);
      }
      object.applyMatrix4(_m1$1);
      object.updateWorldMatrix(false, false);
      this.add(object);
      return this;
    },
    getObjectById: function(id) {
      return this.getObjectByProperty("id", id);
    },
    getObjectByName: function(name) {
      return this.getObjectByProperty("name", name);
    },
    getObjectByProperty: function(name, value) {
      if (this[name] === value)
        return this;
      for (let i = 0, l = this.children.length; i < l; i++) {
        const child = this.children[i];
        const object = child.getObjectByProperty(name, value);
        if (object !== void 0) {
          return object;
        }
      }
      return void 0;
    },
    getWorldPosition: function(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldPosition() target is now required");
        target = new Vector3();
      }
      this.updateWorldMatrix(true, false);
      return target.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
        target = new Quaternion();
      }
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position, target, _scale);
      return target;
    },
    getWorldScale: function(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldScale() target is now required");
        target = new Vector3();
      }
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position, _quaternion$2, target);
      return target;
    },
    getWorldDirection: function(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldDirection() target is now required");
        target = new Vector3();
      }
      this.updateWorldMatrix(true, false);
      const e = this.matrixWorld.elements;
      return target.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {
    },
    traverse: function(callback) {
      callback(this);
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].traverse(callback);
      }
    },
    traverseVisible: function(callback) {
      if (this.visible === false)
        return;
      callback(this);
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].traverseVisible(callback);
      }
    },
    traverseAncestors: function(callback) {
      const parent = this.parent;
      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    },
    updateMatrix: function() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function(force) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || force) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        this.matrixWorldNeedsUpdate = false;
        force = true;
      }
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(force);
      }
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
      const parent = this.parent;
      if (updateParents === true && parent !== null) {
        parent.updateWorldMatrix(true, false);
      }
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      if (updateChildren === true) {
        const children = this.children;
        for (let i = 0, l = children.length; i < l; i++) {
          children[i].updateWorldMatrix(false, true);
        }
      }
    },
    toJSON: function(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      const output = {};
      if (isRootObject) {
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {}
        };
        output.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON"
        };
      }
      const object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== "")
        object.name = this.name;
      if (this.castShadow === true)
        object.castShadow = true;
      if (this.receiveShadow === true)
        object.receiveShadow = true;
      if (this.visible === false)
        object.visible = false;
      if (this.frustumCulled === false)
        object.frustumCulled = false;
      if (this.renderOrder !== 0)
        object.renderOrder = this.renderOrder;
      if (JSON.stringify(this.userData) !== "{}")
        object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      if (this.matrixAutoUpdate === false)
        object.matrixAutoUpdate = false;
      if (this.isInstancedMesh) {
        object.type = "InstancedMesh";
        object.count = this.count;
        object.instanceMatrix = this.instanceMatrix.toJSON();
      }
      function serialize(library, element) {
        if (library[element.uuid] === void 0) {
          library[element.uuid] = element.toJSON(meta);
        }
        return element.uuid;
      }
      if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        const parameters = this.geometry.parameters;
        if (parameters !== void 0 && parameters.shapes !== void 0) {
          const shapes = parameters.shapes;
          if (Array.isArray(shapes)) {
            for (let i = 0, l = shapes.length; i < l; i++) {
              const shape = shapes[i];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }
      if (this.isSkinnedMesh) {
        object.bindMode = this.bindMode;
        object.bindMatrix = this.bindMatrix.toArray();
        if (this.skeleton !== void 0) {
          serialize(meta.skeletons, this.skeleton);
          object.skeleton = this.skeleton.uuid;
        }
      }
      if (this.material !== void 0) {
        if (Array.isArray(this.material)) {
          const uuids = [];
          for (let i = 0, l = this.material.length; i < l; i++) {
            uuids.push(serialize(meta.materials, this.material[i]));
          }
          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      }
      if (this.children.length > 0) {
        object.children = [];
        for (let i = 0; i < this.children.length; i++) {
          object.children.push(this.children[i].toJSON(meta).object);
        }
      }
      if (this.animations.length > 0) {
        object.animations = [];
        for (let i = 0; i < this.animations.length; i++) {
          const animation = this.animations[i];
          object.animations.push(serialize(meta.animations, animation));
        }
      }
      if (isRootObject) {
        const geometries = extractFromCache(meta.geometries);
        const materials = extractFromCache(meta.materials);
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        const shapes = extractFromCache(meta.shapes);
        const skeletons = extractFromCache(meta.skeletons);
        const animations = extractFromCache(meta.animations);
        if (geometries.length > 0)
          output.geometries = geometries;
        if (materials.length > 0)
          output.materials = materials;
        if (textures.length > 0)
          output.textures = textures;
        if (images.length > 0)
          output.images = images;
        if (shapes.length > 0)
          output.shapes = shapes;
        if (skeletons.length > 0)
          output.skeletons = skeletons;
        if (animations.length > 0)
          output.animations = animations;
      }
      output.object = object;
      return output;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data = cache[key];
          delete data.metadata;
          values.push(data);
        }
        return values;
      }
    },
    clone: function(recursive) {
      return new this.constructor().copy(this, recursive);
    },
    copy: function(source, recursive = true) {
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.rotation.order = source.rotation.order;
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      if (recursive === true) {
        for (let i = 0; i < source.children.length; i++) {
          const child = source.children[i];
          this.add(child.clone());
        }
      }
      return this;
    }
  });
  var _vector1 = /* @__PURE__ */ new Vector3();
  var _vector2 = /* @__PURE__ */ new Vector3();
  var _normalMatrix = /* @__PURE__ */ new Matrix3();
  var Plane = class {
    constructor(normal, constant) {
      Object.defineProperty(this, "isPlane", {value: true});
      this.normal = normal !== void 0 ? normal : new Vector3(1, 0, 0);
      this.constant = constant !== void 0 ? constant : 0;
    }
    set(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    }
    setComponents(x, y, z, w) {
      this.normal.set(x, y, z);
      this.constant = w;
      return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    }
    setFromCoplanarPoints(a, b, c) {
      const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    }
    normalize() {
      const inverseNormalLength = 1 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    }
    negate() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    }
    distanceToPoint(point) {
      return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
      if (target === void 0) {
        console.warn("THREE.Plane: .projectPoint() target is now required");
        target = new Vector3();
      }
      return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    }
    intersectLine(line, target) {
      if (target === void 0) {
        console.warn("THREE.Plane: .intersectLine() target is now required");
        target = new Vector3();
      }
      const direction = line.delta(_vector1);
      const denominator = this.normal.dot(direction);
      if (denominator === 0) {
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        }
        return void 0;
      }
      const t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return void 0;
      }
      return target.copy(direction).multiplyScalar(t).add(line.start);
    }
    intersectsLine(line) {
      const startSign = this.distanceToPoint(line.start);
      const endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
      return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
      return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
      if (target === void 0) {
        console.warn("THREE.Plane: .coplanarPoint() target is now required");
        target = new Vector3();
      }
      return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
      const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
      const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
      const normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    }
    translate(offset) {
      this.constant -= offset.dot(this.normal);
      return this;
    }
    equals(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
  };
  var _v0$1 = /* @__PURE__ */ new Vector3();
  var _v1$3 = /* @__PURE__ */ new Vector3();
  var _v2$1 = /* @__PURE__ */ new Vector3();
  var _v3 = /* @__PURE__ */ new Vector3();
  var _vab = /* @__PURE__ */ new Vector3();
  var _vac = /* @__PURE__ */ new Vector3();
  var _vbc = /* @__PURE__ */ new Vector3();
  var _vap = /* @__PURE__ */ new Vector3();
  var _vbp = /* @__PURE__ */ new Vector3();
  var _vcp = /* @__PURE__ */ new Vector3();
  var Triangle = class {
    constructor(a, b, c) {
      this.a = a !== void 0 ? a : new Vector3();
      this.b = b !== void 0 ? b : new Vector3();
      this.c = c !== void 0 ? c : new Vector3();
    }
    static getNormal(a, b, c, target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .getNormal() target is now required");
        target = new Vector3();
      }
      target.subVectors(c, b);
      _v0$1.subVectors(a, b);
      target.cross(_v0$1);
      const targetLengthSq = target.lengthSq();
      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }
      return target.set(0, 0, 0);
    }
    static getBarycoord(point, a, b, c, target) {
      _v0$1.subVectors(c, a);
      _v1$3.subVectors(b, a);
      _v2$1.subVectors(point, a);
      const dot00 = _v0$1.dot(_v0$1);
      const dot01 = _v0$1.dot(_v1$3);
      const dot02 = _v0$1.dot(_v2$1);
      const dot11 = _v1$3.dot(_v1$3);
      const dot12 = _v1$3.dot(_v2$1);
      const denom = dot00 * dot11 - dot01 * dot01;
      if (target === void 0) {
        console.warn("THREE.Triangle: .getBarycoord() target is now required");
        target = new Vector3();
      }
      if (denom === 0) {
        return target.set(-2, -1, -1);
      }
      const invDenom = 1 / denom;
      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return target.set(1 - u - v, v, u);
    }
    static containsPoint(point, a, b, c) {
      this.getBarycoord(point, a, b, c, _v3);
      return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
    }
    static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
      this.getBarycoord(point, p1, p2, p3, _v3);
      target.set(0, 0);
      target.addScaledVector(uv1, _v3.x);
      target.addScaledVector(uv2, _v3.y);
      target.addScaledVector(uv3, _v3.z);
      return target;
    }
    static isFrontFacing(a, b, c, direction) {
      _v0$1.subVectors(c, b);
      _v1$3.subVectors(a, b);
      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
    set(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    }
    getArea() {
      _v0$1.subVectors(this.c, this.b);
      _v1$3.subVectors(this.a, this.b);
      return _v0$1.cross(_v1$3).length() * 0.5;
    }
    getMidpoint(target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .getMidpoint() target is now required");
        target = new Vector3();
      }
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
      return Triangle.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .getPlane() target is now required");
        target = new Plane();
      }
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getUV(point, uv1, uv2, uv3, target) {
      return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    }
    containsPoint(point) {
      return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
      return box.intersectsTriangle(this);
    }
    closestPointToPoint(p, target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
        target = new Vector3();
      }
      const a = this.a, b = this.b, c = this.c;
      let v, w;
      _vab.subVectors(b, a);
      _vac.subVectors(c, a);
      _vap.subVectors(p, a);
      const d1 = _vab.dot(_vap);
      const d2 = _vac.dot(_vap);
      if (d1 <= 0 && d2 <= 0) {
        return target.copy(a);
      }
      _vbp.subVectors(p, b);
      const d3 = _vab.dot(_vbp);
      const d4 = _vac.dot(_vbp);
      if (d3 >= 0 && d4 <= d3) {
        return target.copy(b);
      }
      const vc = d1 * d4 - d3 * d2;
      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3);
        return target.copy(a).addScaledVector(_vab, v);
      }
      _vcp.subVectors(p, c);
      const d5 = _vab.dot(_vcp);
      const d6 = _vac.dot(_vcp);
      if (d6 >= 0 && d5 <= d6) {
        return target.copy(c);
      }
      const vb = d5 * d2 - d1 * d6;
      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6);
        return target.copy(a).addScaledVector(_vac, w);
      }
      const va = d3 * d6 - d5 * d4;
      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        _vbc.subVectors(c, b);
        w = (d4 - d3) / (d4 - d3 + (d5 - d6));
        return target.copy(b).addScaledVector(_vbc, w);
      }
      const denom = 1 / (va + vb + vc);
      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    }
    equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  };
  var _colorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  var _hslA = {h: 0, s: 0, l: 0};
  var _hslB = {h: 0, s: 0, l: 0};
  function hue2rgb(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * 6 * (2 / 3 - t);
    return p;
  }
  function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
  }
  var Color = class {
    constructor(r, g, b) {
      Object.defineProperty(this, "isColor", {value: true});
      if (g === void 0 && b === void 0) {
        return this.set(r);
      }
      return this.setRGB(r, g, b);
    }
    set(value) {
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
      return this;
    }
    setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
    setHex(hex) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      return this;
    }
    setRGB(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
      return this;
    }
    setHSL(h, s, l) {
      h = MathUtils.euclideanModulo(h, 1);
      s = MathUtils.clamp(s, 0, 1);
      l = MathUtils.clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        const q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      return this;
    }
    setStyle(style) {
      function handleAlpha(string) {
        if (string === void 0)
          return;
        if (parseFloat(string) < 1) {
          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
      }
      let m;
      if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
        let color;
        const name = m[1];
        const components = m[2];
        switch (name) {
          case "rgb":
          case "rgba":
            if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
              this.r = Math.min(255, parseInt(color[1], 10)) / 255;
              this.g = Math.min(255, parseInt(color[2], 10)) / 255;
              this.b = Math.min(255, parseInt(color[3], 10)) / 255;
              handleAlpha(color[5]);
              return this;
            }
            if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
              this.r = Math.min(100, parseInt(color[1], 10)) / 100;
              this.g = Math.min(100, parseInt(color[2], 10)) / 100;
              this.b = Math.min(100, parseInt(color[3], 10)) / 100;
              handleAlpha(color[5]);
              return this;
            }
            break;
          case "hsl":
          case "hsla":
            if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
              const h = parseFloat(color[1]) / 360;
              const s = parseInt(color[2], 10) / 100;
              const l = parseInt(color[3], 10) / 100;
              handleAlpha(color[5]);
              return this.setHSL(h, s, l);
            }
            break;
        }
      } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
        const hex = m[1];
        const size = hex.length;
        if (size === 3) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
          this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
          this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
          return this;
        } else if (size === 6) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
          this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
          this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
          return this;
        }
      }
      if (style && style.length > 0) {
        return this.setColorName(style);
      }
      return this;
    }
    setColorName(style) {
      const hex = _colorKeywords[style];
      if (hex !== void 0) {
        this.setHex(hex);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
      return this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
    copyGammaToLinear(color, gammaFactor = 2) {
      this.r = Math.pow(color.r, gammaFactor);
      this.g = Math.pow(color.g, gammaFactor);
      this.b = Math.pow(color.b, gammaFactor);
      return this;
    }
    copyLinearToGamma(color, gammaFactor = 2) {
      const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
      this.r = Math.pow(color.r, safeInverse);
      this.g = Math.pow(color.g, safeInverse);
      this.b = Math.pow(color.b, safeInverse);
      return this;
    }
    convertGammaToLinear(gammaFactor) {
      this.copyGammaToLinear(this, gammaFactor);
      return this;
    }
    convertLinearToGamma(gammaFactor) {
      this.copyLinearToGamma(this, gammaFactor);
      return this;
    }
    copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
    copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
    convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
    convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
    getHex() {
      return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    }
    getHexString() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    }
    getHSL(target) {
      if (target === void 0) {
        console.warn("THREE.Color: .getHSL() target is now required");
        target = {h: 0, s: 0, l: 0};
      }
      const r = this.r, g = this.g, b = this.b;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let hue, saturation;
      const lightness = (min + max) / 2;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        const delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
    getStyle() {
      return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
    }
    offsetHSL(h, s, l) {
      this.getHSL(_hslA);
      _hslA.h += h;
      _hslA.s += s;
      _hslA.l += l;
      this.setHSL(_hslA.h, _hslA.s, _hslA.l);
      return this;
    }
    add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
    addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
    addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    }
    sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
    multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
    multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    }
    lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
    lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
      const s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
      const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h, s, l);
      return this;
    }
    equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    fromArray(array, offset = 0) {
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.r = attribute.getX(index);
      this.g = attribute.getY(index);
      this.b = attribute.getZ(index);
      if (attribute.normalized === true) {
        this.r /= 255;
        this.g /= 255;
        this.b /= 255;
      }
      return this;
    }
    toJSON() {
      return this.getHex();
    }
  };
  Color.NAMES = _colorKeywords;
  Color.prototype.r = 1;
  Color.prototype.g = 1;
  Color.prototype.b = 1;
  var Face3 = class {
    constructor(a, b, c, normal, color, materialIndex = 0) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.normal = normal && normal.isVector3 ? normal : new Vector3();
      this.vertexNormals = Array.isArray(normal) ? normal : [];
      this.color = color && color.isColor ? color : new Color();
      this.vertexColors = Array.isArray(color) ? color : [];
      this.materialIndex = materialIndex;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.a = source.a;
      this.b = source.b;
      this.c = source.c;
      this.normal.copy(source.normal);
      this.color.copy(source.color);
      this.materialIndex = source.materialIndex;
      for (let i = 0, il = source.vertexNormals.length; i < il; i++) {
        this.vertexNormals[i] = source.vertexNormals[i].clone();
      }
      for (let i = 0, il = source.vertexColors.length; i < il; i++) {
        this.vertexColors[i] = source.vertexColors[i].clone();
      }
      return this;
    }
  };
  var materialId = 0;
  function Material() {
    Object.defineProperty(this, "id", {value: materialId++});
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.flatShading = false;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
  }
  Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Material,
    isMaterial: true,
    onBeforeCompile: function() {
    },
    customProgramCacheKey: function() {
      return this.onBeforeCompile.toString();
    },
    setValues: function(values) {
      if (values === void 0)
        return;
      for (const key in values) {
        const newValue = values[key];
        if (newValue === void 0) {
          console.warn("THREE.Material: '" + key + "' parameter is undefined.");
          continue;
        }
        if (key === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          this.flatShading = newValue === FlatShading ? true : false;
          continue;
        }
        const currentValue = this[key];
        if (currentValue === void 0) {
          console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
          continue;
        }
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    },
    toJSON: function(meta) {
      const isRoot = meta === void 0 || typeof meta === "string";
      if (isRoot) {
        meta = {
          textures: {},
          images: {}
        };
      }
      const data = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (this.color && this.color.isColor)
        data.color = this.color.getHex();
      if (this.roughness !== void 0)
        data.roughness = this.roughness;
      if (this.metalness !== void 0)
        data.metalness = this.metalness;
      if (this.sheen && this.sheen.isColor)
        data.sheen = this.sheen.getHex();
      if (this.emissive && this.emissive.isColor)
        data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity && this.emissiveIntensity !== 1)
        data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor)
        data.specular = this.specular.getHex();
      if (this.shininess !== void 0)
        data.shininess = this.shininess;
      if (this.clearcoat !== void 0)
        data.clearcoat = this.clearcoat;
      if (this.clearcoatRoughness !== void 0)
        data.clearcoatRoughness = this.clearcoatRoughness;
      if (this.clearcoatMap && this.clearcoatMap.isTexture) {
        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
      }
      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
      }
      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
      }
      if (this.map && this.map.isTexture)
        data.map = this.map.toJSON(meta).uuid;
      if (this.matcap && this.matcap.isTexture)
        data.matcap = this.matcap.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture)
        data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap && this.lightMap.isTexture)
        data.lightMap = this.lightMap.toJSON(meta).uuid;
      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }
      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }
      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }
      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }
      if (this.roughnessMap && this.roughnessMap.isTexture)
        data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture)
        data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture)
        data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture)
        data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        data.reflectivity = this.reflectivity;
        data.refractionRatio = this.refractionRatio;
        if (this.combine !== void 0)
          data.combine = this.combine;
        if (this.envMapIntensity !== void 0)
          data.envMapIntensity = this.envMapIntensity;
      }
      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }
      if (this.size !== void 0)
        data.size = this.size;
      if (this.sizeAttenuation !== void 0)
        data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending)
        data.blending = this.blending;
      if (this.flatShading === true)
        data.flatShading = this.flatShading;
      if (this.side !== FrontSide)
        data.side = this.side;
      if (this.vertexColors)
        data.vertexColors = true;
      if (this.opacity < 1)
        data.opacity = this.opacity;
      if (this.transparent === true)
        data.transparent = this.transparent;
      data.depthFunc = this.depthFunc;
      data.depthTest = this.depthTest;
      data.depthWrite = this.depthWrite;
      data.stencilWrite = this.stencilWrite;
      data.stencilWriteMask = this.stencilWriteMask;
      data.stencilFunc = this.stencilFunc;
      data.stencilRef = this.stencilRef;
      data.stencilFuncMask = this.stencilFuncMask;
      data.stencilFail = this.stencilFail;
      data.stencilZFail = this.stencilZFail;
      data.stencilZPass = this.stencilZPass;
      if (this.rotation && this.rotation !== 0)
        data.rotation = this.rotation;
      if (this.polygonOffset === true)
        data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0)
        data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0)
        data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth && this.linewidth !== 1)
        data.linewidth = this.linewidth;
      if (this.dashSize !== void 0)
        data.dashSize = this.dashSize;
      if (this.gapSize !== void 0)
        data.gapSize = this.gapSize;
      if (this.scale !== void 0)
        data.scale = this.scale;
      if (this.dithering === true)
        data.dithering = true;
      if (this.alphaTest > 0)
        data.alphaTest = this.alphaTest;
      if (this.premultipliedAlpha === true)
        data.premultipliedAlpha = this.premultipliedAlpha;
      if (this.wireframe === true)
        data.wireframe = this.wireframe;
      if (this.wireframeLinewidth > 1)
        data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== "round")
        data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== "round")
        data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.morphTargets === true)
        data.morphTargets = true;
      if (this.morphNormals === true)
        data.morphNormals = true;
      if (this.skinning === true)
        data.skinning = true;
      if (this.visible === false)
        data.visible = false;
      if (this.toneMapped === false)
        data.toneMapped = false;
      if (JSON.stringify(this.userData) !== "{}")
        data.userData = this.userData;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data2 = cache[key];
          delete data2.metadata;
          values.push(data2);
        }
        return values;
      }
      if (isRoot) {
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        if (textures.length > 0)
          data.textures = textures;
        if (images.length > 0)
          data.images = images;
      }
      return data;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.name = source.name;
      this.fog = source.fog;
      this.blending = source.blending;
      this.side = source.side;
      this.flatShading = source.flatShading;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.stencilWriteMask = source.stencilWriteMask;
      this.stencilFunc = source.stencilFunc;
      this.stencilRef = source.stencilRef;
      this.stencilFuncMask = source.stencilFuncMask;
      this.stencilFail = source.stencilFail;
      this.stencilZFail = source.stencilZFail;
      this.stencilZPass = source.stencilZPass;
      this.stencilWrite = source.stencilWrite;
      const srcPlanes = source.clippingPlanes;
      let dstPlanes = null;
      if (srcPlanes !== null) {
        const n = srcPlanes.length;
        dstPlanes = new Array(n);
        for (let i = 0; i !== n; ++i) {
          dstPlanes[i] = srcPlanes[i].clone();
        }
      }
      this.clippingPlanes = dstPlanes;
      this.clipIntersection = source.clipIntersection;
      this.clipShadows = source.clipShadows;
      this.shadowSide = source.shadowSide;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.visible = source.visible;
      this.toneMapped = source.toneMapped;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      return this;
    },
    dispose: function() {
      this.dispatchEvent({type: "dispose"});
    }
  });
  Object.defineProperty(Material.prototype, "needsUpdate", {
    set: function(value) {
      if (value === true)
        this.version++;
    }
  });
  function MeshBasicMaterial(parameters) {
    Material.call(this);
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  MeshBasicMaterial.prototype = Object.create(Material.prototype);
  MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
  MeshBasicMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
  };
  var _vector$3 = new Vector3();
  var _vector2$1 = new Vector2();
  function BufferAttribute(array, itemSize, normalized) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = {offset: 0, count: -1};
    this.version = 0;
  }
  Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
    set: function(value) {
      if (value === true)
        this.version++;
    }
  });
  Object.assign(BufferAttribute.prototype, {
    isBufferAttribute: true,
    onUploadCallback: function() {
    },
    setUsage: function(value) {
      this.usage = value;
      return this;
    },
    copy: function(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.usage = source.usage;
      return this;
    },
    copyAt: function(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;
      for (let i = 0, l = this.itemSize; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    },
    copyArray: function(array) {
      this.array.set(array);
      return this;
    },
    copyColorsArray: function(colors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = colors.length; i < l; i++) {
        let color = colors[i];
        if (color === void 0) {
          console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
          color = new Color();
        }
        array[offset++] = color.r;
        array[offset++] = color.g;
        array[offset++] = color.b;
      }
      return this;
    },
    copyVector2sArray: function(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = vectors.length; i < l; i++) {
        let vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
          vector = new Vector2();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
      }
      return this;
    },
    copyVector3sArray: function(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = vectors.length; i < l; i++) {
        let vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
          vector = new Vector3();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
      }
      return this;
    },
    copyVector4sArray: function(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = vectors.length; i < l; i++) {
        let vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
          vector = new Vector4();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
        array[offset++] = vector.w;
      }
      return this;
    },
    applyMatrix3: function(m) {
      if (this.itemSize === 2) {
        for (let i = 0, l = this.count; i < l; i++) {
          _vector2$1.fromBufferAttribute(this, i);
          _vector2$1.applyMatrix3(m);
          this.setXY(i, _vector2$1.x, _vector2$1.y);
        }
      } else if (this.itemSize === 3) {
        for (let i = 0, l = this.count; i < l; i++) {
          _vector$3.fromBufferAttribute(this, i);
          _vector$3.applyMatrix3(m);
          this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
        }
      }
      return this;
    },
    applyMatrix4: function(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$3.x = this.getX(i);
        _vector$3.y = this.getY(i);
        _vector$3.z = this.getZ(i);
        _vector$3.applyMatrix4(m);
        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
      }
      return this;
    },
    applyNormalMatrix: function(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$3.x = this.getX(i);
        _vector$3.y = this.getY(i);
        _vector$3.z = this.getZ(i);
        _vector$3.applyNormalMatrix(m);
        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
      }
      return this;
    },
    transformDirection: function(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$3.x = this.getX(i);
        _vector$3.y = this.getY(i);
        _vector$3.z = this.getZ(i);
        _vector$3.transformDirection(m);
        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
      }
      return this;
    },
    set: function(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    },
    getX: function(index) {
      return this.array[index * this.itemSize];
    },
    setX: function(index, x) {
      this.array[index * this.itemSize] = x;
      return this;
    },
    getY: function(index) {
      return this.array[index * this.itemSize + 1];
    },
    setY: function(index, y) {
      this.array[index * this.itemSize + 1] = y;
      return this;
    },
    getZ: function(index) {
      return this.array[index * this.itemSize + 2];
    },
    setZ: function(index, z) {
      this.array[index * this.itemSize + 2] = z;
      return this;
    },
    getW: function(index) {
      return this.array[index * this.itemSize + 3];
    },
    setW: function(index, w) {
      this.array[index * this.itemSize + 3] = w;
      return this;
    },
    setXY: function(index, x, y) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      return this;
    },
    setXYZ: function(index, x, y, z) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    },
    setXYZW: function(index, x, y, z, w) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    },
    onUpload: function(callback) {
      this.onUploadCallback = callback;
      return this;
    },
    clone: function() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    },
    toJSON: function() {
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.prototype.slice.call(this.array),
        normalized: this.normalized
      };
    }
  });
  function Int8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
  }
  Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
  function Uint8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
  }
  Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
  function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
  }
  Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
  function Int16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
  }
  Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
  function Uint16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
  }
  Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
  function Int32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
  }
  Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
  function Uint32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
  }
  Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
  function Float16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
  }
  Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
  Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
  function Float32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
  }
  Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
  function Float64BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
  }
  Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
  var DirectGeometry = class {
    constructor() {
      this.vertices = [];
      this.normals = [];
      this.colors = [];
      this.uvs = [];
      this.uvs2 = [];
      this.groups = [];
      this.morphTargets = {};
      this.skinWeights = [];
      this.skinIndices = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.verticesNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.groupsNeedUpdate = false;
    }
    computeGroups(geometry) {
      const groups = [];
      let group2, i;
      let materialIndex = void 0;
      const faces = geometry.faces;
      for (i = 0; i < faces.length; i++) {
        const face = faces[i];
        if (face.materialIndex !== materialIndex) {
          materialIndex = face.materialIndex;
          if (group2 !== void 0) {
            group2.count = i * 3 - group2.start;
            groups.push(group2);
          }
          group2 = {
            start: i * 3,
            materialIndex
          };
        }
      }
      if (group2 !== void 0) {
        group2.count = i * 3 - group2.start;
        groups.push(group2);
      }
      this.groups = groups;
    }
    fromGeometry(geometry) {
      const faces = geometry.faces;
      const vertices = geometry.vertices;
      const faceVertexUvs = geometry.faceVertexUvs;
      const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
      const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
      const morphTargets = geometry.morphTargets;
      const morphTargetsLength = morphTargets.length;
      let morphTargetsPosition;
      if (morphTargetsLength > 0) {
        morphTargetsPosition = [];
        for (let i = 0; i < morphTargetsLength; i++) {
          morphTargetsPosition[i] = {
            name: morphTargets[i].name,
            data: []
          };
        }
        this.morphTargets.position = morphTargetsPosition;
      }
      const morphNormals = geometry.morphNormals;
      const morphNormalsLength = morphNormals.length;
      let morphTargetsNormal;
      if (morphNormalsLength > 0) {
        morphTargetsNormal = [];
        for (let i = 0; i < morphNormalsLength; i++) {
          morphTargetsNormal[i] = {
            name: morphNormals[i].name,
            data: []
          };
        }
        this.morphTargets.normal = morphTargetsNormal;
      }
      const skinIndices = geometry.skinIndices;
      const skinWeights = geometry.skinWeights;
      const hasSkinIndices = skinIndices.length === vertices.length;
      const hasSkinWeights = skinWeights.length === vertices.length;
      if (vertices.length > 0 && faces.length === 0) {
        console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
      }
      for (let i = 0; i < faces.length; i++) {
        const face = faces[i];
        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
        const vertexNormals = face.vertexNormals;
        if (vertexNormals.length === 3) {
          this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
        } else {
          const normal = face.normal;
          this.normals.push(normal, normal, normal);
        }
        const vertexColors = face.vertexColors;
        if (vertexColors.length === 3) {
          this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
        } else {
          const color = face.color;
          this.colors.push(color, color, color);
        }
        if (hasFaceVertexUv === true) {
          const vertexUvs = faceVertexUvs[0][i];
          if (vertexUvs !== void 0) {
            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
          } else {
            console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i);
            this.uvs.push(new Vector2(), new Vector2(), new Vector2());
          }
        }
        if (hasFaceVertexUv2 === true) {
          const vertexUvs = faceVertexUvs[1][i];
          if (vertexUvs !== void 0) {
            this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
          } else {
            console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i);
            this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
          }
        }
        for (let j = 0; j < morphTargetsLength; j++) {
          const morphTarget = morphTargets[j].vertices;
          morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
        }
        for (let j = 0; j < morphNormalsLength; j++) {
          const morphNormal = morphNormals[j].vertexNormals[i];
          morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
        }
        if (hasSkinIndices) {
          this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
        }
        if (hasSkinWeights) {
          this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
        }
      }
      this.computeGroups(geometry);
      this.verticesNeedUpdate = geometry.verticesNeedUpdate;
      this.normalsNeedUpdate = geometry.normalsNeedUpdate;
      this.colorsNeedUpdate = geometry.colorsNeedUpdate;
      this.uvsNeedUpdate = geometry.uvsNeedUpdate;
      this.groupsNeedUpdate = geometry.groupsNeedUpdate;
      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }
      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
      return this;
    }
  };
  function arrayMax(array) {
    if (array.length === 0)
      return -Infinity;
    let max = array[0];
    for (let i = 1, l = array.length; i < l; ++i) {
      if (array[i] > max)
        max = array[i];
    }
    return max;
  }
  var TYPED_ARRAYS = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray: typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  };
  function getTypedArray(type, buffer) {
    return new TYPED_ARRAYS[type](buffer);
  }
  var _bufferGeometryId = 1;
  var _m1$2 = new Matrix4();
  var _obj = new Object3D();
  var _offset = new Vector3();
  var _box$2 = new Box3();
  var _boxMorphTargets = new Box3();
  var _vector$4 = new Vector3();
  function BufferGeometry() {
    Object.defineProperty(this, "id", {value: _bufferGeometryId += 2});
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {start: 0, count: Infinity};
    this.userData = {};
  }
  BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: BufferGeometry,
    isBufferGeometry: true,
    getIndex: function() {
      return this.index;
    },
    setIndex: function(index) {
      if (Array.isArray(index)) {
        this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
      } else {
        this.index = index;
      }
      return this;
    },
    getAttribute: function(name) {
      return this.attributes[name];
    },
    setAttribute: function(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    },
    deleteAttribute: function(name) {
      delete this.attributes[name];
      return this;
    },
    hasAttribute: function(name) {
      return this.attributes[name] !== void 0;
    },
    addGroup: function(start, count, materialIndex = 0) {
      this.groups.push({
        start,
        count,
        materialIndex
      });
    },
    clearGroups: function() {
      this.groups = [];
    },
    setDrawRange: function(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    },
    applyMatrix4: function(matrix) {
      const position = this.attributes.position;
      if (position !== void 0) {
        position.applyMatrix4(matrix);
        position.needsUpdate = true;
      }
      const normal = this.attributes.normal;
      if (normal !== void 0) {
        const normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normal.applyNormalMatrix(normalMatrix);
        normal.needsUpdate = true;
      }
      const tangent = this.attributes.tangent;
      if (tangent !== void 0) {
        tangent.transformDirection(matrix);
        tangent.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      return this;
    },
    rotateX: function(angle) {
      _m1$2.makeRotationX(angle);
      this.applyMatrix4(_m1$2);
      return this;
    },
    rotateY: function(angle) {
      _m1$2.makeRotationY(angle);
      this.applyMatrix4(_m1$2);
      return this;
    },
    rotateZ: function(angle) {
      _m1$2.makeRotationZ(angle);
      this.applyMatrix4(_m1$2);
      return this;
    },
    translate: function(x, y, z) {
      _m1$2.makeTranslation(x, y, z);
      this.applyMatrix4(_m1$2);
      return this;
    },
    scale: function(x, y, z) {
      _m1$2.makeScale(x, y, z);
      this.applyMatrix4(_m1$2);
      return this;
    },
    lookAt: function(vector) {
      _obj.lookAt(vector);
      _obj.updateMatrix();
      this.applyMatrix4(_obj.matrix);
      return this;
    },
    center: function() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset).negate();
      this.translate(_offset.x, _offset.y, _offset.z);
      return this;
    },
    setFromObject: function(object) {
      const geometry = object.geometry;
      if (object.isPoints || object.isLine) {
        const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
        const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
        this.setAttribute("position", positions.copyVector3sArray(geometry.vertices));
        this.setAttribute("color", colors.copyColorsArray(geometry.colors));
        if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
          const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
          this.setAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
        }
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
      } else if (object.isMesh) {
        if (geometry && geometry.isGeometry) {
          this.fromGeometry(geometry);
        }
      }
      return this;
    },
    setFromPoints: function(points) {
      const position = [];
      for (let i = 0, l = points.length; i < l; i++) {
        const point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(position, 3));
      return this;
    },
    updateFromObject: function(object) {
      let geometry = object.geometry;
      if (object.isMesh) {
        let direct = geometry.__directGeometry;
        if (geometry.elementsNeedUpdate === true) {
          direct = void 0;
          geometry.elementsNeedUpdate = false;
        }
        if (direct === void 0) {
          return this.fromGeometry(geometry);
        }
        direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
        direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
        direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
        direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
        direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
        geometry.verticesNeedUpdate = false;
        geometry.normalsNeedUpdate = false;
        geometry.colorsNeedUpdate = false;
        geometry.uvsNeedUpdate = false;
        geometry.groupsNeedUpdate = false;
        geometry = direct;
      }
      if (geometry.verticesNeedUpdate === true) {
        const attribute = this.attributes.position;
        if (attribute !== void 0) {
          attribute.copyVector3sArray(geometry.vertices);
          attribute.needsUpdate = true;
        }
        geometry.verticesNeedUpdate = false;
      }
      if (geometry.normalsNeedUpdate === true) {
        const attribute = this.attributes.normal;
        if (attribute !== void 0) {
          attribute.copyVector3sArray(geometry.normals);
          attribute.needsUpdate = true;
        }
        geometry.normalsNeedUpdate = false;
      }
      if (geometry.colorsNeedUpdate === true) {
        const attribute = this.attributes.color;
        if (attribute !== void 0) {
          attribute.copyColorsArray(geometry.colors);
          attribute.needsUpdate = true;
        }
        geometry.colorsNeedUpdate = false;
      }
      if (geometry.uvsNeedUpdate) {
        const attribute = this.attributes.uv;
        if (attribute !== void 0) {
          attribute.copyVector2sArray(geometry.uvs);
          attribute.needsUpdate = true;
        }
        geometry.uvsNeedUpdate = false;
      }
      if (geometry.lineDistancesNeedUpdate) {
        const attribute = this.attributes.lineDistance;
        if (attribute !== void 0) {
          attribute.copyArray(geometry.lineDistances);
          attribute.needsUpdate = true;
        }
        geometry.lineDistancesNeedUpdate = false;
      }
      if (geometry.groupsNeedUpdate) {
        geometry.computeGroups(object.geometry);
        this.groups = geometry.groups;
        geometry.groupsNeedUpdate = false;
      }
      return this;
    },
    fromGeometry: function(geometry) {
      geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
      return this.fromDirectGeometry(geometry.__directGeometry);
    },
    fromDirectGeometry: function(geometry) {
      const positions = new Float32Array(geometry.vertices.length * 3);
      this.setAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
      if (geometry.normals.length > 0) {
        const normals = new Float32Array(geometry.normals.length * 3);
        this.setAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
      }
      if (geometry.colors.length > 0) {
        const colors = new Float32Array(geometry.colors.length * 3);
        this.setAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
      }
      if (geometry.uvs.length > 0) {
        const uvs = new Float32Array(geometry.uvs.length * 2);
        this.setAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
      }
      if (geometry.uvs2.length > 0) {
        const uvs2 = new Float32Array(geometry.uvs2.length * 2);
        this.setAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
      }
      this.groups = geometry.groups;
      for (const name in geometry.morphTargets) {
        const array = [];
        const morphTargets = geometry.morphTargets[name];
        for (let i = 0, l = morphTargets.length; i < l; i++) {
          const morphTarget = morphTargets[i];
          const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
          attribute.name = morphTarget.name;
          array.push(attribute.copyVector3sArray(morphTarget.data));
        }
        this.morphAttributes[name] = array;
      }
      if (geometry.skinIndices.length > 0) {
        const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
        this.setAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
      }
      if (geometry.skinWeights.length > 0) {
        const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
        this.setAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
      }
      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }
      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
      return this;
    },
    computeBoundingBox: function() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
        return;
      }
      if (position !== void 0) {
        this.boundingBox.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            _box$2.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$4.addVectors(this.boundingBox.min, _box$2.min);
              this.boundingBox.expandByPoint(_vector$4);
              _vector$4.addVectors(this.boundingBox.max, _box$2.max);
              this.boundingBox.expandByPoint(_vector$4);
            } else {
              this.boundingBox.expandByPoint(_box$2.min);
              this.boundingBox.expandByPoint(_box$2.max);
            }
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }
      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    },
    computeBoundingSphere: function() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingSphere.set(new Vector3(), Infinity);
        return;
      }
      if (position) {
        const center = this.boundingSphere.center;
        _box$2.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            _boxMorphTargets.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);
              _box$2.expandByPoint(_vector$4);
              _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);
              _box$2.expandByPoint(_vector$4);
            } else {
              _box$2.expandByPoint(_boxMorphTargets.min);
              _box$2.expandByPoint(_boxMorphTargets.max);
            }
          }
        }
        _box$2.getCenter(center);
        let maxRadiusSq = 0;
        for (let i = 0, il = position.count; i < il; i++) {
          _vector$4.fromBufferAttribute(position, i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
        }
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            const morphTargetsRelative = this.morphTargetsRelative;
            for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
              _vector$4.fromBufferAttribute(morphAttribute, j);
              if (morphTargetsRelative) {
                _offset.fromBufferAttribute(position, j);
                _vector$4.add(_offset);
              }
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
            }
          }
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    },
    computeFaceNormals: function() {
    },
    computeVertexNormals: function() {
      const index = this.index;
      const positionAttribute = this.getAttribute("position");
      if (positionAttribute !== void 0) {
        let normalAttribute = this.getAttribute("normal");
        if (normalAttribute === void 0) {
          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
          this.setAttribute("normal", normalAttribute);
        } else {
          for (let i = 0, il = normalAttribute.count; i < il; i++) {
            normalAttribute.setXYZ(i, 0, 0, 0);
          }
        }
        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
        const cb = new Vector3(), ab = new Vector3();
        if (index) {
          for (let i = 0, il = index.count; i < il; i += 3) {
            const vA = index.getX(i + 0);
            const vB = index.getX(i + 1);
            const vC = index.getX(i + 2);
            pA.fromBufferAttribute(positionAttribute, vA);
            pB.fromBufferAttribute(positionAttribute, vB);
            pC.fromBufferAttribute(positionAttribute, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            nA.fromBufferAttribute(normalAttribute, vA);
            nB.fromBufferAttribute(normalAttribute, vB);
            nC.fromBufferAttribute(normalAttribute, vC);
            nA.add(cb);
            nB.add(cb);
            nC.add(cb);
            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
          }
        } else {
          for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
            pA.fromBufferAttribute(positionAttribute, i + 0);
            pB.fromBufferAttribute(positionAttribute, i + 1);
            pC.fromBufferAttribute(positionAttribute, i + 2);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
          }
        }
        this.normalizeNormals();
        normalAttribute.needsUpdate = true;
      }
    },
    merge: function(geometry, offset) {
      if (!(geometry && geometry.isBufferGeometry)) {
        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
        return;
      }
      if (offset === void 0) {
        offset = 0;
        console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        if (geometry.attributes[key] === void 0)
          continue;
        const attribute1 = attributes[key];
        const attributeArray1 = attribute1.array;
        const attribute2 = geometry.attributes[key];
        const attributeArray2 = attribute2.array;
        const attributeOffset = attribute2.itemSize * offset;
        const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
        for (let i = 0, j = attributeOffset; i < length; i++, j++) {
          attributeArray1[j] = attributeArray2[i];
        }
      }
      return this;
    },
    normalizeNormals: function() {
      const normals = this.attributes.normal;
      for (let i = 0, il = normals.count; i < il; i++) {
        _vector$4.fromBufferAttribute(normals, i);
        _vector$4.normalize();
        normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
      }
    },
    toNonIndexed: function() {
      function convertBufferAttribute(attribute, indices2) {
        const array = attribute.array;
        const itemSize = attribute.itemSize;
        const normalized = attribute.normalized;
        const array2 = new array.constructor(indices2.length * itemSize);
        let index = 0, index2 = 0;
        for (let i = 0, l = indices2.length; i < l; i++) {
          index = indices2[i] * itemSize;
          for (let j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
          }
        }
        return new BufferAttribute(array2, itemSize, normalized);
      }
      if (this.index === null) {
        console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
        return this;
      }
      const geometry2 = new BufferGeometry();
      const indices = this.index.array;
      const attributes = this.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        const newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.setAttribute(name, newAttribute);
      }
      const morphAttributes = this.morphAttributes;
      for (const name in morphAttributes) {
        const morphArray = [];
        const morphAttribute = morphAttributes[name];
        for (let i = 0, il = morphAttribute.length; i < il; i++) {
          const attribute = morphAttribute[i];
          const newAttribute = convertBufferAttribute(attribute, indices);
          morphArray.push(newAttribute);
        }
        geometry2.morphAttributes[name] = morphArray;
      }
      geometry2.morphTargetsRelative = this.morphTargetsRelative;
      const groups = this.groups;
      for (let i = 0, l = groups.length; i < l; i++) {
        const group2 = groups[i];
        geometry2.addGroup(group2.start, group2.count, group2.materialIndex);
      }
      return geometry2;
    },
    toJSON: function() {
      const data = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (Object.keys(this.userData).length > 0)
        data.userData = this.userData;
      if (this.parameters !== void 0) {
        const parameters = this.parameters;
        for (const key in parameters) {
          if (parameters[key] !== void 0)
            data[key] = parameters[key];
        }
        return data;
      }
      data.data = {attributes: {}};
      const index = this.index;
      if (index !== null) {
        data.data.index = {
          type: index.array.constructor.name,
          array: Array.prototype.slice.call(index.array)
        };
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        const attribute = attributes[key];
        const attributeData = attribute.toJSON(data.data);
        if (attribute.name !== "")
          attributeData.name = attribute.name;
        data.data.attributes[key] = attributeData;
      }
      const morphAttributes = {};
      let hasMorphAttributes = false;
      for (const key in this.morphAttributes) {
        const attributeArray = this.morphAttributes[key];
        const array = [];
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          const attributeData = attribute.toJSON(data.data);
          if (attribute.name !== "")
            attributeData.name = attribute.name;
          array.push(attributeData);
        }
        if (array.length > 0) {
          morphAttributes[key] = array;
          hasMorphAttributes = true;
        }
      }
      if (hasMorphAttributes) {
        data.data.morphAttributes = morphAttributes;
        data.data.morphTargetsRelative = this.morphTargetsRelative;
      }
      const groups = this.groups;
      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }
      const boundingSphere = this.boundingSphere;
      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }
      return data;
    },
    clone: function() {
      return new BufferGeometry().copy(this);
    },
    copy: function(source) {
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      const data = {};
      this.name = source.name;
      const index = source.index;
      if (index !== null) {
        this.setIndex(index.clone(data));
      }
      const attributes = source.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        this.setAttribute(name, attribute.clone(data));
      }
      const morphAttributes = source.morphAttributes;
      for (const name in morphAttributes) {
        const array = [];
        const morphAttribute = morphAttributes[name];
        for (let i = 0, l = morphAttribute.length; i < l; i++) {
          array.push(morphAttribute[i].clone(data));
        }
        this.morphAttributes[name] = array;
      }
      this.morphTargetsRelative = source.morphTargetsRelative;
      const groups = source.groups;
      for (let i = 0, l = groups.length; i < l; i++) {
        const group2 = groups[i];
        this.addGroup(group2.start, group2.count, group2.materialIndex);
      }
      const boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }
      const boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }
      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;
      this.userData = source.userData;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({type: "dispose"});
    }
  });
  var _inverseMatrix = new Matrix4();
  var _ray = new Ray();
  var _sphere = new Sphere();
  var _vA = new Vector3();
  var _vB = new Vector3();
  var _vC = new Vector3();
  var _tempA = new Vector3();
  var _tempB = new Vector3();
  var _tempC = new Vector3();
  var _morphA = new Vector3();
  var _morphB = new Vector3();
  var _morphC = new Vector3();
  var _uvA = new Vector2();
  var _uvB = new Vector2();
  var _uvC = new Vector2();
  var _intersectionPoint = new Vector3();
  var _intersectionPointWorld = new Vector3();
  function Mesh(geometry, material) {
    Object3D.call(this);
    this.type = "Mesh";
    this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
    this.material = material !== void 0 ? material : new MeshBasicMaterial();
    this.updateMorphTargets();
  }
  Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Mesh,
    isMesh: true,
    copy: function(source) {
      Object3D.prototype.copy.call(this, source);
      if (source.morphTargetInfluences !== void 0) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }
      if (source.morphTargetDictionary !== void 0) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    },
    updateMorphTargets: function() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
              const name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        const morphTargets = geometry.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    },
    raycast: function(raycaster, intersects2) {
      const geometry = this.geometry;
      const material = this.material;
      const matrixWorld = this.matrixWorld;
      if (material === void 0)
        return;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere.copy(geometry.boundingSphere);
      _sphere.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(_sphere) === false)
        return;
      _inverseMatrix.copy(matrixWorld).invert();
      _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
      if (geometry.boundingBox !== null) {
        if (_ray.intersectsBox(geometry.boundingBox) === false)
          return;
      }
      let intersection;
      if (geometry.isBufferGeometry) {
        const index = geometry.index;
        const position = geometry.attributes.position;
        const morphPosition = geometry.morphAttributes.position;
        const morphTargetsRelative = geometry.morphTargetsRelative;
        const uv = geometry.attributes.uv;
        const uv2 = geometry.attributes.uv2;
        const groups = geometry.groups;
        const drawRange = geometry.drawRange;
        if (index !== null) {
          if (Array.isArray(material)) {
            for (let i = 0, il = groups.length; i < il; i++) {
              const group2 = groups[i];
              const groupMaterial = material[group2.materialIndex];
              const start = Math.max(group2.start, drawRange.start);
              const end = Math.min(group2.start + group2.count, drawRange.start + drawRange.count);
              for (let j = start, jl = end; j < jl; j += 3) {
                const a = index.getX(j);
                const b = index.getX(j + 1);
                const c = index.getX(j + 2);
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3);
                  intersection.face.materialIndex = group2.materialIndex;
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for (let i = start, il = end; i < il; i += 3) {
              const a = index.getX(i);
              const b = index.getX(i + 1);
              const c = index.getX(i + 2);
              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects2.push(intersection);
              }
            }
          }
        } else if (position !== void 0) {
          if (Array.isArray(material)) {
            for (let i = 0, il = groups.length; i < il; i++) {
              const group2 = groups[i];
              const groupMaterial = material[group2.materialIndex];
              const start = Math.max(group2.start, drawRange.start);
              const end = Math.min(group2.start + group2.count, drawRange.start + drawRange.count);
              for (let j = start, jl = end; j < jl; j += 3) {
                const a = j;
                const b = j + 1;
                const c = j + 2;
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3);
                  intersection.face.materialIndex = group2.materialIndex;
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(position.count, drawRange.start + drawRange.count);
            for (let i = start, il = end; i < il; i += 3) {
              const a = i;
              const b = i + 1;
              const c = i + 2;
              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects2.push(intersection);
              }
            }
          }
        }
      } else if (geometry.isGeometry) {
        const isMultiMaterial = Array.isArray(material);
        const vertices = geometry.vertices;
        const faces = geometry.faces;
        let uvs;
        const faceVertexUvs = geometry.faceVertexUvs[0];
        if (faceVertexUvs.length > 0)
          uvs = faceVertexUvs;
        for (let f = 0, fl = faces.length; f < fl; f++) {
          const face = faces[f];
          const faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
          if (faceMaterial === void 0)
            continue;
          const fvA = vertices[face.a];
          const fvB = vertices[face.b];
          const fvC = vertices[face.c];
          intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);
          if (intersection) {
            if (uvs && uvs[f]) {
              const uvs_f = uvs[f];
              _uvA.copy(uvs_f[0]);
              _uvB.copy(uvs_f[1]);
              _uvC.copy(uvs_f[2]);
              intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2());
            }
            intersection.face = face;
            intersection.faceIndex = f;
            intersects2.push(intersection);
          }
        }
      }
    }
  });
  function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    }
    if (intersect === null)
      return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far)
      return null;
    return {
      distance,
      point: _intersectionPointWorld.clone(),
      object
    };
  }
  function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
    _vA.fromBufferAttribute(position, a);
    _vB.fromBufferAttribute(position, b);
    _vC.fromBufferAttribute(position, c);
    const morphInfluences = object.morphTargetInfluences;
    if (material.morphTargets && morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      _morphB.set(0, 0, 0);
      _morphC.set(0, 0, 0);
      for (let i = 0, il = morphPosition.length; i < il; i++) {
        const influence = morphInfluences[i];
        const morphAttribute = morphPosition[i];
        if (influence === 0)
          continue;
        _tempA.fromBufferAttribute(morphAttribute, a);
        _tempB.fromBufferAttribute(morphAttribute, b);
        _tempC.fromBufferAttribute(morphAttribute, c);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
          _morphB.addScaledVector(_tempB, influence);
          _morphC.addScaledVector(_tempC, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(_vA), influence);
          _morphB.addScaledVector(_tempB.sub(_vB), influence);
          _morphC.addScaledVector(_tempC.sub(_vC), influence);
        }
      }
      _vA.add(_morphA);
      _vB.add(_morphB);
      _vC.add(_morphC);
    }
    if (object.isSkinnedMesh) {
      object.boneTransform(a, _vA);
      object.boneTransform(b, _vB);
      object.boneTransform(c, _vC);
    }
    const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
    if (intersection) {
      if (uv) {
        _uvA.fromBufferAttribute(uv, a);
        _uvB.fromBufferAttribute(uv, b);
        _uvC.fromBufferAttribute(uv, c);
        intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
      }
      if (uv2) {
        _uvA.fromBufferAttribute(uv2, a);
        _uvB.fromBufferAttribute(uv2, b);
        _uvC.fromBufferAttribute(uv2, c);
        intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
      }
      const face = new Face3(a, b, c);
      Triangle.getNormal(_vA, _vB, _vC, face.normal);
      intersection.face = face;
    }
    return intersection;
  }
  var BoxBufferGeometry = class extends BufferGeometry {
    constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
      super();
      this.type = "BoxBufferGeometry";
      this.parameters = {
        width,
        height,
        depth,
        widthSegments,
        heightSegments,
        depthSegments
      };
      const scope = this;
      widthSegments = Math.floor(widthSegments);
      heightSegments = Math.floor(heightSegments);
      depthSegments = Math.floor(depthSegments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let numberOfVertices = 0;
      let groupStart = 0;
      buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
      buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
      buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
      buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
      buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
      buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
        const segmentWidth = width2 / gridX;
        const segmentHeight = height2 / gridY;
        const widthHalf = width2 / 2;
        const heightHalf = height2 / 2;
        const depthHalf = depth2 / 2;
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        let vertexCounter = 0;
        let groupCount = 0;
        const vector = new Vector3();
        for (let iy = 0; iy < gridY1; iy++) {
          const y = iy * segmentHeight - heightHalf;
          for (let ix = 0; ix < gridX1; ix++) {
            const x = ix * segmentWidth - widthHalf;
            vector[u] = x * udir;
            vector[v] = y * vdir;
            vector[w] = depthHalf;
            vertices.push(vector.x, vector.y, vector.z);
            vector[u] = 0;
            vector[v] = 0;
            vector[w] = depth2 > 0 ? 1 : -1;
            normals.push(vector.x, vector.y, vector.z);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
            vertexCounter += 1;
          }
        }
        for (let iy = 0; iy < gridY; iy++) {
          for (let ix = 0; ix < gridX; ix++) {
            const a = numberOfVertices + ix + gridX1 * iy;
            const b = numberOfVertices + ix + gridX1 * (iy + 1);
            const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
            const d = numberOfVertices + (ix + 1) + gridX1 * iy;
            indices.push(a, b, d);
            indices.push(b, c, d);
            groupCount += 6;
          }
        }
        scope.addGroup(groupStart, groupCount, materialIndex);
        groupStart += groupCount;
        numberOfVertices += vertexCounter;
      }
    }
  };
  function cloneUniforms(src) {
    const dst = {};
    for (const u in src) {
      dst[u] = {};
      for (const p in src[u]) {
        const property = src[u][p];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
          dst[u][p] = property.clone();
        } else if (Array.isArray(property)) {
          dst[u][p] = property.slice();
        } else {
          dst[u][p] = property;
        }
      }
    }
    return dst;
  }
  function mergeUniforms(uniforms) {
    const merged = {};
    for (let u = 0; u < uniforms.length; u++) {
      const tmp2 = cloneUniforms(uniforms[u]);
      for (const p in tmp2) {
        merged[p] = tmp2[p];
      }
    }
    return merged;
  }
  var UniformsUtils = {clone: cloneUniforms, merge: mergeUniforms};
  var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  function ShaderMaterial(parameters) {
    Material.call(this);
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.extensions = {
      derivatives: false,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      if (parameters.attributes !== void 0) {
        console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
      }
      this.setValues(parameters);
    }
  }
  ShaderMaterial.prototype = Object.create(Material.prototype);
  ShaderMaterial.prototype.constructor = ShaderMaterial;
  ShaderMaterial.prototype.isShaderMaterial = true;
  ShaderMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  };
  ShaderMaterial.prototype.toJSON = function(meta) {
    const data = Material.prototype.toJSON.call(this, meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true)
        extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0)
      data.extensions = extensions;
    return data;
  };
  function Camera() {
    Object3D.call(this);
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }
  Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Camera,
    isCamera: true,
    copy: function(source, recursive) {
      Object3D.prototype.copy.call(this, source, recursive);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      return this;
    },
    getWorldDirection: function(target) {
      if (target === void 0) {
        console.warn("THREE.Camera: .getWorldDirection() target is now required");
        target = new Vector3();
      }
      this.updateWorldMatrix(true, false);
      const e = this.matrixWorld.elements;
      return target.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
      Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  });
  function PerspectiveCamera(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    Camera.call(this);
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: PerspectiveCamera,
    isPerspectiveCamera: true,
    copy: function(source, recursive) {
      Camera.prototype.copy.call(this, source, recursive);
      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    },
    setFocalLength: function(focalLength) {
      const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
      this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
      this.updateProjectionMatrix();
    },
    getFocalLength: function() {
      const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / vExtentSlope;
    },
    getEffectiveFOV: function() {
      return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
      return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
      return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      const near = this.near;
      let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
      let height = 2 * top;
      let width = this.aspect * height;
      let left = -0.5 * width;
      const view = this.view;
      if (this.view !== null && this.view.enabled) {
        const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
        left += view.offsetX * width / fullWidth;
        top -= view.offsetY * height / fullHeight;
        width *= view.width / fullWidth;
        height *= view.height / fullHeight;
      }
      const skew = this.filmOffset;
      if (skew !== 0)
        left += near * skew / this.getFilmWidth();
      this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    },
    toJSON: function(meta) {
      const data = Object3D.prototype.toJSON.call(this, meta);
      data.object.fov = this.fov;
      data.object.zoom = this.zoom;
      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;
      data.object.aspect = this.aspect;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;
      return data;
    }
  });
  var fov = 90;
  var aspect = 1;
  function CubeCamera(near, far, renderTarget) {
    Object3D.call(this);
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
    this.update = function(renderer3, scene2) {
      if (this.parent === null)
        this.updateMatrixWorld();
      const currentXrEnabled = renderer3.xr.enabled;
      const currentRenderTarget = renderer3.getRenderTarget();
      renderer3.xr.enabled = false;
      const generateMipmaps = renderTarget.texture.generateMipmaps;
      renderTarget.texture.generateMipmaps = false;
      renderer3.setRenderTarget(renderTarget, 0);
      renderer3.render(scene2, cameraPX);
      renderer3.setRenderTarget(renderTarget, 1);
      renderer3.render(scene2, cameraNX);
      renderer3.setRenderTarget(renderTarget, 2);
      renderer3.render(scene2, cameraPY);
      renderer3.setRenderTarget(renderTarget, 3);
      renderer3.render(scene2, cameraNY);
      renderer3.setRenderTarget(renderTarget, 4);
      renderer3.render(scene2, cameraPZ);
      renderTarget.texture.generateMipmaps = generateMipmaps;
      renderer3.setRenderTarget(renderTarget, 5);
      renderer3.render(scene2, cameraNZ);
      renderer3.setRenderTarget(currentRenderTarget);
      renderer3.xr.enabled = currentXrEnabled;
    };
  }
  CubeCamera.prototype = Object.create(Object3D.prototype);
  CubeCamera.prototype.constructor = CubeCamera;
  function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    format = format !== void 0 ? format : RGBFormat;
    Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
    this._needsFlipEnvMap = true;
  }
  CubeTexture.prototype = Object.create(Texture.prototype);
  CubeTexture.prototype.constructor = CubeTexture;
  CubeTexture.prototype.isCubeTexture = true;
  Object.defineProperty(CubeTexture.prototype, "images", {
    get: function() {
      return this.image;
    },
    set: function(value) {
      this.image = value;
    }
  });
  function WebGLCubeRenderTarget(size, options, dummy) {
    if (Number.isInteger(options)) {
      console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
      options = dummy;
    }
    WebGLRenderTarget.call(this, size, size, options);
    options = options || {};
    this.texture = new CubeTexture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture._needsFlipEnvMap = false;
  }
  WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);
  WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;
  WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
  WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function(renderer3, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: {value: null}
      },
      vertexShader: `

			varying vec3 vWorldDirection;

			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

			}

			void main() {

				vWorldDirection = transformDirection( position, modelMatrix );

				#include <begin_vertex>
				#include <project_vertex>

			}
		`,
      fragmentShader: `

			uniform sampler2D tEquirect;

			varying vec3 vWorldDirection;

			#include <common>

			void main() {

				vec3 direction = normalize( vWorldDirection );

				vec2 sampleUV = equirectUv( direction );

				gl_FragColor = texture2D( tEquirect, sampleUV );

			}
		`
    };
    const geometry = new BoxBufferGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera2 = new CubeCamera(1, 10, this);
    camera2.update(renderer3, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  };
  WebGLCubeRenderTarget.prototype.clear = function(renderer3, color, depth, stencil) {
    const currentRenderTarget = renderer3.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer3.setRenderTarget(this, i);
      renderer3.clear(color, depth, stencil);
    }
    renderer3.setRenderTarget(currentRenderTarget);
  };
  function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {data: data || null, width: width || 1, height: height || 1};
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
  DataTexture.prototype = Object.create(Texture.prototype);
  DataTexture.prototype.constructor = DataTexture;
  DataTexture.prototype.isDataTexture = true;
  var _sphere$1 = /* @__PURE__ */ new Sphere();
  var _vector$5 = /* @__PURE__ */ new Vector3();
  var Frustum = class {
    constructor(p0, p1, p2, p3, p4, p5) {
      this.planes = [
        p0 !== void 0 ? p0 : new Plane(),
        p1 !== void 0 ? p1 : new Plane(),
        p2 !== void 0 ? p2 : new Plane(),
        p3 !== void 0 ? p3 : new Plane(),
        p4 !== void 0 ? p4 : new Plane(),
        p5 !== void 0 ? p5 : new Plane()
      ];
    }
    set(p0, p1, p2, p3, p4, p5) {
      const planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(frustum) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        planes[i].copy(frustum.planes[i]);
      }
      return this;
    }
    setFromProjectionMatrix(m) {
      const planes = this.planes;
      const me = m.elements;
      const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
      const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
      const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
      const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
      return this;
    }
    intersectsObject(object) {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(_sphere$1);
    }
    intersectsSprite(sprite) {
      _sphere$1.center.set(0, 0, 0);
      _sphere$1.radius = 0.7071067811865476;
      _sphere$1.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(_sphere$1);
    }
    intersectsSphere(sphere) {
      const planes = this.planes;
      const center = sphere.center;
      const negRadius = -sphere.radius;
      for (let i = 0; i < 6; i++) {
        const distance = planes[i].distanceToPoint(center);
        if (distance < negRadius) {
          return false;
        }
      }
      return true;
    }
    intersectsBox(box) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        const plane = planes[i];
        _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        if (plane.distanceToPoint(_vector$5) < 0) {
          return false;
        }
      }
      return true;
    }
    containsPoint(point) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        if (planes[i].distanceToPoint(point) < 0) {
          return false;
        }
      }
      return true;
    }
  };
  function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
      animationLoop(time, frame);
      requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
      start: function() {
        if (isAnimating === true)
          return;
        if (animationLoop === null)
          return;
        requestId = context.requestAnimationFrame(onAnimationFrame);
        isAnimating = true;
      },
      stop: function() {
        context.cancelAnimationFrame(requestId);
        isAnimating = false;
      },
      setAnimationLoop: function(callback) {
        animationLoop = callback;
      },
      setContext: function(value) {
        context = value;
      }
    };
  }
  function WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = new WeakMap();
    function createBuffer(attribute, bufferType) {
      const array = attribute.array;
      const usage = attribute.usage;
      const buffer = gl.createBuffer();
      gl.bindBuffer(bufferType, buffer);
      gl.bufferData(bufferType, array, usage);
      attribute.onUploadCallback();
      let type = 5126;
      if (array instanceof Float32Array) {
        type = 5126;
      } else if (array instanceof Float64Array) {
        console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
      } else if (array instanceof Uint16Array) {
        if (attribute.isFloat16BufferAttribute) {
          if (isWebGL2) {
            type = 5131;
          } else {
            console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
          }
        } else {
          type = 5123;
        }
      } else if (array instanceof Int16Array) {
        type = 5122;
      } else if (array instanceof Uint32Array) {
        type = 5125;
      } else if (array instanceof Int32Array) {
        type = 5124;
      } else if (array instanceof Int8Array) {
        type = 5120;
      } else if (array instanceof Uint8Array) {
        type = 5121;
      }
      return {
        buffer,
        type,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version
      };
    }
    function updateBuffer(buffer, attribute, bufferType) {
      const array = attribute.array;
      const updateRange = attribute.updateRange;
      gl.bindBuffer(bufferType, buffer);
      if (updateRange.count === -1) {
        gl.bufferSubData(bufferType, 0, array);
      } else {
        if (isWebGL2) {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
        } else {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
        }
        updateRange.count = -1;
      }
    }
    function get(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      return buffers.get(attribute);
    }
    function remove(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data) {
        gl.deleteBuffer(data.buffer);
        buffers.delete(attribute);
      }
    }
    function update2(attribute, bufferType) {
      if (attribute.isGLBufferAttribute) {
        const cached = buffers.get(attribute);
        if (!cached || cached.version < attribute.version) {
          buffers.set(attribute, {
            buffer: attribute.buffer,
            type: attribute.type,
            bytesPerElement: attribute.elementSize,
            version: attribute.version
          });
        }
        return;
      }
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data === void 0) {
        buffers.set(attribute, createBuffer(attribute, bufferType));
      } else if (data.version < attribute.version) {
        updateBuffer(data.buffer, attribute, bufferType);
        data.version = attribute.version;
      }
    }
    return {
      get,
      remove,
      update: update2
    };
  }
  var PlaneBufferGeometry = class extends BufferGeometry {
    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
      super();
      this.type = "PlaneBufferGeometry";
      this.parameters = {
        width,
        height,
        widthSegments,
        heightSegments
      };
      const width_half = width / 2;
      const height_half = height / 2;
      const gridX = Math.floor(widthSegments);
      const gridY = Math.floor(heightSegments);
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      const segment_width = width / gridX;
      const segment_height = height / gridY;
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segment_height - height_half;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segment_width - width_half;
          vertices.push(x, -y, 0);
          normals.push(0, 0, 1);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = ix + gridX1 * iy;
          const b = ix + gridX1 * (iy + 1);
          const c = ix + 1 + gridX1 * (iy + 1);
          const d = ix + 1 + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
  };
  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
  var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
  var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
  var begin_vertex = "vec3 transformed = vec3( position );";
  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
  var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
  var color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
  var color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
  var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
  var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
  var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
  var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
  var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
  var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
  var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
  var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
  var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
  var fog_vertex = "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif";
  var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
  var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
  var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
  var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
  var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
  var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
  var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
  var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
  var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
  var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif";
  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
  var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif";
  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
  var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
  var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
  var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
  var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
  var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
  var normal_fragment_begin = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
  var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		float scale = sign( st1.t * st0.s - st0.t * st1.s );\n		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n		vec3 N = normalize( surf_norm );\n		mat3 tsn = mat3( S, T, N );\n		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		return normalize( tsn * mapN );\n	}\n#endif";
  var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
  var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n	#endif\n#endif";
  var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
  var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
  var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
  var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
  var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
  var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
  var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
  var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
  var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
  var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
  var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
  var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
  var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
  var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
  var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif";
  var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
  var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
  var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
  var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
  var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
  var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
  var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
  var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
  var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
  var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
  var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
  var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
  var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
  var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
  var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
  var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
  var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
  var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
  var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var ShaderChunk = {
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    encodings_fragment,
    encodings_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_fragment,
    lightmap_pars_fragment,
    lights_lambert_vertex,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmissionmap_fragment,
    transmissionmap_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    uv2_pars_fragment,
    uv2_pars_vertex,
    uv2_vertex,
    worldpos_vertex,
    background_frag,
    background_vert,
    cube_frag,
    cube_vert,
    depth_frag,
    depth_vert,
    distanceRGBA_frag,
    distanceRGBA_vert,
    equirect_frag,
    equirect_vert,
    linedashed_frag,
    linedashed_vert,
    meshbasic_frag,
    meshbasic_vert,
    meshlambert_frag,
    meshlambert_vert,
    meshmatcap_frag,
    meshmatcap_vert,
    meshtoon_frag,
    meshtoon_vert,
    meshphong_frag,
    meshphong_vert,
    meshphysical_frag,
    meshphysical_vert,
    normal_frag,
    normal_vert,
    points_frag,
    points_vert,
    shadow_frag,
    shadow_vert,
    sprite_frag,
    sprite_vert
  };
  var UniformsLib = {
    common: {
      diffuse: {value: new Color(15658734)},
      opacity: {value: 1},
      map: {value: null},
      uvTransform: {value: new Matrix3()},
      uv2Transform: {value: new Matrix3()},
      alphaMap: {value: null}
    },
    specularmap: {
      specularMap: {value: null}
    },
    envmap: {
      envMap: {value: null},
      flipEnvMap: {value: -1},
      reflectivity: {value: 1},
      refractionRatio: {value: 0.98},
      maxMipLevel: {value: 0}
    },
    aomap: {
      aoMap: {value: null},
      aoMapIntensity: {value: 1}
    },
    lightmap: {
      lightMap: {value: null},
      lightMapIntensity: {value: 1}
    },
    emissivemap: {
      emissiveMap: {value: null}
    },
    bumpmap: {
      bumpMap: {value: null},
      bumpScale: {value: 1}
    },
    normalmap: {
      normalMap: {value: null},
      normalScale: {value: new Vector2(1, 1)}
    },
    displacementmap: {
      displacementMap: {value: null},
      displacementScale: {value: 1},
      displacementBias: {value: 0}
    },
    roughnessmap: {
      roughnessMap: {value: null}
    },
    metalnessmap: {
      metalnessMap: {value: null}
    },
    gradientmap: {
      gradientMap: {value: null}
    },
    fog: {
      fogDensity: {value: 25e-5},
      fogNear: {value: 1},
      fogFar: {value: 2e3},
      fogColor: {value: new Color(16777215)}
    },
    lights: {
      ambientLightColor: {value: []},
      lightProbe: {value: []},
      directionalLights: {value: [], properties: {
        direction: {},
        color: {}
      }},
      directionalLightShadows: {value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }},
      directionalShadowMap: {value: []},
      directionalShadowMatrix: {value: []},
      spotLights: {value: [], properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      }},
      spotLightShadows: {value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }},
      spotShadowMap: {value: []},
      spotShadowMatrix: {value: []},
      pointLights: {value: [], properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      }},
      pointLightShadows: {value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      }},
      pointShadowMap: {value: []},
      pointShadowMatrix: {value: []},
      hemisphereLights: {value: [], properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      }},
      rectAreaLights: {value: [], properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      }},
      ltc_1: {value: null},
      ltc_2: {value: null}
    },
    points: {
      diffuse: {value: new Color(15658734)},
      opacity: {value: 1},
      size: {value: 1},
      scale: {value: 1},
      map: {value: null},
      alphaMap: {value: null},
      uvTransform: {value: new Matrix3()}
    },
    sprite: {
      diffuse: {value: new Color(15658734)},
      opacity: {value: 1},
      center: {value: new Vector2(0.5, 0.5)},
      rotation: {value: 0},
      map: {value: null},
      alphaMap: {value: null},
      uvTransform: {value: new Matrix3()}
    }
  };
  var ShaderLib = {
    basic: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: {value: new Color(0)}
        }
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: {value: new Color(0)},
          specular: {value: new Color(1118481)},
          shininess: {value: 30}
        }
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: {value: new Color(0)},
          roughness: {value: 1},
          metalness: {value: 0},
          envMapIntensity: {value: 1}
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: {value: new Color(0)}
        }
      ]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        {
          matcap: {value: null}
        }
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
      uniforms: mergeUniforms([
        UniformsLib.points,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: {value: 1},
          dashSize: {value: 1},
          totalSize: {value: 2}
        }
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        {
          opacity: {value: 1}
        }
      ]),
      vertexShader: ShaderChunk.normal_vert,
      fragmentShader: ShaderChunk.normal_frag
    },
    sprite: {
      uniforms: mergeUniforms([
        UniformsLib.sprite,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: {value: new Matrix3()},
        t2D: {value: null}
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag
    },
    cube: {
      uniforms: mergeUniforms([
        UniformsLib.envmap,
        {
          opacity: {value: 1}
        }
      ]),
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: {value: null}
      },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: {value: new Vector3()},
          nearDistance: {value: 1},
          farDistance: {value: 1e3}
        }
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
      uniforms: mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        {
          color: {value: new Color(0)},
          opacity: {value: 1}
        }
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag
    }
  };
  ShaderLib.physical = {
    uniforms: mergeUniforms([
      ShaderLib.standard.uniforms,
      {
        clearcoat: {value: 0},
        clearcoatMap: {value: null},
        clearcoatRoughness: {value: 0},
        clearcoatRoughnessMap: {value: null},
        clearcoatNormalScale: {value: new Vector2(1, 1)},
        clearcoatNormalMap: {value: null},
        sheen: {value: new Color(0)},
        transmission: {value: 0},
        transmissionMap: {value: null}
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  };
  function WebGLBackground(renderer3, cubemaps, state, objects, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = 0;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene2, camera2, forceClear) {
      let background = scene2.isScene === true ? scene2.background : null;
      if (background && background.isTexture) {
        background = cubemaps.get(background);
      }
      const xr = renderer3.xr;
      const session = xr.getSession && xr.getSession();
      if (session && session.environmentBlendMode === "additive") {
        background = null;
      }
      if (background === null) {
        setClear(clearColor, clearAlpha);
      } else if (background && background.isColor) {
        setClear(background, 1);
        forceClear = true;
      }
      if (renderer3.autoClear || forceClear) {
        renderer3.clear(renderer3.autoClearColor, renderer3.autoClearDepth, renderer3.autoClearStencil);
      }
      if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
        if (boxMesh === void 0) {
          boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          boxMesh.geometry.deleteAttribute("normal");
          boxMesh.geometry.deleteAttribute("uv");
          boxMesh.onBeforeRender = function(renderer4, scene3, camera3) {
            this.matrixWorld.copyPosition(camera3.matrixWorld);
          };
          Object.defineProperty(boxMesh.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          });
          objects.update(boxMesh);
        }
        if (background.isWebGLCubeRenderTarget) {
          background = background.texture;
        }
        boxMesh.material.uniforms.envMap.value = background;
        boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer3.toneMapping) {
          boxMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer3.toneMapping;
        }
        renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
      } else if (background && background.isTexture) {
        if (planeMesh === void 0) {
          planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          planeMesh.geometry.deleteAttribute("normal");
          Object.defineProperty(planeMesh.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          });
          objects.update(planeMesh);
        }
        planeMesh.material.uniforms.t2D.value = background;
        if (background.matrixAutoUpdate === true) {
          background.updateMatrix();
        }
        planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer3.toneMapping) {
          planeMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer3.toneMapping;
        }
        renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
      }
    }
    function setClear(color, alpha) {
      state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
    }
    return {
      getClearColor: function() {
        return clearColor;
      },
      setClearColor: function(color, alpha = 1) {
        clearColor.set(color);
        clearAlpha = alpha;
        setClear(clearColor, clearAlpha);
      },
      getClearAlpha: function() {
        return clearAlpha;
      },
      setClearAlpha: function(alpha) {
        clearAlpha = alpha;
        setClear(clearColor, clearAlpha);
      },
      render
    };
  }
  function WebGLBindingStates(gl, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl.getParameter(34921);
    const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    function setup(object, material, program, geometry, index) {
      let updateBuffers = false;
      if (vaoAvailable) {
        const state = getBindingState(geometry, program, material);
        if (currentState !== state) {
          currentState = state;
          bindVertexArrayObject(currentState.object);
        }
        updateBuffers = needsUpdate(geometry, index);
        if (updateBuffers)
          saveCache(geometry, index);
      } else {
        const wireframe = material.wireframe === true;
        if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
          currentState.geometry = geometry.id;
          currentState.program = program.id;
          currentState.wireframe = wireframe;
          updateBuffers = true;
        }
      }
      if (object.isInstancedMesh === true) {
        updateBuffers = true;
      }
      if (index !== null) {
        attributes.update(index, 34963);
      }
      if (updateBuffers) {
        setupVertexAttributes(object, material, program, geometry);
        if (index !== null) {
          gl.bindBuffer(34963, attributes.get(index).buffer);
        }
      }
    }
    function createVertexArrayObject() {
      if (capabilities.isWebGL2)
        return gl.createVertexArray();
      return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.bindVertexArray(vao);
      return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.deleteVertexArray(vao);
      return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
      const wireframe = material.wireframe === true;
      let programMap = bindingStates[geometry.id];
      if (programMap === void 0) {
        programMap = {};
        bindingStates[geometry.id] = programMap;
      }
      let stateMap = programMap[program.id];
      if (stateMap === void 0) {
        stateMap = {};
        programMap[program.id] = stateMap;
      }
      let state = stateMap[wireframe];
      if (state === void 0) {
        state = createBindingState(createVertexArrayObject());
        stateMap[wireframe] = state;
      }
      return state;
    }
    function createBindingState(vao) {
      const newAttributes = [];
      const enabledAttributes = [];
      const attributeDivisors = [];
      for (let i = 0; i < maxVertexAttributes; i++) {
        newAttributes[i] = 0;
        enabledAttributes[i] = 0;
        attributeDivisors[i] = 0;
      }
      return {
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes,
        enabledAttributes,
        attributeDivisors,
        object: vao,
        attributes: {},
        index: null
      };
    }
    function needsUpdate(geometry, index) {
      const cachedAttributes = currentState.attributes;
      const geometryAttributes = geometry.attributes;
      let attributesNum = 0;
      for (const key in geometryAttributes) {
        const cachedAttribute = cachedAttributes[key];
        const geometryAttribute = geometryAttributes[key];
        if (cachedAttribute === void 0)
          return true;
        if (cachedAttribute.attribute !== geometryAttribute)
          return true;
        if (cachedAttribute.data !== geometryAttribute.data)
          return true;
        attributesNum++;
      }
      if (currentState.attributesNum !== attributesNum)
        return true;
      if (currentState.index !== index)
        return true;
      return false;
    }
    function saveCache(geometry, index) {
      const cache = {};
      const attributes2 = geometry.attributes;
      let attributesNum = 0;
      for (const key in attributes2) {
        const attribute = attributes2[key];
        const data = {};
        data.attribute = attribute;
        if (attribute.data) {
          data.data = attribute.data;
        }
        cache[key] = data;
        attributesNum++;
      }
      currentState.attributes = cache;
      currentState.attributesNum = attributesNum;
      currentState.index = index;
    }
    function initAttributes() {
      const newAttributes = currentState.newAttributes;
      for (let i = 0, il = newAttributes.length; i < il; i++) {
        newAttributes[i] = 0;
      }
    }
    function enableAttribute(attribute) {
      enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      const attributeDivisors = currentState.attributeDivisors;
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== meshPerAttribute) {
        const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
        extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    }
    function disableUnusedAttributes() {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      for (let i = 0, il = enabledAttributes.length; i < il; i++) {
        if (enabledAttributes[i] !== newAttributes[i]) {
          gl.disableVertexAttribArray(i);
          enabledAttributes[i] = 0;
        }
      }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset) {
      if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
        gl.vertexAttribIPointer(index, size, type, stride, offset);
      } else {
        gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
      }
    }
    function setupVertexAttributes(object, material, program, geometry) {
      if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
        if (extensions.get("ANGLE_instanced_arrays") === null)
          return;
      }
      initAttributes();
      const geometryAttributes = geometry.attributes;
      const programAttributes = program.getAttributes();
      const materialDefaultAttributeValues = material.defaultAttributeValues;
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute >= 0) {
          const geometryAttribute = geometryAttributes[name];
          if (geometryAttribute !== void 0) {
            const normalized = geometryAttribute.normalized;
            const size = geometryAttribute.itemSize;
            const attribute = attributes.get(geometryAttribute);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            const bytesPerElement = attribute.bytesPerElement;
            if (geometryAttribute.isInterleavedBufferAttribute) {
              const data = geometryAttribute.data;
              const stride = data.stride;
              const offset = geometryAttribute.offset;
              if (data && data.isInstancedInterleavedBuffer) {
                enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                if (geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                }
              } else {
                enableAttribute(programAttribute);
              }
              gl.bindBuffer(34962, buffer);
              vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
            } else {
              if (geometryAttribute.isInstancedBufferAttribute) {
                enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                if (geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                enableAttribute(programAttribute);
              }
              gl.bindBuffer(34962, buffer);
              vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
            }
          } else if (name === "instanceMatrix") {
            const attribute = attributes.get(object.instanceMatrix);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            enableAttributeAndDivisor(programAttribute + 0, 1);
            enableAttributeAndDivisor(programAttribute + 1, 1);
            enableAttributeAndDivisor(programAttribute + 2, 1);
            enableAttributeAndDivisor(programAttribute + 3, 1);
            gl.bindBuffer(34962, buffer);
            gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
            gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
            gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
            gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
          } else if (name === "instanceColor") {
            const attribute = attributes.get(object.instanceColor);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            enableAttributeAndDivisor(programAttribute, 1);
            gl.bindBuffer(34962, buffer);
            gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
          } else if (materialDefaultAttributeValues !== void 0) {
            const value = materialDefaultAttributeValues[name];
            if (value !== void 0) {
              switch (value.length) {
                case 2:
                  gl.vertexAttrib2fv(programAttribute, value);
                  break;
                case 3:
                  gl.vertexAttrib3fv(programAttribute, value);
                  break;
                case 4:
                  gl.vertexAttrib4fv(programAttribute, value);
                  break;
                default:
                  gl.vertexAttrib1fv(programAttribute, value);
              }
            }
          }
        }
      }
      disableUnusedAttributes();
    }
    function dispose() {
      reset();
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        for (const programId in programMap) {
          const stateMap = programMap[programId];
          for (const wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[programId];
        }
        delete bindingStates[geometryId];
      }
    }
    function releaseStatesOfGeometry(geometry) {
      if (bindingStates[geometry.id] === void 0)
        return;
      const programMap = bindingStates[geometry.id];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        if (programMap[program.id] === void 0)
          continue;
        const stateMap = programMap[program.id];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[program.id];
      }
    }
    function reset() {
      resetDefaultState();
      if (currentState === defaultState)
        return;
      currentState = defaultState;
      bindVertexArrayObject(currentState.object);
    }
    function resetDefaultState() {
      defaultState.geometry = null;
      defaultState.program = null;
      defaultState.wireframe = false;
    }
    return {
      setup,
      reset,
      resetDefaultState,
      dispose,
      releaseStatesOfGeometry,
      releaseStatesOfProgram,
      initAttributes,
      enableAttribute,
      disableUnusedAttributes
    };
  }
  function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    function render(start, count) {
      gl.drawArrays(mode, start, count);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawArraysInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawArraysInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, start, count, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
      if (maxAnisotropy !== void 0)
        return maxAnisotropy;
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (extension !== null) {
        maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        maxAnisotropy = 0;
      }
      return maxAnisotropy;
    }
    function getMaxPrecision(precision2) {
      if (precision2 === "highp") {
        if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
          return "highp";
        }
        precision2 = "mediump";
      }
      if (precision2 === "mediump") {
        if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
          return "mediump";
        }
      }
      return "lowp";
    }
    const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
    let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
      console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
      precision = maxPrecision;
    }
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(34930);
    const maxVertexTextures = gl.getParameter(35660);
    const maxTextureSize = gl.getParameter(3379);
    const maxCubemapSize = gl.getParameter(34076);
    const maxAttributes = gl.getParameter(34921);
    const maxVertexUniforms = gl.getParameter(36347);
    const maxVaryings = gl.getParameter(36348);
    const maxFragmentUniforms = gl.getParameter(36349);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || !!extensions.get("OES_texture_float");
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
      isWebGL2,
      getMaxAnisotropy,
      getMaxPrecision,
      precision,
      logarithmicDepthBuffer,
      maxTextures,
      maxVertexTextures,
      maxTextureSize,
      maxCubemapSize,
      maxAttributes,
      maxVertexUniforms,
      maxVaryings,
      maxFragmentUniforms,
      vertexTextures,
      floatFragmentTextures,
      floatVertexTextures,
      maxSamples
    };
  }
  function WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {value: null, needsUpdate: false};
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera2) {
      const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
      localClippingEnabled = enableLocalClipping;
      globalState = projectPlanes(planes, camera2, 0);
      numGlobalPlanes = planes.length;
      return enabled;
    };
    this.beginShadows = function() {
      renderingShadows = true;
      projectPlanes(null);
    };
    this.endShadows = function() {
      renderingShadows = false;
      resetGlobalState();
    };
    this.setState = function(material, camera2, useCache) {
      const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
      const materialProperties = properties.get(material);
      if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
          projectPlanes(null);
        } else {
          resetGlobalState();
        }
      } else {
        const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
        let dstArray = materialProperties.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera2, lGlobal, useCache);
        for (let i = 0; i !== lGlobal; ++i) {
          dstArray[i] = globalState[i];
        }
        materialProperties.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;
      }
    };
    function resetGlobalState() {
      if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
      }
      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera2, dstOffset, skipTransform) {
      const nPlanes = planes !== null ? planes.length : 0;
      let dstArray = null;
      if (nPlanes !== 0) {
        dstArray = uniform.value;
        if (skipTransform !== true || dstArray === null) {
          const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera2.matrixWorldInverse;
          viewNormalMatrix.getNormalMatrix(viewMatrix);
          if (dstArray === null || dstArray.length < flatSize) {
            dstArray = new Float32Array(flatSize);
          }
          for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
            plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
            plane.normal.toArray(dstArray, i4);
            dstArray[i4 + 3] = plane.constant;
          }
        }
        uniform.value = dstArray;
        uniform.needsUpdate = true;
      }
      scope.numPlanes = nPlanes;
      scope.numIntersection = 0;
      return dstArray;
    }
  }
  function WebGLCubeMaps(renderer3) {
    let cubemaps = new WeakMap();
    function mapTextureMapping(texture, mapping) {
      if (mapping === EquirectangularReflectionMapping) {
        texture.mapping = CubeReflectionMapping;
      } else if (mapping === EquirectangularRefractionMapping) {
        texture.mapping = CubeRefractionMapping;
      }
      return texture;
    }
    function get(texture) {
      if (texture && texture.isTexture) {
        const mapping = texture.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (cubemaps.has(texture)) {
            const cubemap = cubemaps.get(texture).texture;
            return mapTextureMapping(cubemap, texture.mapping);
          } else {
            const image = texture.image;
            if (image && image.height > 0) {
              const currentRenderList = renderer3.getRenderList();
              const currentRenderTarget = renderer3.getRenderTarget();
              const currentRenderState = renderer3.getRenderState();
              const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
              renderTarget.fromEquirectangularTexture(renderer3, texture);
              cubemaps.set(texture, renderTarget);
              renderer3.setRenderTarget(currentRenderTarget);
              renderer3.setRenderList(currentRenderList);
              renderer3.setRenderState(currentRenderState);
              texture.addEventListener("dispose", onTextureDispose);
              return mapTextureMapping(renderTarget.texture, texture.mapping);
            } else {
              return null;
            }
          }
        }
      }
      return texture;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemap = cubemaps.get(texture);
      if (cubemap !== void 0) {
        cubemaps.delete(texture);
        cubemap.dispose();
      }
    }
    function dispose() {
      cubemaps = new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function WebGLExtensions(gl) {
    const extensions = {};
    return {
      has: function(name) {
        if (extensions[name] !== void 0) {
          return extensions[name] !== null;
        }
        let extension;
        switch (name) {
          case "WEBGL_depth_texture":
            extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            extension = gl.getExtension(name);
        }
        extensions[name] = extension;
        return extension !== null;
      },
      get: function(name) {
        if (!this.has(name)) {
          console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
        }
        return extensions[name];
      }
    };
  }
  function WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = new WeakMap();
    const wireframeAttributes = new WeakMap();
    function onGeometryDispose(event) {
      const geometry = event.target;
      const buffergeometry = geometries.get(geometry);
      if (buffergeometry.index !== null) {
        attributes.remove(buffergeometry.index);
      }
      for (const name in buffergeometry.attributes) {
        attributes.remove(buffergeometry.attributes[name]);
      }
      geometry.removeEventListener("dispose", onGeometryDispose);
      geometries.delete(geometry);
      const attribute = wireframeAttributes.get(buffergeometry);
      if (attribute) {
        attributes.remove(attribute);
        wireframeAttributes.delete(buffergeometry);
      }
      bindingStates.releaseStatesOfGeometry(buffergeometry);
      if (geometry.isInstancedBufferGeometry === true) {
        delete geometry._maxInstanceCount;
      }
      info.memory.geometries--;
    }
    function get(object, geometry) {
      let buffergeometry = geometries.get(geometry);
      if (buffergeometry)
        return buffergeometry;
      geometry.addEventListener("dispose", onGeometryDispose);
      if (geometry.isBufferGeometry) {
        buffergeometry = geometry;
      } else if (geometry.isGeometry) {
        if (geometry._bufferGeometry === void 0) {
          geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
        }
        buffergeometry = geometry._bufferGeometry;
      }
      geometries.set(geometry, buffergeometry);
      info.memory.geometries++;
      return buffergeometry;
    }
    function update2(geometry) {
      const geometryAttributes = geometry.attributes;
      for (const name in geometryAttributes) {
        attributes.update(geometryAttributes[name], 34962);
      }
      const morphAttributes = geometry.morphAttributes;
      for (const name in morphAttributes) {
        const array = morphAttributes[name];
        for (let i = 0, l = array.length; i < l; i++) {
          attributes.update(array[i], 34962);
        }
      }
    }
    function updateWireframeAttribute(geometry) {
      const indices = [];
      const geometryIndex = geometry.index;
      const geometryPosition = geometry.attributes.position;
      let version = 0;
      if (geometryIndex !== null) {
        const array = geometryIndex.array;
        version = geometryIndex.version;
        for (let i = 0, l = array.length; i < l; i += 3) {
          const a = array[i + 0];
          const b = array[i + 1];
          const c = array[i + 2];
          indices.push(a, b, b, c, c, a);
        }
      } else {
        const array = geometryPosition.array;
        version = geometryPosition.version;
        for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
          const a = i + 0;
          const b = i + 1;
          const c = i + 2;
          indices.push(a, b, b, c, c, a);
        }
      }
      const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
      attribute.version = version;
      const previousAttribute = wireframeAttributes.get(geometry);
      if (previousAttribute)
        attributes.remove(previousAttribute);
      wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
      const currentAttribute = wireframeAttributes.get(geometry);
      if (currentAttribute) {
        const geometryIndex = geometry.index;
        if (geometryIndex !== null) {
          if (currentAttribute.version < geometryIndex.version) {
            updateWireframeAttribute(geometry);
          }
        }
      } else {
        updateWireframeAttribute(geometry);
      }
      return wireframeAttributes.get(geometry);
    }
    return {
      get,
      update: update2,
      getWireframeAttribute
    };
  }
  function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
      type = value.type;
      bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
      gl.drawElements(mode, count, type, start * bytesPerElement);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawElementsInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawElementsInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, count, type, start * bytesPerElement, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLInfo(gl) {
    const memory = {
      geometries: 0,
      textures: 0
    };
    const render = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function update2(count, mode, instanceCount) {
      render.calls++;
      switch (mode) {
        case 4:
          render.triangles += instanceCount * (count / 3);
          break;
        case 1:
          render.lines += instanceCount * (count / 2);
          break;
        case 3:
          render.lines += instanceCount * (count - 1);
          break;
        case 2:
          render.lines += instanceCount * count;
          break;
        case 0:
          render.points += instanceCount * count;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
          break;
      }
    }
    function reset() {
      render.frame++;
      render.calls = 0;
      render.triangles = 0;
      render.points = 0;
      render.lines = 0;
    }
    return {
      memory,
      render,
      programs: null,
      autoReset: true,
      reset,
      update: update2
    };
  }
  function numericalSort(a, b) {
    return a[0] - b[0];
  }
  function absNumericalSort(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
  }
  function WebGLMorphtargets(gl) {
    const influencesList = {};
    const morphInfluences = new Float32Array(8);
    const workInfluences = [];
    for (let i = 0; i < 8; i++) {
      workInfluences[i] = [i, 0];
    }
    function update2(object, geometry, material, program) {
      const objectInfluences = object.morphTargetInfluences;
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0) {
        influences = [];
        for (let i = 0; i < length; i++) {
          influences[i] = [i, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i = 0; i < length; i++) {
        const influence = influences[i];
        influence[0] = i;
        influence[1] = objectInfluences[i];
      }
      influences.sort(absNumericalSort);
      for (let i = 0; i < 8; i++) {
        if (i < length && influences[i][1]) {
          workInfluences[i][0] = influences[i][0];
          workInfluences[i][1] = influences[i][1];
        } else {
          workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = material.morphTargets && geometry.morphAttributes.position;
      const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i = 0; i < 8; i++) {
        const influence = workInfluences[i];
        const index = influence[0];
        const value = influence[1];
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index]) {
            geometry.setAttribute("morphTarget" + i, morphTargets[index]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index]) {
            geometry.setAttribute("morphNormal" + i, morphNormals[index]);
          }
          morphInfluences[i] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i) === true) {
            geometry.deleteAttribute("morphTarget" + i);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i) === true) {
            geometry.deleteAttribute("morphNormal" + i);
          }
          morphInfluences[i] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
    return {
      update: update2
    };
  }
  function WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = new WeakMap();
    function update2(object) {
      const frame = info.render.frame;
      const geometry = object.geometry;
      const buffergeometry = geometries.get(object, geometry);
      if (updateMap.get(buffergeometry) !== frame) {
        if (geometry.isGeometry) {
          buffergeometry.updateFromObject(object);
        }
        geometries.update(buffergeometry);
        updateMap.set(buffergeometry, frame);
      }
      if (object.isInstancedMesh) {
        attributes.update(object.instanceMatrix, 34962);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, 34962);
        }
      }
      return buffergeometry;
    }
    function dispose() {
      updateMap = new WeakMap();
    }
    return {
      update: update2,
      dispose
    };
  }
  function DataTexture2DArray(data = null, width = 1, height = 1, depth = 1) {
    Texture.call(this, null);
    this.image = {data, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
  DataTexture2DArray.prototype = Object.create(Texture.prototype);
  DataTexture2DArray.prototype.constructor = DataTexture2DArray;
  DataTexture2DArray.prototype.isDataTexture2DArray = true;
  function DataTexture3D(data = null, width = 1, height = 1, depth = 1) {
    Texture.call(this, null);
    this.image = {data, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
  DataTexture3D.prototype = Object.create(Texture.prototype);
  DataTexture3D.prototype.constructor = DataTexture3D;
  DataTexture3D.prototype.isDataTexture3D = true;
  var emptyTexture = new Texture();
  var emptyTexture2dArray = new DataTexture2DArray();
  var emptyTexture3d = new DataTexture3D();
  var emptyCubeTexture = new CubeTexture();
  var arrayCacheF32 = [];
  var arrayCacheI32 = [];
  var mat4array = new Float32Array(16);
  var mat3array = new Float32Array(9);
  var mat2array = new Float32Array(4);
  function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0)
      return array;
    const n = nBlocks * blockSize;
    let r = arrayCacheF32[n];
    if (r === void 0) {
      r = new Float32Array(n);
      arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
      firstElem.toArray(r, 0);
      for (let i = 1, offset = 0; i !== nBlocks; ++i) {
        offset += blockSize;
        array[i].toArray(r, offset);
      }
    }
    return r;
  }
  function arraysEqual(a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0, l = a.length; i < l; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  function copyArray(a, b) {
    for (let i = 0, l = b.length; i < l; i++) {
      a[i] = b[i];
    }
  }
  function allocTexUnits(textures, n) {
    let r = arrayCacheI32[n];
    if (r === void 0) {
      r = new Int32Array(n);
      arrayCacheI32[n] = r;
    }
    for (let i = 0; i !== n; ++i) {
      r[i] = textures.allocateTextureUnit();
    }
    return r;
  }
  function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
  }
  function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2f(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform2fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3f(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else if (v.r !== void 0) {
      if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
        gl.uniform3f(this.addr, v.r, v.g, v.b);
        cache[0] = v.r;
        cache[1] = v.g;
        cache[2] = v.b;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform3fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform4fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix2fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat2array.set(elements);
      gl.uniformMatrix2fv(this.addr, false, mat2array);
      copyArray(cache, elements);
    }
  }
  function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix3fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat3array.set(elements);
      gl.uniformMatrix3fv(this.addr, false, mat3array);
      copyArray(cache, elements);
    }
  }
  function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix4fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat4array.set(elements);
      gl.uniformMatrix4fv(this.addr, false, mat4array);
      copyArray(cache, elements);
    }
  }
  function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.safeSetTexture2D(v || emptyTexture, unit);
  }
  function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyTexture2dArray, unit);
  }
  function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture3D(v || emptyTexture3d, unit);
  }
  function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.safeSetTextureCube(v || emptyCubeTexture, unit);
  }
  function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
  }
  function setValueV2i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV3i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV4i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
  }
  function getSingularSetter(type) {
    switch (type) {
      case 5126:
        return setValueV1f;
      case 35664:
        return setValueV2f;
      case 35665:
        return setValueV3f;
      case 35666:
        return setValueV4f;
      case 35674:
        return setValueM2;
      case 35675:
        return setValueM3;
      case 35676:
        return setValueM4;
      case 5124:
      case 35670:
        return setValueV1i;
      case 35667:
      case 35671:
        return setValueV2i;
      case 35668:
      case 35672:
        return setValueV3i;
      case 35669:
      case 35673:
        return setValueV4i;
      case 5125:
        return setValueV1ui;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3D1;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArray1;
    }
  }
  function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
  }
  function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
  }
  function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
  }
  function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
  }
  function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
  }
  function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
  }
  function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
  }
  function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
  }
  function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
  }
  function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
  }
  function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
  }
  function setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i = 0; i !== n; ++i) {
      textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
    }
  }
  function setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i = 0; i !== n; ++i) {
      textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
  }
  function getPureArraySetter(type) {
    switch (type) {
      case 5126:
        return setValueV1fArray;
      case 35664:
        return setValueV2fArray;
      case 35665:
        return setValueV3fArray;
      case 35666:
        return setValueV4fArray;
      case 35674:
        return setValueM2Array;
      case 35675:
        return setValueM3Array;
      case 35676:
        return setValueM4Array;
      case 5124:
      case 35670:
        return setValueV1iArray;
      case 35667:
      case 35671:
        return setValueV2iArray;
      case 35668:
      case 35672:
        return setValueV3iArray;
      case 35669:
      case 35673:
        return setValueV4iArray;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1Array;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6Array;
    }
  }
  function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
  }
  function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
  PureArrayUniform.prototype.updateCache = function(data) {
    const cache = this.cache;
    if (data instanceof Float32Array && cache.length !== data.length) {
      this.cache = new Float32Array(data.length);
    }
    copyArray(cache, data);
  };
  function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  StructuredUniform.prototype.setValue = function(gl, value, textures) {
    const seq = this.seq;
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      u.setValue(gl, value[u.id], textures);
    }
  };
  var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
  function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
  }
  function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while (true) {
      const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
      let id = match[1];
      const idIsIndex = match[2] === "]", subscript = match[3];
      if (idIsIndex)
        id = id | 0;
      if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
        break;
      } else {
        const map = container.map;
        let next = map[id];
        if (next === void 0) {
          next = new StructuredUniform(id);
          addUniform(container, next);
        }
        container = next;
      }
    }
  }
  function WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, 35718);
    for (let i = 0; i < n; ++i) {
      const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== void 0)
      u.setValue(gl, value, textures);
  };
  WebGLUniforms.prototype.setOptional = function(gl, object, name) {
    const v = object[name];
    if (v !== void 0)
      this.setValue(gl, name, v);
  };
  WebGLUniforms.upload = function(gl, seq, values, textures) {
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i], v = values[u.id];
      if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, textures);
      }
    }
  };
  WebGLUniforms.seqWithValue = function(seq, values) {
    const r = [];
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      if (u.id in values)
        r.push(u);
    }
    return r;
  };
  function WebGLShader(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
  }
  var programIdCount = 0;
  function addLineNumbers(string) {
    const lines = string.split("\n");
    for (let i = 0; i < lines.length; i++) {
      lines[i] = i + 1 + ": " + lines[i];
    }
    return lines.join("\n");
  }
  function getEncodingComponents(encoding) {
    switch (encoding) {
      case LinearEncoding:
        return ["Linear", "( value )"];
      case sRGBEncoding:
        return ["sRGB", "( value )"];
      case RGBEEncoding:
        return ["RGBE", "( value )"];
      case RGBM7Encoding:
        return ["RGBM", "( value, 7.0 )"];
      case RGBM16Encoding:
        return ["RGBM", "( value, 16.0 )"];
      case RGBDEncoding:
        return ["RGBD", "( value, 256.0 )"];
      case GammaEncoding:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      case LogLuvEncoding:
        return ["LogLuv", "( value )"];
      default:
        console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
        return ["Linear", "( value )"];
    }
  }
  function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, 35713);
    const log = gl.getShaderInfoLog(shader).trim();
    if (status && log === "")
      return "";
    const source = gl.getShaderSource(shader);
    return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
  }
  function getTexelDecodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
  }
  function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
  }
  function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch (toneMapping) {
      case LinearToneMapping:
        toneMappingName = "Linear";
        break;
      case ReinhardToneMapping:
        toneMappingName = "Reinhard";
        break;
      case CineonToneMapping:
        toneMappingName = "OptimizedCineon";
        break;
      case ACESFilmicToneMapping:
        toneMappingName = "ACESFilmic";
        break;
      case CustomToneMapping:
        toneMappingName = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
        toneMappingName = "Linear";
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
  }
  function generateExtensions(parameters) {
    const chunks = [
      parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
      (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
      parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ];
    return chunks.filter(filterEmptyLine).join("\n");
  }
  function generateDefines(defines) {
    const chunks = [];
    for (const name in defines) {
      const value = defines[name];
      if (value === false)
        continue;
      chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
  }
  function fetchAttributeLocations(gl, program) {
    const attributes = {};
    const n = gl.getProgramParameter(program, 35721);
    for (let i = 0; i < n; i++) {
      const info = gl.getActiveAttrib(program, i);
      const name = info.name;
      attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
  }
  function filterEmptyLine(string) {
    return string !== "";
  }
  function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
  }
  function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
  }
  var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
  }
  function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === void 0) {
      throw new Error("Can not resolve #include <" + include + ">");
    }
    return resolveIncludes(string);
  }
  var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
  }
  function deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
    return loopReplacer(match, start, end, snippet);
  }
  function loopReplacer(match, start, end, snippet) {
    let string = "";
    for (let i = parseInt(start); i < parseInt(end); i++) {
      string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
    }
    return string;
  }
  function generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") {
      precisionstring += "\n#define HIGH_PRECISION";
    } else if (parameters.precision === "mediump") {
      precisionstring += "\n#define MEDIUM_PRECISION";
    } else if (parameters.precision === "lowp") {
      precisionstring += "\n#define LOW_PRECISION";
    }
    return precisionstring;
  }
  function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === PCFShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    } else if (parameters.shadowMapType === VSMShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
    }
    return shadowMapTypeDefine;
  }
  function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE";
          break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
          break;
      }
    }
    return envMapTypeDefine;
  }
  function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeRefractionMapping:
        case CubeUVRefractionMapping:
          envMapModeDefine = "ENVMAP_MODE_REFRACTION";
          break;
      }
    }
    return envMapModeDefine;
  }
  function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
    if (parameters.envMap) {
      switch (parameters.combine) {
        case MultiplyOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case MixOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
          break;
        case AddOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
          break;
      }
    }
    return envMapBlendingDefine;
  }
  function WebGLProgram(renderer3, cacheKey, parameters, bindingStates) {
    const gl = renderer3.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const gammaFactorDefine = renderer3.gammaFactor > 0 ? renderer3.gammaFactor : 1;
    const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
    if (parameters.isRawShaderMaterial) {
      prefixVertex = [
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixVertex.length > 0) {
        prefixVertex += "\n";
      }
      prefixFragment = [
        customExtensions,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixFragment.length > 0) {
        prefixFragment += "\n";
      }
    } else {
      prefixVertex = [
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.instancing ? "#define USE_INSTANCING" : "",
        parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        "#define GAMMA_FACTOR " + gammaFactorDefine,
        "#define MAX_BONES " + parameters.maxBones,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.skinning ? "#define USE_SKINNING" : "",
        parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
        parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
        parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#ifdef USE_COLOR",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_MORPHTARGETS",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n"
      ].filter(filterEmptyLine).join("\n");
      prefixFragment = [
        customExtensions,
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
        "#define GAMMA_FACTOR " + gammaFactorDefine,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.matcap ? "#define USE_MATCAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapTypeDefine : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.envMap ? "#define " + envMapBlendingDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.sheen ? "#define USE_SHEEN" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
        parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
        parameters.dithering ? "#define DITHERING" : "",
        ShaderChunk["encodings_pars_fragment"],
        parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
        parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
        parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
        parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
        parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
        getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
        parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
        "\n"
      ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
      versionString = "#version 300 es\n";
      prefixVertex = [
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
      ].join("\n") + "\n" + prefixVertex;
      prefixFragment = [
        "#define varying in",
        parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
        parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
      ].join("\n") + "\n" + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
    const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    if (parameters.index0AttributeName !== void 0) {
      gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      gl.bindAttribLocation(program, 0, "position");
    }
    gl.linkProgram(program);
    if (renderer3.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, 35714) === false) {
        runnable = false;
        const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
        const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
        console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        this.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    let cachedUniforms;
    this.getUniforms = function() {
      if (cachedUniforms === void 0) {
        cachedUniforms = new WebGLUniforms(gl, program);
      }
      return cachedUniforms;
    };
    let cachedAttributes;
    this.getAttributes = function() {
      if (cachedAttributes === void 0) {
        cachedAttributes = fetchAttributeLocations(gl, program);
      }
      return cachedAttributes;
    };
    this.destroy = function() {
      bindingStates.releaseStatesOfProgram(this);
      gl.deleteProgram(program);
      this.program = void 0;
    };
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
  }
  function WebGLPrograms(renderer3, cubemaps, extensions, capabilities, bindingStates, clipping) {
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const floatVertexTextures = capabilities.floatVertexTextures;
    const maxVertexUniforms = capabilities.maxVertexUniforms;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    const parameterNames = [
      "precision",
      "isWebGL2",
      "supportsVertexTextures",
      "outputEncoding",
      "instancing",
      "instancingColor",
      "map",
      "mapEncoding",
      "matcap",
      "matcapEncoding",
      "envMap",
      "envMapMode",
      "envMapEncoding",
      "envMapCubeUV",
      "lightMap",
      "lightMapEncoding",
      "aoMap",
      "emissiveMap",
      "emissiveMapEncoding",
      "bumpMap",
      "normalMap",
      "objectSpaceNormalMap",
      "tangentSpaceNormalMap",
      "clearcoatMap",
      "clearcoatRoughnessMap",
      "clearcoatNormalMap",
      "displacementMap",
      "specularMap",
      "roughnessMap",
      "metalnessMap",
      "gradientMap",
      "alphaMap",
      "combine",
      "vertexColors",
      "vertexTangents",
      "vertexUvs",
      "uvsVertexOnly",
      "fog",
      "useFog",
      "fogExp2",
      "flatShading",
      "sizeAttenuation",
      "logarithmicDepthBuffer",
      "skinning",
      "maxBones",
      "useVertexTexture",
      "morphTargets",
      "morphNormals",
      "maxMorphTargets",
      "maxMorphNormals",
      "premultipliedAlpha",
      "numDirLights",
      "numPointLights",
      "numSpotLights",
      "numHemiLights",
      "numRectAreaLights",
      "numDirLightShadows",
      "numPointLightShadows",
      "numSpotLightShadows",
      "shadowMapEnabled",
      "shadowMapType",
      "toneMapping",
      "physicallyCorrectLights",
      "alphaTest",
      "doubleSided",
      "flipSided",
      "numClippingPlanes",
      "numClipIntersection",
      "depthPacking",
      "dithering",
      "sheen",
      "transmissionMap"
    ];
    function getMaxBones(object) {
      const skeleton = object.skeleton;
      const bones = skeleton.bones;
      if (floatVertexTextures) {
        return 1024;
      } else {
        const nVertexUniforms = maxVertexUniforms;
        const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
        const maxBones = Math.min(nVertexMatrices, bones.length);
        if (maxBones < bones.length) {
          console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
          return 0;
        }
        return maxBones;
      }
    }
    function getTextureEncodingFromMap(map) {
      let encoding;
      if (!map) {
        encoding = LinearEncoding;
      } else if (map.isTexture) {
        encoding = map.encoding;
      } else if (map.isWebGLRenderTarget) {
        console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
        encoding = map.texture.encoding;
      }
      return encoding;
    }
    function getParameters(material, lights, shadows, scene2, object) {
      const fog = scene2.fog;
      const environment = material.isMeshStandardMaterial ? scene2.environment : null;
      const envMap = cubemaps.get(material.envMap || environment);
      const shaderID = shaderIDs[material.type];
      const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
          console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
      }
      let vertexShader, fragmentShader;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        vertexShader = shader.vertexShader;
        fragmentShader = shader.fragmentShader;
      } else {
        vertexShader = material.vertexShader;
        fragmentShader = material.fragmentShader;
      }
      const currentRenderTarget = renderer3.getRenderTarget();
      const parameters = {
        isWebGL2,
        shaderID,
        shaderName: material.type,
        vertexShader,
        fragmentShader,
        defines: material.defines,
        isRawShaderMaterial: material.isRawShaderMaterial === true,
        glslVersion: material.glslVersion,
        precision,
        instancing: object.isInstancedMesh === true,
        instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
        supportsVertexTextures: vertexTextures,
        outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer3.outputEncoding,
        map: !!material.map,
        mapEncoding: getTextureEncodingFromMap(material.map),
        matcap: !!material.matcap,
        matcapEncoding: getTextureEncodingFromMap(material.matcap),
        envMap: !!envMap,
        envMapMode: envMap && envMap.mapping,
        envMapEncoding: getTextureEncodingFromMap(envMap),
        envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
        lightMap: !!material.lightMap,
        lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
        aoMap: !!material.aoMap,
        emissiveMap: !!material.emissiveMap,
        emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
        bumpMap: !!material.bumpMap,
        normalMap: !!material.normalMap,
        objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
        tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
        clearcoatMap: !!material.clearcoatMap,
        clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
        clearcoatNormalMap: !!material.clearcoatNormalMap,
        displacementMap: !!material.displacementMap,
        roughnessMap: !!material.roughnessMap,
        metalnessMap: !!material.metalnessMap,
        specularMap: !!material.specularMap,
        alphaMap: !!material.alphaMap,
        gradientMap: !!material.gradientMap,
        sheen: !!material.sheen,
        transmissionMap: !!material.transmissionMap,
        combine: material.combine,
        vertexTangents: material.normalMap && material.vertexTangents,
        vertexColors: material.vertexColors,
        vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
        uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
        fog: !!fog,
        useFog: material.fog,
        fogExp2: fog && fog.isFogExp2,
        flatShading: material.flatShading,
        sizeAttenuation: material.sizeAttenuation,
        logarithmicDepthBuffer,
        skinning: material.skinning && maxBones > 0,
        maxBones,
        useVertexTexture: floatVertexTextures,
        morphTargets: material.morphTargets,
        morphNormals: material.morphNormals,
        maxMorphTargets: renderer3.maxMorphTargets,
        maxMorphNormals: renderer3.maxMorphNormals,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,
        numDirLightShadows: lights.directionalShadowMap.length,
        numPointLightShadows: lights.pointShadowMap.length,
        numSpotLightShadows: lights.spotShadowMap.length,
        numClippingPlanes: clipping.numPlanes,
        numClipIntersection: clipping.numIntersection,
        dithering: material.dithering,
        shadowMapEnabled: renderer3.shadowMap.enabled && shadows.length > 0,
        shadowMapType: renderer3.shadowMap.type,
        toneMapping: material.toneMapped ? renderer3.toneMapping : NoToneMapping,
        physicallyCorrectLights: renderer3.physicallyCorrectLights,
        premultipliedAlpha: material.premultipliedAlpha,
        alphaTest: material.alphaTest,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
        index0AttributeName: material.index0AttributeName,
        extensionDerivatives: material.extensions && material.extensions.derivatives,
        extensionFragDepth: material.extensions && material.extensions.fragDepth,
        extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
        extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
        customProgramCacheKey: material.customProgramCacheKey()
      };
      return parameters;
    }
    function getProgramCacheKey(parameters) {
      const array = [];
      if (parameters.shaderID) {
        array.push(parameters.shaderID);
      } else {
        array.push(parameters.fragmentShader);
        array.push(parameters.vertexShader);
      }
      if (parameters.defines !== void 0) {
        for (const name in parameters.defines) {
          array.push(name);
          array.push(parameters.defines[name]);
        }
      }
      if (parameters.isRawShaderMaterial === false) {
        for (let i = 0; i < parameterNames.length; i++) {
          array.push(parameters[parameterNames[i]]);
        }
        array.push(renderer3.outputEncoding);
        array.push(renderer3.gammaFactor);
      }
      array.push(parameters.customProgramCacheKey);
      return array.join();
    }
    function getUniforms(material) {
      const shaderID = shaderIDs[material.type];
      let uniforms;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        uniforms = UniformsUtils.clone(shader.uniforms);
      } else {
        uniforms = material.uniforms;
      }
      return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
      let program;
      for (let p = 0, pl = programs.length; p < pl; p++) {
        const preexistingProgram = programs[p];
        if (preexistingProgram.cacheKey === cacheKey) {
          program = preexistingProgram;
          ++program.usedTimes;
          break;
        }
      }
      if (program === void 0) {
        program = new WebGLProgram(renderer3, cacheKey, parameters, bindingStates);
        programs.push(program);
      }
      return program;
    }
    function releaseProgram(program) {
      if (--program.usedTimes === 0) {
        const i = programs.indexOf(program);
        programs[i] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    }
    return {
      getParameters,
      getProgramCacheKey,
      getUniforms,
      acquireProgram,
      releaseProgram,
      programs
    };
  }
  function WebGLProperties() {
    let properties = new WeakMap();
    function get(object) {
      let map = properties.get(object);
      if (map === void 0) {
        map = {};
        properties.set(object, map);
      }
      return map;
    }
    function remove(object) {
      properties.delete(object);
    }
    function update2(object, key, value) {
      properties.get(object)[key] = value;
    }
    function dispose() {
      properties = new WeakMap();
    }
    return {
      get,
      remove,
      update: update2,
      dispose
    };
  }
  function painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.program !== b.program) {
      return a.program.id - b.program.id;
    } else if (a.material.id !== b.material.id) {
      return a.material.id - b.material.id;
    } else if (a.z !== b.z) {
      return a.z - b.z;
    } else {
      return a.id - b.id;
    }
  }
  function reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }
  function WebGLRenderList(properties) {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transparent = [];
    const defaultProgram = {id: -1};
    function init() {
      renderItemsIndex = 0;
      opaque.length = 0;
      transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z, group2) {
      let renderItem = renderItems[renderItemsIndex];
      const materialProperties = properties.get(material);
      if (renderItem === void 0) {
        renderItem = {
          id: object.id,
          object,
          geometry,
          material,
          program: materialProperties.program || defaultProgram,
          groupOrder,
          renderOrder: object.renderOrder,
          z,
          group: group2
        };
        renderItems[renderItemsIndex] = renderItem;
      } else {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.program = materialProperties.program || defaultProgram;
        renderItem.groupOrder = groupOrder;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z;
        renderItem.group = group2;
      }
      renderItemsIndex++;
      return renderItem;
    }
    function push(object, geometry, material, groupOrder, z, group2) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group2);
      (material.transparent === true ? transparent : opaque).push(renderItem);
    }
    function unshift(object, geometry, material, groupOrder, z, group2) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group2);
      (material.transparent === true ? transparent : opaque).unshift(renderItem);
    }
    function sort(customOpaqueSort, customTransparentSort) {
      if (opaque.length > 1)
        opaque.sort(customOpaqueSort || painterSortStable);
      if (transparent.length > 1)
        transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
      for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
        const renderItem = renderItems[i];
        if (renderItem.id === null)
          break;
        renderItem.id = null;
        renderItem.object = null;
        renderItem.geometry = null;
        renderItem.material = null;
        renderItem.program = null;
        renderItem.group = null;
      }
    }
    return {
      opaque,
      transparent,
      init,
      push,
      unshift,
      finish,
      sort
    };
  }
  function WebGLRenderLists(properties) {
    let lists = new WeakMap();
    function get(scene2, camera2) {
      const cameras = lists.get(scene2);
      let list;
      if (cameras === void 0) {
        list = new WebGLRenderList(properties);
        lists.set(scene2, new WeakMap());
        lists.get(scene2).set(camera2, list);
      } else {
        list = cameras.get(camera2);
        if (list === void 0) {
          list = new WebGLRenderList(properties);
          cameras.set(camera2, list);
        }
      }
      return list;
    }
    function dispose() {
      lists = new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function UniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              direction: new Vector3(),
              color: new Color()
            };
            break;
          case "SpotLight":
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;
          case "RectAreaLight":
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  function ShadowUniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "SpotLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "PointLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  var nextVersion = 0;
  function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
  }
  function WebGLLights(extensions, capabilities) {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    };
    for (let i = 0; i < 9; i++)
      state.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights, shadows, camera2) {
      let r = 0, g = 0, b = 0;
      for (let i = 0; i < 9; i++)
        state.probe[i].set(0, 0, 0);
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      let numDirectionalShadows = 0;
      let numPointShadows = 0;
      let numSpotShadows = 0;
      const viewMatrix = camera2.matrixWorldInverse;
      lights.sort(shadowCastingLightsFirst);
      for (let i = 0, l = lights.length; i < l; i++) {
        const light = lights[i];
        const color = light.color;
        const intensity = light.intensity;
        const distance = light.distance;
        const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
        if (light.isAmbientLight) {
          r += color.r * intensity;
          g += color.g * intensity;
          b += color.b * intensity;
        } else if (light.isLightProbe) {
          for (let j = 0; j < 9; j++) {
            state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
          }
        } else if (light.isDirectionalLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity);
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.directionalShadow[directionalLength] = shadowUniforms;
            state.directionalShadowMap[directionalLength] = shadowMap;
            state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
            numDirectionalShadows++;
          }
          state.directional[directionalLength] = uniforms;
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = cache.get(light);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.distance = distance;
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          uniforms.coneCos = Math.cos(light.angle);
          uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.spotShadow[spotLength] = shadowUniforms;
            state.spotShadowMap[spotLength] = shadowMap;
            state.spotShadowMatrix[spotLength] = light.shadow.matrix;
            numSpotShadows++;
          }
          state.spot[spotLength] = uniforms;
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          matrix42.identity();
          matrix4.copy(light.matrixWorld);
          matrix4.premultiply(viewMatrix);
          matrix42.extractRotation(matrix4);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          uniforms.halfWidth.applyMatrix4(matrix42);
          uniforms.halfHeight.applyMatrix4(matrix42);
          state.rectArea[rectAreaLength] = uniforms;
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = cache.get(light);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity);
          uniforms.distance = light.distance;
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            shadowUniforms.shadowCameraNear = shadow.camera.near;
            shadowUniforms.shadowCameraFar = shadow.camera.far;
            state.pointShadow[pointLength] = shadowUniforms;
            state.pointShadowMap[pointLength] = shadowMap;
            state.pointShadowMatrix[pointLength] = light.shadow.matrix;
            numPointShadows++;
          }
          state.point[pointLength] = uniforms;
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = cache.get(light);
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          uniforms.direction.transformDirection(viewMatrix);
          uniforms.direction.normalize();
          uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
          uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
          state.hemi[hemiLength] = uniforms;
          hemiLength++;
        }
      }
      if (rectAreaLength > 0) {
        if (capabilities.isWebGL2) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else {
          if (extensions.has("OES_texture_float_linear") === true) {
            state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
            state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
          } else if (extensions.has("OES_texture_half_float_linear") === true) {
            state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
            state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
          } else {
            console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
          }
        }
      }
      state.ambient[0] = r;
      state.ambient[1] = g;
      state.ambient[2] = b;
      const hash = state.hash;
      if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
        state.directional.length = directionalLength;
        state.spot.length = spotLength;
        state.rectArea.length = rectAreaLength;
        state.point.length = pointLength;
        state.hemi.length = hemiLength;
        state.directionalShadow.length = numDirectionalShadows;
        state.directionalShadowMap.length = numDirectionalShadows;
        state.pointShadow.length = numPointShadows;
        state.pointShadowMap.length = numPointShadows;
        state.spotShadow.length = numSpotShadows;
        state.spotShadowMap.length = numSpotShadows;
        state.directionalShadowMatrix.length = numDirectionalShadows;
        state.pointShadowMatrix.length = numPointShadows;
        state.spotShadowMatrix.length = numSpotShadows;
        hash.directionalLength = directionalLength;
        hash.pointLength = pointLength;
        hash.spotLength = spotLength;
        hash.rectAreaLength = rectAreaLength;
        hash.hemiLength = hemiLength;
        hash.numDirectionalShadows = numDirectionalShadows;
        hash.numPointShadows = numPointShadows;
        hash.numSpotShadows = numSpotShadows;
        state.version = nextVersion++;
      }
    }
    return {
      setup,
      state
    };
  }
  function WebGLRenderState(extensions, capabilities) {
    const lights = new WebGLLights(extensions, capabilities);
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }
    function pushLight(light) {
      lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
      shadowsArray.push(shadowLight);
    }
    function setupLights(camera2) {
      lights.setup(lightsArray, shadowsArray, camera2);
    }
    const state = {
      lightsArray,
      shadowsArray,
      lights
    };
    return {
      init,
      state,
      setupLights,
      pushLight,
      pushShadow
    };
  }
  function WebGLRenderStates(extensions, capabilities) {
    let renderStates = new WeakMap();
    function get(scene2, camera2) {
      let renderState;
      if (renderStates.has(scene2) === false) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.set(scene2, new WeakMap());
        renderStates.get(scene2).set(camera2, renderState);
      } else {
        if (renderStates.get(scene2).has(camera2) === false) {
          renderState = new WebGLRenderState(extensions, capabilities);
          renderStates.get(scene2).set(camera2, renderState);
        } else {
          renderState = renderStates.get(scene2).get(camera2);
        }
      }
      return renderState;
    }
    function dispose() {
      renderStates = new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function MeshDepthMaterial(parameters) {
    Material.call(this);
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  MeshDepthMaterial.prototype = Object.create(Material.prototype);
  MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
  MeshDepthMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  };
  function MeshDistanceMaterial(parameters) {
    Material.call(this);
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  MeshDistanceMaterial.prototype = Object.create(Material.prototype);
  MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
  MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
  MeshDistanceMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  };
  var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
  var vsm_vert = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
  function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {};
    const shadowSide = {0: BackSide, 1: FrontSide, 2: DoubleSide};
    const shadowMaterialVertical = new ShaderMaterial({
      defines: {
        SAMPLE_RATE: 2 / 8,
        HALF_SAMPLE_RATE: 1 / 8
      },
      uniforms: {
        shadow_pass: {value: null},
        resolution: {value: new Vector2()},
        radius: {value: 4}
      },
      vertexShader: vsm_vert,
      fragmentShader: vsm_frag
    });
    const shadowMaterialHorizonal = shadowMaterialVertical.clone();
    shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene2, camera2) {
      if (scope.enabled === false)
        return;
      if (scope.autoUpdate === false && scope.needsUpdate === false)
        return;
      if (lights.length === 0)
        return;
      const currentRenderTarget = _renderer.getRenderTarget();
      const activeCubeFace = _renderer.getActiveCubeFace();
      const activeMipmapLevel = _renderer.getActiveMipmapLevel();
      const _state = _renderer.state;
      _state.setBlending(NoBlending);
      _state.buffers.color.setClear(1, 1, 1, 1);
      _state.buffers.depth.setTest(true);
      _state.setScissorTest(false);
      for (let i = 0, il = lights.length; i < il; i++) {
        const light = lights[i];
        const shadow = light.shadow;
        if (shadow === void 0) {
          console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
          continue;
        }
        if (shadow.autoUpdate === false && shadow.needsUpdate === false)
          continue;
        _shadowMapSize.copy(shadow.mapSize);
        const shadowFrameExtents = shadow.getFrameExtents();
        _shadowMapSize.multiply(shadowFrameExtents);
        _viewportSize.copy(shadow.mapSize);
        if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
          if (_shadowMapSize.x > maxTextureSize) {
            _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
            _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
            shadow.mapSize.x = _viewportSize.x;
          }
          if (_shadowMapSize.y > maxTextureSize) {
            _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
            _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
            shadow.mapSize.y = _viewportSize.y;
          }
        }
        if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
          const pars = {minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat};
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.camera.updateProjectionMatrix();
        }
        if (shadow.map === null) {
          const pars = {minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat};
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.camera.updateProjectionMatrix();
        }
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        const viewportCount = shadow.getViewportCount();
        for (let vp = 0; vp < viewportCount; vp++) {
          const viewport = shadow.getViewport(vp);
          _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
          _state.viewport(_viewport);
          shadow.updateMatrices(light, vp);
          _frustum = shadow.getFrustum();
          renderObject(scene2, camera2, shadow.camera, light, this.type);
        }
        if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
          VSMPass(shadow, camera2);
        }
        shadow.needsUpdate = false;
      }
      scope.needsUpdate = false;
      _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera2) {
      const geometry = _objects.update(fullScreenMesh);
      shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
      shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialVertical.uniforms.radius.value = shadow.radius;
      _renderer.setRenderTarget(shadow.mapPass);
      _renderer.clear();
      _renderer.renderBufferDirect(camera2, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
      shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
      shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      _renderer.renderBufferDirect(camera2, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
    }
    function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
      const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
      let material = _depthMaterials[index];
      if (material === void 0) {
        material = new MeshDepthMaterial({
          depthPacking: RGBADepthPacking,
          morphTargets: useMorphing,
          skinning: useSkinning
        });
        _depthMaterials[index] = material;
      }
      return material;
    }
    function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
      const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
      let material = _distanceMaterials[index];
      if (material === void 0) {
        material = new MeshDistanceMaterial({
          morphTargets: useMorphing,
          skinning: useSkinning
        });
        _distanceMaterials[index] = material;
      }
      return material;
    }
    function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
      let result = null;
      let getMaterialVariant = getDepthMaterialVariant;
      let customMaterial = object.customDepthMaterial;
      if (light.isPointLight === true) {
        getMaterialVariant = getDistanceMaterialVariant;
        customMaterial = object.customDistanceMaterial;
      }
      if (customMaterial === void 0) {
        let useMorphing = false;
        if (material.morphTargets === true) {
          useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
        }
        let useSkinning = false;
        if (object.isSkinnedMesh === true) {
          if (material.skinning === true) {
            useSkinning = true;
          } else {
            console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
          }
        }
        const useInstancing = object.isInstancedMesh === true;
        result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
      } else {
        result = customMaterial;
      }
      if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
        }
        result = cachedMaterial;
      }
      result.visible = material.visible;
      result.wireframe = material.wireframe;
      if (type === VSMShadowMap) {
        result.side = material.shadowSide !== null ? material.shadowSide : material.side;
      } else {
        result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
      }
      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;
      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;
      if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
        result.referencePosition.setFromMatrixPosition(light.matrixWorld);
        result.nearDistance = shadowCameraNear;
        result.farDistance = shadowCameraFar;
      }
      return result;
    }
    function renderObject(object, camera2, shadowCamera, light, type) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera2.layers);
      if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          const geometry = _objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let k = 0, kl = groups.length; k < kl; k++) {
              const group2 = groups[k];
              const groupMaterial = material[group2.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group2);
              }
            }
          } else if (material.visible) {
            const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        renderObject(children[i], camera2, shadowCamera, light, type);
      }
    }
  }
  function WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
      let locked = false;
      const color = new Vector4();
      let currentColorMask = null;
      const currentColorClear = new Vector4(0, 0, 0, 0);
      return {
        setMask: function(colorMask) {
          if (currentColorMask !== colorMask && !locked) {
            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
            currentColorMask = colorMask;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(r, g, b, a, premultipliedAlpha) {
          if (premultipliedAlpha === true) {
            r *= a;
            g *= a;
            b *= a;
          }
          color.set(r, g, b, a);
          if (currentColorClear.equals(color) === false) {
            gl.clearColor(r, g, b, a);
            currentColorClear.copy(color);
          }
        },
        reset: function() {
          locked = false;
          currentColorMask = null;
          currentColorClear.set(-1, 0, 0, 0);
        }
      };
    }
    function DepthBuffer() {
      let locked = false;
      let currentDepthMask = null;
      let currentDepthFunc = null;
      let currentDepthClear = null;
      return {
        setTest: function(depthTest) {
          if (depthTest) {
            enable(2929);
          } else {
            disable(2929);
          }
        },
        setMask: function(depthMask) {
          if (currentDepthMask !== depthMask && !locked) {
            gl.depthMask(depthMask);
            currentDepthMask = depthMask;
          }
        },
        setFunc: function(depthFunc) {
          if (currentDepthFunc !== depthFunc) {
            if (depthFunc) {
              switch (depthFunc) {
                case NeverDepth:
                  gl.depthFunc(512);
                  break;
                case AlwaysDepth:
                  gl.depthFunc(519);
                  break;
                case LessDepth:
                  gl.depthFunc(513);
                  break;
                case LessEqualDepth:
                  gl.depthFunc(515);
                  break;
                case EqualDepth:
                  gl.depthFunc(514);
                  break;
                case GreaterEqualDepth:
                  gl.depthFunc(518);
                  break;
                case GreaterDepth:
                  gl.depthFunc(516);
                  break;
                case NotEqualDepth:
                  gl.depthFunc(517);
                  break;
                default:
                  gl.depthFunc(515);
              }
            } else {
              gl.depthFunc(515);
            }
            currentDepthFunc = depthFunc;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(depth) {
          if (currentDepthClear !== depth) {
            gl.clearDepth(depth);
            currentDepthClear = depth;
          }
        },
        reset: function() {
          locked = false;
          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;
        }
      };
    }
    function StencilBuffer() {
      let locked = false;
      let currentStencilMask = null;
      let currentStencilFunc = null;
      let currentStencilRef = null;
      let currentStencilFuncMask = null;
      let currentStencilFail = null;
      let currentStencilZFail = null;
      let currentStencilZPass = null;
      let currentStencilClear = null;
      return {
        setTest: function(stencilTest) {
          if (!locked) {
            if (stencilTest) {
              enable(2960);
            } else {
              disable(2960);
            }
          }
        },
        setMask: function(stencilMask) {
          if (currentStencilMask !== stencilMask && !locked) {
            gl.stencilMask(stencilMask);
            currentStencilMask = stencilMask;
          }
        },
        setFunc: function(stencilFunc, stencilRef, stencilMask) {
          if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;
          }
        },
        setOp: function(stencilFail, stencilZFail, stencilZPass) {
          if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(stencil) {
          if (currentStencilClear !== stencil) {
            gl.clearStencil(stencil);
            currentStencilClear = stencil;
          }
        },
        reset: function() {
          locked = false;
          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;
        }
      };
    }
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {};
    let currentProgram = null;
    let currentBlendingEnabled = null;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(35661);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(7938);
    if (glVersion.indexOf("WebGL") !== -1) {
      version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
      version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const currentScissor = new Vector4();
    const currentViewport = new Vector4();
    function createTexture(type, target, count) {
      const data = new Uint8Array(4);
      const texture = gl.createTexture();
      gl.bindTexture(type, texture);
      gl.texParameteri(type, 10241, 9728);
      gl.texParameteri(type, 10240, 9728);
      for (let i = 0; i < count; i++) {
        gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
      }
      return texture;
    }
    const emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);
    function enable(id) {
      if (enabledCapabilities[id] !== true) {
        gl.enable(id);
        enabledCapabilities[id] = true;
      }
    }
    function disable(id) {
      if (enabledCapabilities[id] !== false) {
        gl.disable(id);
        enabledCapabilities[id] = false;
      }
    }
    function useProgram(program) {
      if (currentProgram !== program) {
        gl.useProgram(program);
        currentProgram = program;
        return true;
      }
      return false;
    }
    const equationToGL = {
      [AddEquation]: 32774,
      [SubtractEquation]: 32778,
      [ReverseSubtractEquation]: 32779
    };
    if (isWebGL2) {
      equationToGL[MinEquation] = 32775;
      equationToGL[MaxEquation] = 32776;
    } else {
      const extension = extensions.get("EXT_blend_minmax");
      if (extension !== null) {
        equationToGL[MinEquation] = extension.MIN_EXT;
        equationToGL[MaxEquation] = extension.MAX_EXT;
      }
    }
    const factorToGL = {
      [ZeroFactor]: 0,
      [OneFactor]: 1,
      [SrcColorFactor]: 768,
      [SrcAlphaFactor]: 770,
      [SrcAlphaSaturateFactor]: 776,
      [DstColorFactor]: 774,
      [DstAlphaFactor]: 772,
      [OneMinusSrcColorFactor]: 769,
      [OneMinusSrcAlphaFactor]: 771,
      [OneMinusDstColorFactor]: 775,
      [OneMinusDstAlphaFactor]: 773
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
      if (blending === NoBlending) {
        if (currentBlendingEnabled) {
          disable(3042);
          currentBlendingEnabled = false;
        }
        return;
      }
      if (!currentBlendingEnabled) {
        enable(3042);
        currentBlendingEnabled = true;
      }
      if (blending !== CustomBlending) {
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
          if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
            gl.blendEquation(32774);
            currentBlendEquation = AddEquation;
            currentBlendEquationAlpha = AddEquation;
          }
          if (premultipliedAlpha) {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(1, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(1, 1);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 0, 769, 771);
                break;
              case MultiplyBlending:
                gl.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          } else {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(770, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(770, 1);
                break;
              case SubtractiveBlending:
                gl.blendFunc(0, 769);
                break;
              case MultiplyBlending:
                gl.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          }
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentBlending = blending;
          currentPremultipledAlpha = premultipliedAlpha;
        }
        return;
      }
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
      currentBlending = blending;
      currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
      material.side === DoubleSide ? disable(2884) : enable(2884);
      let flipSided = material.side === BackSide;
      if (frontFaceCW)
        flipSided = !flipSided;
      setFlipSided(flipSided);
      material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
      depthBuffer.setFunc(material.depthFunc);
      depthBuffer.setTest(material.depthTest);
      depthBuffer.setMask(material.depthWrite);
      colorBuffer.setMask(material.colorWrite);
      const stencilWrite = material.stencilWrite;
      stencilBuffer.setTest(stencilWrite);
      if (stencilWrite) {
        stencilBuffer.setMask(material.stencilWriteMask);
        stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
        stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
      }
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    }
    function setFlipSided(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl.frontFace(2304);
        } else {
          gl.frontFace(2305);
        }
        currentFlipSided = flipSided;
      }
    }
    function setCullFace(cullFace) {
      if (cullFace !== CullFaceNone) {
        enable(2884);
        if (cullFace !== currentCullFace) {
          if (cullFace === CullFaceBack) {
            gl.cullFace(1029);
          } else if (cullFace === CullFaceFront) {
            gl.cullFace(1028);
          } else {
            gl.cullFace(1032);
          }
        }
      } else {
        disable(2884);
      }
      currentCullFace = cullFace;
    }
    function setLineWidth(width) {
      if (width !== currentLineWidth) {
        if (lineWidthAvailable)
          gl.lineWidth(width);
        currentLineWidth = width;
      }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        enable(32823);
        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      } else {
        disable(32823);
      }
    }
    function setScissorTest(scissorTest) {
      if (scissorTest) {
        enable(3089);
      } else {
        disable(3089);
      }
    }
    function activeTexture(webglSlot) {
      if (webglSlot === void 0)
        webglSlot = 33984 + maxTextures - 1;
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    }
    function bindTexture(webglType, webglTexture) {
      if (currentTextureSlot === null) {
        activeTexture();
      }
      let boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture === void 0) {
        boundTexture = {type: void 0, texture: void 0};
        currentBoundTextures[currentTextureSlot] = boundTexture;
      }
      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    }
    function unbindTexture() {
      const boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture !== void 0 && boundTexture.type !== void 0) {
        gl.bindTexture(boundTexture.type, null);
        boundTexture.type = void 0;
        boundTexture.texture = void 0;
      }
    }
    function compressedTexImage2D() {
      try {
        gl.compressedTexImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage2D() {
      try {
        gl.texImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage3D() {
      try {
        gl.texImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function scissor(scissor2) {
      if (currentScissor.equals(scissor2) === false) {
        gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
        currentScissor.copy(scissor2);
      }
    }
    function viewport(viewport2) {
      if (currentViewport.equals(viewport2) === false) {
        gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
        currentViewport.copy(viewport2);
      }
    }
    function reset() {
      enabledCapabilities = {};
      currentTextureSlot = null;
      currentBoundTextures = {};
      currentProgram = null;
      currentBlendingEnabled = null;
      currentBlending = null;
      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;
      currentPremultipledAlpha = false;
      currentFlipSided = null;
      currentCullFace = null;
      currentLineWidth = null;
      currentPolygonOffsetFactor = null;
      currentPolygonOffsetUnits = null;
      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();
    }
    return {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      enable,
      disable,
      useProgram,
      setBlending,
      setMaterial,
      setFlipSided,
      setCullFace,
      setLineWidth,
      setPolygonOffset,
      setScissorTest,
      activeTexture,
      bindTexture,
      unbindTexture,
      compressedTexImage2D,
      texImage2D,
      texImage3D,
      scissor,
      viewport,
      reset
    };
  }
  function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const _videoTextures = new WeakMap();
    let _canvas2;
    let useOffscreenCanvas = false;
    try {
      useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    }
    function createCanvas(width, height) {
      return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
      let scale = 1;
      if (image.width > maxSize || image.height > maxSize) {
        scale = maxSize / Math.max(image.width, image.height);
      }
      if (scale < 1 || needsPowerOfTwo === true) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
          const width = floor(scale * image.width);
          const height = floor(scale * image.height);
          if (_canvas2 === void 0)
            _canvas2 = createCanvas(width, height);
          const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
          canvas.width = width;
          canvas.height = height;
          const context = canvas.getContext("2d");
          context.drawImage(image, 0, 0, width, height);
          console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
          return canvas;
        } else {
          if ("data" in image) {
            console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
          }
          return image;
        }
      }
      return image;
    }
    function isPowerOfTwo(image) {
      return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
      if (isWebGL2)
        return false;
      return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
      return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target, texture, width, height) {
      _gl.generateMipmap(target);
      const textureProperties = properties.get(texture);
      textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
    }
    function getInternalFormat(internalFormatName, glFormat, glType) {
      if (isWebGL2 === false)
        return glFormat;
      if (internalFormatName !== null) {
        if (_gl[internalFormatName] !== void 0)
          return _gl[internalFormatName];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
      }
      let internalFormat = glFormat;
      if (glFormat === 6403) {
        if (glType === 5126)
          internalFormat = 33326;
        if (glType === 5131)
          internalFormat = 33325;
        if (glType === 5121)
          internalFormat = 33321;
      }
      if (glFormat === 6407) {
        if (glType === 5126)
          internalFormat = 34837;
        if (glType === 5131)
          internalFormat = 34843;
        if (glType === 5121)
          internalFormat = 32849;
      }
      if (glFormat === 6408) {
        if (glType === 5126)
          internalFormat = 34836;
        if (glType === 5131)
          internalFormat = 34842;
        if (glType === 5121)
          internalFormat = 32856;
      }
      if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
        extensions.get("EXT_color_buffer_float");
      }
      return internalFormat;
    }
    function filterFallback(f) {
      if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
        return 9728;
      }
      return 9729;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      deallocateTexture(texture);
      if (texture.isVideoTexture) {
        _videoTextures.delete(texture);
      }
      info.memory.textures--;
    }
    function onRenderTargetDispose(event) {
      const renderTarget = event.target;
      renderTarget.removeEventListener("dispose", onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
      info.memory.textures--;
    }
    function deallocateTexture(texture) {
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglInit === void 0)
        return;
      _gl.deleteTexture(textureProperties.__webglTexture);
      properties.remove(texture);
    }
    function deallocateRenderTarget(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(renderTarget.texture);
      if (!renderTarget)
        return;
      if (textureProperties.__webglTexture !== void 0) {
        _gl.deleteTexture(textureProperties.__webglTexture);
      }
      if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
      }
      if (renderTarget.isWebGLCubeRenderTarget) {
        for (let i = 0; i < 6; i++) {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
        }
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        if (renderTargetProperties.__webglMultisampledFramebuffer)
          _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
        if (renderTargetProperties.__webglColorRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
        if (renderTargetProperties.__webglDepthRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
      }
      properties.remove(renderTarget.texture);
      properties.remove(renderTarget);
    }
    let textureUnits = 0;
    function resetTextureUnits() {
      textureUnits = 0;
    }
    function allocateTextureUnit() {
      const textureUnit = textureUnits;
      if (textureUnit >= maxTextures) {
        console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
      }
      textureUnits += 1;
      return textureUnit;
    }
    function setTexture2D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.isVideoTexture)
        updateVideoTexture(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        const image = texture.image;
        if (image === void 0) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
        } else if (image.complete === false) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        } else {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(35866, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadCubeTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
    }
    const wrappingToGL = {
      [RepeatWrapping]: 10497,
      [ClampToEdgeWrapping]: 33071,
      [MirroredRepeatWrapping]: 33648
    };
    const filterToGL = {
      [NearestFilter]: 9728,
      [NearestMipmapNearestFilter]: 9984,
      [NearestMipmapLinearFilter]: 9986,
      [LinearFilter]: 9729,
      [LinearMipmapNearestFilter]: 9985,
      [LinearMipmapLinearFilter]: 9987
    };
    function setTextureParameters(textureType, texture, supportsMips) {
      if (supportsMips) {
        _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
        _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
        }
        _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
        _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
      } else {
        _gl.texParameteri(textureType, 10242, 33071);
        _gl.texParameteri(textureType, 10243, 33071);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, 33071);
        }
        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
        }
        _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
        _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
        }
      }
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (extension) {
        if (texture.type === FloatType && extensions.get("OES_texture_float_linear") === null)
          return;
        if (texture.type === HalfFloatType && (isWebGL2 || extensions.get("OES_texture_half_float_linear")) === null)
          return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }
    function initTexture(textureProperties, texture) {
      if (textureProperties.__webglInit === void 0) {
        textureProperties.__webglInit = true;
        texture.addEventListener("dispose", onTextureDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
      }
    }
    function uploadTexture(textureProperties, texture, slot) {
      let textureType = 3553;
      if (texture.isDataTexture2DArray)
        textureType = 35866;
      if (texture.isDataTexture3D)
        textureType = 32879;
      initTexture(textureProperties, texture);
      state.activeTexture(33984 + slot);
      state.bindTexture(textureType, textureProperties.__webglTexture);
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
      const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
      const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
      let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      setTextureParameters(textureType, texture, supportsMips);
      let mipmap;
      const mipmaps = texture.mipmaps;
      if (texture.isDepthTexture) {
        glInternalFormat = 6402;
        if (isWebGL2) {
          if (texture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = 35056;
          } else {
            glInternalFormat = 33189;
          }
        } else {
          if (texture.type === FloatType) {
            console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
          }
        }
        if (texture.format === DepthFormat && glInternalFormat === 6402) {
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture.type = UnsignedShortType;
            glType = utils.convert(texture.type);
          }
        }
        if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
          glInternalFormat = 34041;
          if (texture.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture.type = UnsignedInt248Type;
            glType = utils.convert(texture.type);
          }
        }
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
          texture.generateMipmaps = false;
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          textureProperties.__maxMipLevel = 0;
        }
      } else if (texture.isCompressedTexture) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else if (texture.isDataTexture2DArray) {
        state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      } else if (texture.isDataTexture3D) {
        state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
          }
          texture.generateMipmaps = false;
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
          textureProperties.__maxMipLevel = 0;
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType, texture, image.width, image.height);
      }
      textureProperties.__version = texture.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
      if (texture.image.length !== 6)
        return;
      initTexture(textureProperties, texture);
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
      _gl.pixelStorei(37440, texture.flipY);
      const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
        } else {
          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
        }
      }
      const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      setTextureParameters(34067, texture, supportsMips);
      let mipmaps;
      if (isCompressed) {
        for (let i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
              if (glFormat !== null) {
                state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        mipmaps = texture.mipmaps;
        for (let i = 0; i < 6; i++) {
          if (isDataTexture) {
            state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i].image;
              state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
            }
          } else {
            state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
            }
          }
        }
        textureProperties.__maxMipLevel = mipmaps.length;
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, image.width, image.height);
      }
      textureProperties.__version = texture.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
      const glFormat = utils.convert(renderTarget.texture.format);
      const glType = utils.convert(renderTarget.texture.type);
      const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
      _gl.bindFramebuffer(36160, framebuffer);
      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
      _gl.bindFramebuffer(36160, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
      _gl.bindRenderbuffer(36161, renderbuffer);
      if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
        let glInternalFormat = 33189;
        if (isMultisample) {
          const depthTexture = renderTarget.depthTexture;
          if (depthTexture && depthTexture.isDepthTexture) {
            if (depthTexture.type === FloatType) {
              glInternalFormat = 36012;
            } else if (depthTexture.type === UnsignedIntType) {
              glInternalFormat = 33190;
            }
          }
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
      } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
        if (isMultisample) {
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
      } else {
        const glFormat = utils.convert(renderTarget.texture.format);
        const glType = utils.convert(renderTarget.texture.type);
        const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
        if (isMultisample) {
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
      _gl.bindRenderbuffer(36161, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
      const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
      if (isCube)
        throw new Error("Depth Texture with cube render targets is not supported");
      _gl.bindFramebuffer(36160, framebuffer);
      if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      }
      if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
      }
      setTexture2D(renderTarget.depthTexture, 0);
      const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
      if (renderTarget.depthTexture.format === DepthFormat) {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
      } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
      } else {
        throw new Error("Unknown depthTexture format");
      }
    }
    function setupDepthRenderbuffer(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      if (renderTarget.depthTexture) {
        if (isCube)
          throw new Error("target.depthTexture not supported in Cube render targets");
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
      } else {
        if (isCube) {
          renderTargetProperties.__webglDepthbuffer = [];
          for (let i = 0; i < 6; i++) {
            _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
          }
        } else {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
      }
      _gl.bindFramebuffer(36160, null);
    }
    function setupRenderTarget(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(renderTarget.texture);
      renderTarget.addEventListener("dispose", onRenderTargetDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
      const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
      if (isWebGL2 && renderTarget.texture.format === RGBFormat && (renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType)) {
        renderTarget.texture.format = RGBAFormat;
        console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
      }
      if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let i = 0; i < 6; i++) {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        if (isMultisample) {
          if (isWebGL2) {
            renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
            renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
            const glFormat = utils.convert(renderTarget.texture.format);
            const glType = utils.convert(renderTarget.texture.type);
            const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
            const samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
            _gl.bindRenderbuffer(36161, null);
            if (renderTarget.depthBuffer) {
              renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
            }
            _gl.bindFramebuffer(36160, null);
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          }
        }
      }
      if (isCube) {
        state.bindTexture(34067, textureProperties.__webglTexture);
        setTextureParameters(34067, renderTarget.texture, supportsMips);
        for (let i = 0; i < 6; i++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
        }
        if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
          generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
        }
        state.bindTexture(34067, null);
      } else {
        state.bindTexture(3553, textureProperties.__webglTexture);
        setTextureParameters(3553, renderTarget.texture, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);
        if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
          generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
        }
        state.bindTexture(3553, null);
      }
      if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function updateRenderTargetMipmap(renderTarget) {
      const texture = renderTarget.texture;
      const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target, texture, renderTarget.width, renderTarget.height);
        state.bindTexture(target, null);
      }
    }
    function updateMultisampleRenderTarget(renderTarget) {
      if (renderTarget.isWebGLMultisampleRenderTarget) {
        if (isWebGL2) {
          const renderTargetProperties = properties.get(renderTarget);
          _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
          const width = renderTarget.width;
          const height = renderTarget.height;
          let mask = 16384;
          if (renderTarget.depthBuffer)
            mask |= 256;
          if (renderTarget.stencilBuffer)
            mask |= 1024;
          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    function getRenderTargetSamples(renderTarget) {
      return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
    }
    function updateVideoTexture(texture) {
      const frame = info.render.frame;
      if (_videoTextures.get(texture) !== frame) {
        _videoTextures.set(texture, frame);
        texture.update();
      }
    }
    let warnedTexture2D = false;
    let warnedTextureCube = false;
    function safeSetTexture2D(texture, slot) {
      if (texture && texture.isWebGLRenderTarget) {
        if (warnedTexture2D === false) {
          console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
          warnedTexture2D = true;
        }
        texture = texture.texture;
      }
      setTexture2D(texture, slot);
    }
    function safeSetTextureCube(texture, slot) {
      if (texture && texture.isWebGLCubeRenderTarget) {
        if (warnedTextureCube === false) {
          console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
          warnedTextureCube = true;
        }
        texture = texture.texture;
      }
      setTextureCube(texture, slot);
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
  }
  function WebGLUtils(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p) {
      let extension;
      if (p === UnsignedByteType)
        return 5121;
      if (p === UnsignedShort4444Type)
        return 32819;
      if (p === UnsignedShort5551Type)
        return 32820;
      if (p === UnsignedShort565Type)
        return 33635;
      if (p === ByteType)
        return 5120;
      if (p === ShortType)
        return 5122;
      if (p === UnsignedShortType)
        return 5123;
      if (p === IntType)
        return 5124;
      if (p === UnsignedIntType)
        return 5125;
      if (p === FloatType)
        return 5126;
      if (p === HalfFloatType) {
        if (isWebGL2)
          return 5131;
        extension = extensions.get("OES_texture_half_float");
        if (extension !== null) {
          return extension.HALF_FLOAT_OES;
        } else {
          return null;
        }
      }
      if (p === AlphaFormat)
        return 6406;
      if (p === RGBFormat)
        return 6407;
      if (p === RGBAFormat)
        return 6408;
      if (p === LuminanceFormat)
        return 6409;
      if (p === LuminanceAlphaFormat)
        return 6410;
      if (p === DepthFormat)
        return 6402;
      if (p === DepthStencilFormat)
        return 34041;
      if (p === RedFormat)
        return 6403;
      if (p === RedIntegerFormat)
        return 36244;
      if (p === RGFormat)
        return 33319;
      if (p === RGIntegerFormat)
        return 33320;
      if (p === RGBIntegerFormat)
        return 36248;
      if (p === RGBAIntegerFormat)
        return 36249;
      if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
      if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
        if (extension !== null) {
          if (p === RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p === RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p === RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p === RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else {
          return null;
        }
      }
      if (p === RGB_ETC1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc1");
        if (extension !== null) {
          return extension.COMPRESSED_RGB_ETC1_WEBGL;
        } else {
          return null;
        }
      }
      if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc");
        if (extension !== null) {
          if (p === RGB_ETC2_Format)
            return extension.COMPRESSED_RGB8_ETC2;
          if (p === RGBA_ETC2_EAC_Format)
            return extension.COMPRESSED_RGBA8_ETC2_EAC;
        }
      }
      if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
        extension = extensions.get("WEBGL_compressed_texture_astc");
        if (extension !== null) {
          return p;
        } else {
          return null;
        }
      }
      if (p === RGBA_BPTC_Format) {
        extension = extensions.get("EXT_texture_compression_bptc");
        if (extension !== null) {
          return p;
        } else {
          return null;
        }
      }
      if (p === UnsignedInt248Type) {
        if (isWebGL2)
          return 34042;
        extension = extensions.get("WEBGL_depth_texture");
        if (extension !== null) {
          return extension.UNSIGNED_INT_24_8_WEBGL;
        } else {
          return null;
        }
      }
    }
    return {convert};
  }
  function ArrayCamera(array = []) {
    PerspectiveCamera.call(this);
    this.cameras = array;
  }
  ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
    constructor: ArrayCamera,
    isArrayCamera: true
  });
  function Group() {
    Object3D.call(this);
    this.type = "Group";
  }
  Group.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Group,
    isGroup: true
  });
  function WebXRController() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  Object.assign(WebXRController.prototype, {
    constructor: WebXRController,
    getHandSpace: function() {
      if (this._hand === null) {
        this._hand = new Group();
        this._hand.matrixAutoUpdate = false;
        this._hand.visible = false;
        this._hand.joints = [];
        this._hand.inputState = {pinching: false};
        if (window.XRHand) {
          for (let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++) {
            const joint = new Group();
            joint.matrixAutoUpdate = false;
            joint.visible = false;
            this._hand.joints.push(joint);
            this._hand.add(joint);
          }
        }
      }
      return this._hand;
    },
    getTargetRaySpace: function() {
      if (this._targetRay === null) {
        this._targetRay = new Group();
        this._targetRay.matrixAutoUpdate = false;
        this._targetRay.visible = false;
      }
      return this._targetRay;
    },
    getGripSpace: function() {
      if (this._grip === null) {
        this._grip = new Group();
        this._grip.matrixAutoUpdate = false;
        this._grip.visible = false;
      }
      return this._grip;
    },
    dispatchEvent: function(event) {
      if (this._targetRay !== null) {
        this._targetRay.dispatchEvent(event);
      }
      if (this._grip !== null) {
        this._grip.dispatchEvent(event);
      }
      if (this._hand !== null) {
        this._hand.dispatchEvent(event);
      }
      return this;
    },
    disconnect: function(inputSource) {
      this.dispatchEvent({type: "disconnected", data: inputSource});
      if (this._targetRay !== null) {
        this._targetRay.visible = false;
      }
      if (this._grip !== null) {
        this._grip.visible = false;
      }
      if (this._hand !== null) {
        this._hand.visible = false;
      }
      return this;
    },
    update: function(inputSource, frame, referenceSpace) {
      let inputPose = null;
      let gripPose = null;
      let handPose = null;
      const targetRay = this._targetRay;
      const grip = this._grip;
      const hand = this._hand;
      if (inputSource && frame.session.visibilityState !== "visible-blurred") {
        if (hand && inputSource.hand) {
          handPose = true;
          for (let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++) {
            if (inputSource.hand[i]) {
              const jointPose = frame.getJointPose(inputSource.hand[i], referenceSpace);
              const joint = hand.joints[i];
              if (jointPose !== null) {
                joint.matrix.fromArray(jointPose.transform.matrix);
                joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                joint.jointRadius = jointPose.radius;
              }
              joint.visible = jointPose !== null;
              const indexTip = hand.joints[window.XRHand.INDEX_PHALANX_TIP];
              const thumbTip = hand.joints[window.XRHand.THUMB_PHALANX_TIP];
              const distance = indexTip.position.distanceTo(thumbTip.position);
              const distanceToPinch = 0.02;
              const threshold = 5e-3;
              if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                hand.inputState.pinching = false;
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: inputSource.handedness,
                  target: this
                });
              } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                hand.inputState.pinching = true;
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: inputSource.handedness,
                  target: this
                });
              }
            }
          }
        } else {
          if (targetRay !== null) {
            inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
            if (inputPose !== null) {
              targetRay.matrix.fromArray(inputPose.transform.matrix);
              targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
            }
          }
          if (grip !== null && inputSource.gripSpace) {
            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
            if (gripPose !== null) {
              grip.matrix.fromArray(gripPose.transform.matrix);
              grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            }
          }
        }
      }
      if (targetRay !== null) {
        targetRay.visible = inputPose !== null;
      }
      if (grip !== null) {
        grip.visible = gripPose !== null;
      }
      if (hand !== null) {
        hand.visible = handPose !== null;
      }
      return this;
    }
  });
  function WebXRManager(renderer3, gl) {
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let pose = null;
    const controllers = [];
    const inputSourcesMap = new Map();
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controller = inputSourcesMap.get(event.inputSource);
      if (controller) {
        controller.dispatchEvent({type: event.type, data: event.inputSource});
      }
    }
    function onSessionEnd() {
      inputSourcesMap.forEach(function(controller, inputSource) {
        controller.disconnect(inputSource);
      });
      inputSourcesMap.clear();
      renderer3.setFramebuffer(null);
      renderer3.setRenderTarget(renderer3.getRenderTarget());
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({type: "sessionend"});
    }
    function onRequestReferenceSpace(value) {
      referenceSpace = value;
      animation.setContext(session);
      animation.start();
      scope.isPresenting = true;
      scope.dispatchEvent({type: "sessionstart"});
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return referenceSpace;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = function(value) {
      session = value;
      if (session !== null) {
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        const attributes = gl.getContextAttributes();
        if (attributes.xrCompatible !== true) {
          gl.makeXRCompatible();
        }
        const layerInit = {
          antialias: attributes.antialias,
          alpha: attributes.alpha,
          depth: attributes.depth,
          stencil: attributes.stencil,
          framebufferScaleFactor
        };
        const baseLayer = new XRWebGLLayer(session, gl, layerInit);
        session.updateRenderState({baseLayer});
        session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);
        session.addEventListener("inputsourceschange", updateInputSources);
      }
    };
    function updateInputSources(event) {
      const inputSources = session.inputSources;
      for (let i = 0; i < controllers.length; i++) {
        inputSourcesMap.set(inputSources[i], controllers[i]);
      }
      for (let i = 0; i < event.removed.length; i++) {
        const inputSource = event.removed[i];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({type: "disconnected", data: inputSource});
          inputSourcesMap.delete(inputSource);
        }
      }
      for (let i = 0; i < event.added.length; i++) {
        const inputSource = event.added[i];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({type: "connected", data: inputSource});
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera2, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera2.position, camera2.quaternion, camera2.scale);
      camera2.translateX(xOffset);
      camera2.translateZ(zOffset);
      camera2.matrixWorld.compose(camera2.position, camera2.quaternion, camera2.scale);
      camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera2.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera2, parent) {
      if (parent === null) {
        camera2.matrixWorld.copy(camera2.matrix);
      } else {
        camera2.matrixWorld.multiplyMatrices(parent.matrixWorld, camera2.matrix);
      }
      camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
    }
    this.getCamera = function(camera2) {
      cameraVR.near = cameraR.near = cameraL.near = camera2.near;
      cameraVR.far = cameraR.far = cameraL.far = camera2.far;
      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }
      const parent = camera2.parent;
      const cameras2 = cameraVR.cameras;
      updateCamera(cameraVR, parent);
      for (let i = 0; i < cameras2.length; i++) {
        updateCamera(cameras2[i], parent);
      }
      camera2.matrixWorld.copy(cameraVR.matrixWorld);
      const children = camera2.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(true);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
      return cameraVR;
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(referenceSpace);
      if (pose !== null) {
        const views = pose.views;
        const baseLayer = session.renderState.baseLayer;
        renderer3.setFramebuffer(baseLayer.framebuffer);
        let cameraVRNeedsUpdate = false;
        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }
        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          const viewport = baseLayer.getViewport(view);
          const camera2 = cameras[i];
          camera2.matrix.fromArray(view.transform.matrix);
          camera2.projectionMatrix.fromArray(view.projectionMatrix);
          camera2.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i === 0) {
            cameraVR.matrix.copy(camera2.matrix);
          }
          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera2);
          }
        }
      }
      const inputSources = session.inputSources;
      for (let i = 0; i < controllers.length; i++) {
        const controller = controllers[i];
        const inputSource = inputSources[i];
        controller.update(inputSource, frame, referenceSpace);
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time, frame);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
  Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
  function WebGLMaterials(properties) {
    function refreshFogUniforms(uniforms, fog) {
      uniforms.fogColor.value.copy(fog.color);
      if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsLambert(uniforms, material);
      } else if (material.isMeshToonMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsToon(uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsPhong(uniforms, material);
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(uniforms, material);
        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(uniforms, material);
        } else {
          refreshUniformsStandard(uniforms, material);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsMatcap(uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDepth(uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDistance(uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsNormal(uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(uniforms, material);
        if (material.isLineDashedMaterial) {
          refreshUniformsDash(uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(uniforms, material, pixelRatio, height);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(uniforms, material);
      } else if (material.isShadowMaterial) {
        uniforms.color.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
      } else if (material.isShaderMaterial) {
        material.uniformsNeedUpdate = false;
      }
    }
    function refreshUniformsCommon(uniforms, material) {
      uniforms.opacity.value = material.opacity;
      if (material.color) {
        uniforms.diffuse.value.copy(material.color);
      }
      if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      }
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.specularMap) {
        uniforms.specularMap.value = material.specularMap;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMap.value = envMap;
        uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;
        const maxMipLevel = properties.get(envMap).__maxMipLevel;
        if (maxMipLevel !== void 0) {
          uniforms.maxMipLevel.value = maxMipLevel;
        }
      }
      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
      }
      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.specularMap) {
        uvScaleMap = material.specularMap;
      } else if (material.displacementMap) {
        uvScaleMap = material.displacementMap;
      } else if (material.normalMap) {
        uvScaleMap = material.normalMap;
      } else if (material.bumpMap) {
        uvScaleMap = material.bumpMap;
      } else if (material.roughnessMap) {
        uvScaleMap = material.roughnessMap;
      } else if (material.metalnessMap) {
        uvScaleMap = material.metalnessMap;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      } else if (material.emissiveMap) {
        uvScaleMap = material.emissiveMap;
      } else if (material.clearcoatMap) {
        uvScaleMap = material.clearcoatMap;
      } else if (material.clearcoatNormalMap) {
        uvScaleMap = material.clearcoatNormalMap;
      } else if (material.clearcoatRoughnessMap) {
        uvScaleMap = material.clearcoatRoughnessMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.isWebGLRenderTarget) {
          uvScaleMap = uvScaleMap.texture;
        }
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
      let uv2ScaleMap;
      if (material.aoMap) {
        uv2ScaleMap = material.aoMap;
      } else if (material.lightMap) {
        uv2ScaleMap = material.lightMap;
      }
      if (uv2ScaleMap !== void 0) {
        if (uv2ScaleMap.isWebGLRenderTarget) {
          uv2ScaleMap = uv2ScaleMap.texture;
        }
        if (uv2ScaleMap.matrixAutoUpdate === true) {
          uv2ScaleMap.updateMatrix();
        }
        uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
      }
    }
    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * pixelRatio;
      uniforms.scale.value = height * 0.5;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsSprites(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.rotation.value = material.rotation;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsLambert(uniforms, material) {
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
    }
    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value.copy(material.specular);
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsToon(uniforms, material) {
      if (material.gradientMap) {
        uniforms.gradientMap.value = material.gradientMap;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsStandard(uniforms, material) {
      uniforms.roughness.value = material.roughness;
      uniforms.metalness.value = material.metalness;
      if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
      }
      if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
      }
    }
    function refreshUniformsPhysical(uniforms, material) {
      refreshUniformsStandard(uniforms, material);
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.sheen)
        uniforms.sheen.value.copy(material.sheen);
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
      uniforms.transmission.value = material.transmission;
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
      }
    }
    function refreshUniformsMatcap(uniforms, material) {
      if (material.matcap) {
        uniforms.matcap.value = material.matcap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsDepth(uniforms, material) {
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsDistance(uniforms, material) {
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      uniforms.referencePosition.value.copy(material.referencePosition);
      uniforms.nearDistance.value = material.nearDistance;
      uniforms.farDistance.value = material.farDistance;
    }
    function refreshUniformsNormal(uniforms, material) {
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    return {
      refreshFogUniforms,
      refreshMaterialUniforms
    };
  }
  function createCanvasElement() {
    const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    canvas.style.display = "block";
    return canvas;
  }
  function WebGLRenderer(parameters) {
    parameters = parameters || {};
    const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
    let currentRenderList = null;
    let currentRenderState = null;
    this.domElement = _canvas2;
    this.debug = {
      checkShaderErrors: true
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.gammaFactor = 2;
    this.outputEncoding = LinearEncoding;
    this.physicallyCorrectLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    const _this = this;
    let _isContextLost = false;
    let _framebuffer = null;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentFramebuffer = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    let _currentArrayCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    let _width = _canvas2.width;
    let _height = _canvas2.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    const _projScreenMatrix = new Matrix4();
    const _vector3 = new Vector3();
    const _emptyScene = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: true};
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = _context2;
    function getContext(contextNames, contextAttributes) {
      for (let i = 0; i < contextNames.length; i++) {
        const contextName = contextNames[i];
        const context = _canvas2.getContext(contextName, contextAttributes);
        if (context !== null)
          return context;
      }
      return null;
    }
    try {
      const contextAttributes = {
        alpha: _alpha,
        depth: _depth,
        stencil: _stencil,
        antialias: _antialias,
        premultipliedAlpha: _premultipliedAlpha,
        preserveDrawingBuffer: _preserveDrawingBuffer,
        powerPreference: _powerPreference,
        failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
      };
      _canvas2.addEventListener("webglcontextlost", onContextLost, false);
      _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
      if (_gl === null) {
        const contextNames = ["webgl2", "webgl", "experimental-webgl"];
        if (_this.isWebGL1Renderer === true) {
          contextNames.shift();
        }
        _gl = getContext(contextNames, contextAttributes);
        if (_gl === null) {
          if (getContext(contextNames)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
      if (_gl.getShaderPrecisionFormat === void 0) {
        _gl.getShaderPrecisionFormat = function() {
          return {rangeMin: 1, rangeMax: 1, precision: 1};
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters);
      if (capabilities.isWebGL2 === false) {
        extensions.get("WEBGL_depth_texture");
        extensions.get("OES_texture_float");
        extensions.get("OES_texture_half_float");
        extensions.get("OES_texture_half_float_linear");
        extensions.get("OES_standard_derivatives");
        extensions.get("OES_element_index_uint");
        extensions.get("OES_vertex_array_object");
        extensions.get("ANGLE_instanced_arrays");
      }
      extensions.get("OES_texture_float_linear");
      utils = new WebGLUtils(_gl, extensions, capabilities);
      state = new WebGLState(_gl, extensions, capabilities);
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      attributes = new WebGLAttributes(_gl, capabilities);
      bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(properties);
      renderLists = new WebGLRenderLists(properties);
      renderStates = new WebGLRenderStates(extensions, capabilities);
      background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
    this.shadowMap = shadowMap;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0)
        return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      if (target === void 0) {
        console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
        target = new Vector2();
      }
      return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width;
      _height = height;
      _canvas2.width = Math.floor(width * _pixelRatio);
      _canvas2.height = Math.floor(height * _pixelRatio);
      if (updateStyle !== false) {
        _canvas2.style.width = width + "px";
        _canvas2.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
      if (target === void 0) {
        console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
        target = new Vector2();
      }
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      _canvas2.width = Math.floor(width * pixelRatio);
      _canvas2.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
      if (target === void 0) {
        console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
        target = new Vector4();
      }
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function() {
      return background.getClearColor();
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color, depth, stencil) {
      let bits = 0;
      if (color === void 0 || color)
        bits |= 16384;
      if (depth === void 0 || depth)
        bits |= 256;
      if (stencil === void 0 || stencil)
        bits |= 1024;
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
      _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      xr.dispose();
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      initGLContext();
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReference(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReference(material) {
      const programInfo = properties.get(material).program;
      if (programInfo !== void 0) {
        programCache.releaseProgram(programInfo);
      }
    }
    function renderObjectImmediate(object, program) {
      object.render(function(object2) {
        _this.renderBufferImmediate(object2, program);
      });
    }
    this.renderBufferImmediate = function(object, program) {
      bindingStates.initAttributes();
      const buffers = properties.get(object);
      if (object.hasPositions && !buffers.position)
        buffers.position = _gl.createBuffer();
      if (object.hasNormals && !buffers.normal)
        buffers.normal = _gl.createBuffer();
      if (object.hasUvs && !buffers.uv)
        buffers.uv = _gl.createBuffer();
      if (object.hasColors && !buffers.color)
        buffers.color = _gl.createBuffer();
      const programAttributes = program.getAttributes();
      if (object.hasPositions) {
        _gl.bindBuffer(34962, buffers.position);
        _gl.bufferData(34962, object.positionArray, 35048);
        bindingStates.enableAttribute(programAttributes.position);
        _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
      }
      if (object.hasNormals) {
        _gl.bindBuffer(34962, buffers.normal);
        _gl.bufferData(34962, object.normalArray, 35048);
        bindingStates.enableAttribute(programAttributes.normal);
        _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
      }
      if (object.hasUvs) {
        _gl.bindBuffer(34962, buffers.uv);
        _gl.bufferData(34962, object.uvArray, 35048);
        bindingStates.enableAttribute(programAttributes.uv);
        _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
      }
      if (object.hasColors) {
        _gl.bindBuffer(34962, buffers.color);
        _gl.bufferData(34962, object.colorArray, 35048);
        bindingStates.enableAttribute(programAttributes.color);
        _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
      }
      bindingStates.disableUnusedAttributes();
      _gl.drawArrays(4, 0, object.count);
      object.count = 0;
    };
    this.renderBufferDirect = function(camera2, scene2, geometry, material, object, group2) {
      if (scene2 === null)
        scene2 = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera2, scene2, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      const position = geometry.attributes.position;
      if (index === null) {
        if (position === void 0 || position.count === 0)
          return;
      } else if (index.count === 0) {
        return;
      }
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        rangeFactor = 2;
      }
      if (material.morphTargets || material.morphNormals) {
        morphtargets.update(object, geometry, material, program);
      }
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer3 = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer3 = indexedBufferRenderer;
        renderer3.setIndex(attribute);
      }
      const dataCount = index !== null ? index.count : position.count;
      const rangeStart = geometry.drawRange.start * rangeFactor;
      const rangeCount = geometry.drawRange.count * rangeFactor;
      const groupStart = group2 !== null ? group2.start * rangeFactor : 0;
      const groupCount = group2 !== null ? group2.count * rangeFactor : Infinity;
      const drawStart = Math.max(rangeStart, groupStart);
      const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
      const drawCount = Math.max(0, drawEnd - drawStart + 1);
      if (drawCount === 0)
        return;
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer3.setMode(1);
        } else {
          renderer3.setMode(4);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0)
          lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer3.setMode(1);
        } else if (object.isLineLoop) {
          renderer3.setMode(2);
        } else {
          renderer3.setMode(3);
        }
      } else if (object.isPoints) {
        renderer3.setMode(0);
      } else if (object.isSprite) {
        renderer3.setMode(4);
      }
      if (object.isInstancedMesh) {
        renderer3.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
        renderer3.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer3.render(drawStart, drawCount);
      }
    };
    this.compile = function(scene2, camera2) {
      currentRenderState = renderStates.get(scene2, camera2);
      currentRenderState.init();
      scene2.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera2.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      currentRenderState.setupLights(camera2);
      const compiled = new WeakMap();
      scene2.traverse(function(object) {
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i = 0; i < material.length; i++) {
              const material2 = material[i];
              if (compiled.has(material2) === false) {
                initMaterial(material2, scene2, object);
                compiled.set(material2);
              }
            }
          } else if (compiled.has(material) === false) {
            initMaterial(material, scene2, object);
            compiled.set(material);
          }
        }
      });
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (xr.isPresenting)
        return;
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== "undefined")
      animation.setContext(window);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    this.render = function(scene2, camera2) {
      let renderTarget, forceClear;
      if (arguments[2] !== void 0) {
        console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
        renderTarget = arguments[2];
      }
      if (arguments[3] !== void 0) {
        console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
        forceClear = arguments[3];
      }
      if (camera2 !== void 0 && camera2.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true)
        return;
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      if (scene2.autoUpdate === true)
        scene2.updateMatrixWorld();
      if (camera2.parent === null)
        camera2.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        camera2 = xr.getCamera(camera2);
      }
      if (scene2.isScene === true)
        scene2.onBeforeRender(_this, scene2, camera2, renderTarget || _currentRenderTarget);
      currentRenderState = renderStates.get(scene2, camera2);
      currentRenderState.init();
      _projScreenMatrix.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera2);
      currentRenderList = renderLists.get(scene2, camera2);
      currentRenderList.init();
      projectObject(scene2, camera2, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      if (_clippingEnabled === true)
        clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene2, camera2);
      currentRenderState.setupLights(camera2);
      if (_clippingEnabled === true)
        clipping.endShadows();
      if (this.info.autoReset === true)
        this.info.reset();
      if (renderTarget !== void 0) {
        this.setRenderTarget(renderTarget);
      }
      background.render(currentRenderList, scene2, camera2, forceClear);
      const opaqueObjects = currentRenderList.opaque;
      const transparentObjects = currentRenderList.transparent;
      if (opaqueObjects.length > 0)
        renderObjects(opaqueObjects, scene2, camera2);
      if (transparentObjects.length > 0)
        renderObjects(transparentObjects, scene2, camera2);
      if (scene2.isScene === true)
        scene2.onAfterRender(_this, scene2, camera2);
      if (_currentRenderTarget !== null) {
        textures.updateRenderTargetMipmap(_currentRenderTarget);
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
      }
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
      currentRenderList = null;
      currentRenderState = null;
    };
    function projectObject(object, camera2, groupOrder, sortObjects) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera2.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true)
            object.update(camera2);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        } else if (object.isImmediateRenderObject) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (object.isSkinnedMesh) {
            if (object.skeleton.frame !== info.render.frame) {
              object.skeleton.update();
              object.skeleton.frame = info.render.frame;
            }
          }
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i = 0, l = groups.length; i < l; i++) {
                const group2 = groups[i];
                const groupMaterial = material[group2.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group2);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        projectObject(children[i], camera2, groupOrder, sortObjects);
      }
    }
    function renderObjects(renderList, scene2, camera2) {
      const overrideMaterial = scene2.isScene === true ? scene2.overrideMaterial : null;
      for (let i = 0, l = renderList.length; i < l; i++) {
        const renderItem = renderList[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group2 = renderItem.group;
        if (camera2.isArrayCamera) {
          _currentArrayCamera = camera2;
          const cameras = camera2.cameras;
          for (let j = 0, jl = cameras.length; j < jl; j++) {
            const camera22 = cameras[j];
            if (object.layers.test(camera22.layers)) {
              state.viewport(_currentViewport.copy(camera22.viewport));
              currentRenderState.setupLights(camera22);
              renderObject(object, scene2, camera22, geometry, material, group2);
            }
          }
        } else {
          _currentArrayCamera = null;
          renderObject(object, scene2, camera2, geometry, material, group2);
        }
      }
    }
    function renderObject(object, scene2, camera2, geometry, material, group2) {
      object.onBeforeRender(_this, scene2, camera2, geometry, material, group2);
      currentRenderState = renderStates.get(scene2, _currentArrayCamera || camera2);
      object.modelViewMatrix.multiplyMatrices(camera2.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      if (object.isImmediateRenderObject) {
        const program = setProgram(camera2, scene2, material, object);
        state.setMaterial(material);
        bindingStates.reset();
        renderObjectImmediate(object, program);
      } else {
        _this.renderBufferDirect(camera2, scene2, geometry, material, object, group2);
      }
      object.onAfterRender(_this, scene2, camera2, geometry, material, group2);
      currentRenderState = renderStates.get(scene2, _currentArrayCamera || camera2);
    }
    function initMaterial(material, scene2, object) {
      if (scene2.isScene !== true)
        scene2 = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene2, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let program = materialProperties.program;
      let programChange = true;
      if (program === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
      } else if (program.cacheKey !== programCacheKey) {
        releaseMaterialProgramReference(material);
      } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
        programChange = false;
      } else if (parameters2.shaderID !== void 0) {
        const environment = material.isMeshStandardMaterial ? scene2.environment : null;
        materialProperties.envMap = cubemaps.get(material.envMap || environment);
        return;
      } else {
        programChange = false;
      }
      if (programChange) {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        materialProperties.program = program;
        materialProperties.uniforms = parameters2.uniforms;
        materialProperties.outputEncoding = parameters2.outputEncoding;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        materialProperties.numClippingPlanes = clipping.numPlanes;
        materialProperties.numIntersection = clipping.numIntersection;
        uniforms.clippingPlanes = clipping.uniform;
      }
      materialProperties.environment = material.isMeshStandardMaterial ? scene2.environment : null;
      materialProperties.fog = scene2.fog;
      materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      const progUniforms = materialProperties.program.getUniforms();
      const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
      materialProperties.uniformsList = uniformsList;
    }
    function setProgram(camera2, scene2, material, object) {
      if (scene2.isScene !== true)
        scene2 = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene2.fog;
      const environment = material.isMeshStandardMaterial ? scene2.environment : null;
      const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
      const envMap = cubemaps.get(material.envMap || environment);
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera2 !== _currentCamera) {
          const useCache = camera2 === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera2, useCache);
        }
      }
      if (material.version === materialProperties.__version) {
        if (material.fog && materialProperties.fog !== fog) {
          initMaterial(material, scene2, object);
        } else if (materialProperties.environment !== environment) {
          initMaterial(material, scene2, object);
        } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          initMaterial(material, scene2, object);
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          initMaterial(material, scene2, object);
        } else if (materialProperties.outputEncoding !== encoding) {
          initMaterial(material, scene2, object);
        } else if (materialProperties.envMap !== envMap) {
          initMaterial(material, scene2, object);
        }
      } else {
        initMaterial(material, scene2, object);
        materialProperties.__version = material.version;
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera2) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera2.projectionMatrix);
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera2.far + 1) / Math.LN2));
        }
        if (_currentCamera !== camera2) {
          _currentCamera = camera2;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
          const uCamPos = p_uniforms.map.cameraPosition;
          if (uCamPos !== void 0) {
            uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera2.matrixWorld));
          }
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera2.isOrthographicCamera === true);
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
          p_uniforms.setValue(_gl, "viewMatrix", camera2.matrixWorldInverse);
        }
      }
      if (material.skinning) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          const bones = skeleton.bones;
          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === null) {
              let size = Math.sqrt(bones.length * 4);
              size = MathUtils.ceilPowerOfTwo(size);
              size = Math.max(size, 4);
              const boneMatrices = new Float32Array(size * size * 4);
              boneMatrices.set(skeleton.boneMatrices);
              const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
              skeleton.boneMatrices = boneMatrices;
              skeleton.boneTexture = boneTexture;
              skeleton.boneTextureSize = size;
            }
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
            p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
          } else {
            p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
          }
        }
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.setFramebuffer = function(value) {
      if (_framebuffer !== value && _currentRenderTarget === null)
        _gl.bindFramebuffer(36160, value);
      _framebuffer = value;
    };
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderList = function() {
      return currentRenderList;
    };
    this.setRenderList = function(renderList) {
      currentRenderList = renderList;
    };
    this.getRenderState = function() {
      return currentRenderState;
    };
    this.setRenderState = function(renderState) {
      currentRenderState = renderState;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
        textures.setupRenderTarget(renderTarget);
      }
      let framebuffer = _framebuffer;
      let isCube = false;
      if (renderTarget) {
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          framebuffer = __webglFramebuffer[activeCubeFace];
          isCube = true;
        } else if (renderTarget.isWebGLMultisampleRenderTarget) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          framebuffer = __webglFramebuffer;
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      if (_currentFramebuffer !== framebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);
        _currentFramebuffer = framebuffer;
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      }
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        let restore = false;
        if (framebuffer !== _currentFramebuffer) {
          _gl.bindFramebuffer(36160, framebuffer);
          restore = true;
        }
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get("EXT_color_buffer_float") : extensions.get("EXT_color_buffer_half_float")))) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (_gl.checkFramebufferStatus(36160) === 36053) {
            if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
              _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
            }
          } else {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
          }
        } finally {
          if (restore) {
            _gl.bindFramebuffer(36160, _currentFramebuffer);
          }
        }
      }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      const glFormat = utils.convert(texture.format);
      textures.setTexture2D(texture, 0);
      _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
      const width = srcTexture.image.width;
      const height = srcTexture.image.height;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        } else {
          _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
        }
      }
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(3553);
      state.unbindTexture();
    };
    this.initTexture = function(texture) {
      textures.setTexture2D(texture, 0);
      state.unbindTexture();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
    }
  }
  function WebGL1Renderer(parameters) {
    WebGLRenderer.call(this, parameters);
  }
  WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {
    constructor: WebGL1Renderer,
    isWebGL1Renderer: true
  });
  var Scene = class extends Object3D {
    constructor() {
      super();
      Object.defineProperty(this, "isScene", {value: true});
      this.type = "Scene";
      this.background = null;
      this.environment = null;
      this.fog = null;
      this.overrideMaterial = null;
      this.autoUpdate = true;
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
      }
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      if (source.background !== null)
        this.background = source.background.clone();
      if (source.environment !== null)
        this.environment = source.environment.clone();
      if (source.fog !== null)
        this.fog = source.fog.clone();
      if (source.overrideMaterial !== null)
        this.overrideMaterial = source.overrideMaterial.clone();
      this.autoUpdate = source.autoUpdate;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      if (this.background !== null)
        data.object.background = this.background.toJSON(meta);
      if (this.environment !== null)
        data.object.environment = this.environment.toJSON(meta);
      if (this.fog !== null)
        data.object.fog = this.fog.toJSON();
      return data;
    }
  };
  function InterleavedBuffer(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = {offset: 0, count: -1};
    this.version = 0;
    this.uuid = MathUtils.generateUUID();
  }
  Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
    set: function(value) {
      if (value === true)
        this.version++;
    }
  });
  Object.assign(InterleavedBuffer.prototype, {
    isInterleavedBuffer: true,
    onUploadCallback: function() {
    },
    setUsage: function(value) {
      this.usage = value;
      return this;
    },
    copy: function(source) {
      this.array = new source.array.constructor(source.array);
      this.count = source.count;
      this.stride = source.stride;
      this.usage = source.usage;
      return this;
    },
    copyAt: function(index1, attribute, index2) {
      index1 *= this.stride;
      index2 *= attribute.stride;
      for (let i = 0, l = this.stride; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    },
    set: function(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    },
    clone: function(data) {
      if (data.arrayBuffers === void 0) {
        data.arrayBuffers = {};
      }
      if (this.array.buffer._uuid === void 0) {
        this.array.buffer._uuid = MathUtils.generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
        data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
      }
      const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
      const ib = new InterleavedBuffer(array, this.stride);
      ib.setUsage(this.usage);
      return ib;
    },
    onUpload: function(callback) {
      this.onUploadCallback = callback;
      return this;
    },
    toJSON: function(data) {
      if (data.arrayBuffers === void 0) {
        data.arrayBuffers = {};
      }
      if (this.array.buffer._uuid === void 0) {
        this.array.buffer._uuid = MathUtils.generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
        data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
      }
      return {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  });
  var _vector$6 = new Vector3();
  function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
  }
  Object.defineProperties(InterleavedBufferAttribute.prototype, {
    count: {
      get: function() {
        return this.data.count;
      }
    },
    array: {
      get: function() {
        return this.data.array;
      }
    },
    needsUpdate: {
      set: function(value) {
        this.data.needsUpdate = value;
      }
    }
  });
  Object.assign(InterleavedBufferAttribute.prototype, {
    isInterleavedBufferAttribute: true,
    applyMatrix4: function(m) {
      for (let i = 0, l = this.data.count; i < l; i++) {
        _vector$6.x = this.getX(i);
        _vector$6.y = this.getY(i);
        _vector$6.z = this.getZ(i);
        _vector$6.applyMatrix4(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    },
    setX: function(index, x) {
      this.data.array[index * this.data.stride + this.offset] = x;
      return this;
    },
    setY: function(index, y) {
      this.data.array[index * this.data.stride + this.offset + 1] = y;
      return this;
    },
    setZ: function(index, z) {
      this.data.array[index * this.data.stride + this.offset + 2] = z;
      return this;
    },
    setW: function(index, w) {
      this.data.array[index * this.data.stride + this.offset + 3] = w;
      return this;
    },
    getX: function(index) {
      return this.data.array[index * this.data.stride + this.offset];
    },
    getY: function(index) {
      return this.data.array[index * this.data.stride + this.offset + 1];
    },
    getZ: function(index) {
      return this.data.array[index * this.data.stride + this.offset + 2];
    },
    getW: function(index) {
      return this.data.array[index * this.data.stride + this.offset + 3];
    },
    setXY: function(index, x, y) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      return this;
    },
    setXYZ: function(index, x, y, z) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      return this;
    },
    setXYZW: function(index, x, y, z, w) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      this.data.array[index + 3] = w;
      return this;
    },
    clone: function(data) {
      if (data === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
        const array = [];
        for (let i = 0; i < this.count; i++) {
          const index = i * this.data.stride + this.offset;
          for (let j = 0; j < this.itemSize; j++) {
            array.push(this.data.array[index + j]);
          }
        }
        return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
      } else {
        if (data.interleavedBuffers === void 0) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === void 0) {
          data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
        }
        return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }
    },
    toJSON: function(data) {
      if (data === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
        const array = [];
        for (let i = 0; i < this.count; i++) {
          const index = i * this.data.stride + this.offset;
          for (let j = 0; j < this.itemSize; j++) {
            array.push(this.data.array[index + j]);
          }
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array,
          normalized: this.normalized
        };
      } else {
        if (data.interleavedBuffers === void 0) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === void 0) {
          data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
        }
        return {
          isInterleavedBufferAttribute: true,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized
        };
      }
    }
  });
  function SpriteMaterial(parameters) {
    Material.call(this);
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }
  SpriteMaterial.prototype = Object.create(Material.prototype);
  SpriteMaterial.prototype.constructor = SpriteMaterial;
  SpriteMaterial.prototype.isSpriteMaterial = true;
  SpriteMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  };
  var _geometry;
  var _intersectPoint = new Vector3();
  var _worldScale = new Vector3();
  var _mvPosition = new Vector3();
  var _alignedPosition = new Vector2();
  var _rotatedPosition = new Vector2();
  var _viewWorldMatrix = new Matrix4();
  var _vA$1 = new Vector3();
  var _vB$1 = new Vector3();
  var _vC$1 = new Vector3();
  var _uvA$1 = new Vector2();
  var _uvB$1 = new Vector2();
  var _uvC$1 = new Vector2();
  function Sprite(material) {
    Object3D.call(this);
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Sprite,
    isSprite: true,
    raycast: function(raycaster, intersects2) {
      if (raycaster.camera === null) {
        console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
      }
      _worldScale.setFromMatrixScale(this.matrixWorld);
      _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
      this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
      _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
      if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
        _worldScale.multiplyScalar(-_mvPosition.z);
      }
      const rotation = this.material.rotation;
      let sin, cos;
      if (rotation !== 0) {
        cos = Math.cos(rotation);
        sin = Math.sin(rotation);
      }
      const center = this.center;
      transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvA$1.set(0, 0);
      _uvB$1.set(1, 0);
      _uvC$1.set(1, 1);
      let intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
      if (intersect === null) {
        transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvB$1.set(0, 1);
        intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
        if (intersect === null) {
          return;
        }
      }
      const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far)
        return;
      intersects2.push({
        distance,
        point: _intersectPoint.clone(),
        uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
        face: null,
        object: this
      });
    },
    copy: function(source) {
      Object3D.prototype.copy.call(this, source);
      if (source.center !== void 0)
        this.center.copy(source.center);
      this.material = source.material;
      return this;
    }
  });
  function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
    if (sin !== void 0) {
      _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
      _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else {
      _rotatedPosition.copy(_alignedPosition);
    }
    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;
    vertexPosition.applyMatrix4(_viewWorldMatrix);
  }
  var _v1$4 = new Vector3();
  var _v2$2 = new Vector3();
  function LOD() {
    Object3D.call(this);
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      }
    });
    this.autoUpdate = true;
  }
  LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: LOD,
    isLOD: true,
    copy: function(source) {
      Object3D.prototype.copy.call(this, source, false);
      const levels = source.levels;
      for (let i = 0, l = levels.length; i < l; i++) {
        const level = levels[i];
        this.addLevel(level.object.clone(), level.distance);
      }
      this.autoUpdate = source.autoUpdate;
      return this;
    },
    addLevel: function(object, distance = 0) {
      distance = Math.abs(distance);
      const levels = this.levels;
      let l;
      for (l = 0; l < levels.length; l++) {
        if (distance < levels[l].distance) {
          break;
        }
      }
      levels.splice(l, 0, {distance, object});
      this.add(object);
      return this;
    },
    getCurrentLevel: function() {
      return this._currentLevel;
    },
    getObjectForDistance: function(distance) {
      const levels = this.levels;
      if (levels.length > 0) {
        let i, l;
        for (i = 1, l = levels.length; i < l; i++) {
          if (distance < levels[i].distance) {
            break;
          }
        }
        return levels[i - 1].object;
      }
      return null;
    },
    raycast: function(raycaster, intersects2) {
      const levels = this.levels;
      if (levels.length > 0) {
        _v1$4.setFromMatrixPosition(this.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(_v1$4);
        this.getObjectForDistance(distance).raycast(raycaster, intersects2);
      }
    },
    update: function(camera2) {
      const levels = this.levels;
      if (levels.length > 1) {
        _v1$4.setFromMatrixPosition(camera2.matrixWorld);
        _v2$2.setFromMatrixPosition(this.matrixWorld);
        const distance = _v1$4.distanceTo(_v2$2) / camera2.zoom;
        levels[0].object.visible = true;
        let i, l;
        for (i = 1, l = levels.length; i < l; i++) {
          if (distance >= levels[i].distance) {
            levels[i - 1].object.visible = false;
            levels[i].object.visible = true;
          } else {
            break;
          }
        }
        this._currentLevel = i - 1;
        for (; i < l; i++) {
          levels[i].object.visible = false;
        }
      }
    },
    toJSON: function(meta) {
      const data = Object3D.prototype.toJSON.call(this, meta);
      if (this.autoUpdate === false)
        data.object.autoUpdate = false;
      data.object.levels = [];
      const levels = this.levels;
      for (let i = 0, l = levels.length; i < l; i++) {
        const level = levels[i];
        data.object.levels.push({
          object: level.object.uuid,
          distance: level.distance
        });
      }
      return data;
    }
  });
  function SkinnedMesh(geometry, material) {
    if (geometry && geometry.isGeometry) {
      console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    Mesh.call(this, geometry, material);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
  }
  SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: SkinnedMesh,
    isSkinnedMesh: true,
    copy: function(source) {
      Mesh.prototype.copy.call(this, source);
      this.bindMode = source.bindMode;
      this.bindMatrix.copy(source.bindMatrix);
      this.bindMatrixInverse.copy(source.bindMatrixInverse);
      this.skeleton = source.skeleton;
      return this;
    },
    bind: function(skeleton, bindMatrix) {
      this.skeleton = skeleton;
      if (bindMatrix === void 0) {
        this.updateMatrixWorld(true);
        this.skeleton.calculateInverses();
        bindMatrix = this.matrixWorld;
      }
      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.copy(bindMatrix).invert();
    },
    pose: function() {
      this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
      const vector = new Vector4();
      const skinWeight = this.geometry.attributes.skinWeight;
      for (let i = 0, l = skinWeight.count; i < l; i++) {
        vector.x = skinWeight.getX(i);
        vector.y = skinWeight.getY(i);
        vector.z = skinWeight.getZ(i);
        vector.w = skinWeight.getW(i);
        const scale = 1 / vector.manhattanLength();
        if (scale !== Infinity) {
          vector.multiplyScalar(scale);
        } else {
          vector.set(1, 0, 0, 0);
        }
        skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
      }
    },
    updateMatrixWorld: function(force) {
      Mesh.prototype.updateMatrixWorld.call(this, force);
      if (this.bindMode === "attached") {
        this.bindMatrixInverse.copy(this.matrixWorld).invert();
      } else if (this.bindMode === "detached") {
        this.bindMatrixInverse.copy(this.bindMatrix).invert();
      } else {
        console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
      }
    },
    boneTransform: function() {
      const basePosition = new Vector3();
      const skinIndex = new Vector4();
      const skinWeight = new Vector4();
      const vector = new Vector3();
      const matrix = new Matrix4();
      return function(index, target) {
        const skeleton = this.skeleton;
        const geometry = this.geometry;
        skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
        skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
        basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
        target.set(0, 0, 0);
        for (let i = 0; i < 4; i++) {
          const weight = skinWeight.getComponent(i);
          if (weight !== 0) {
            const boneIndex = skinIndex.getComponent(i);
            matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
            target.addScaledVector(vector.copy(basePosition).applyMatrix4(matrix), weight);
          }
        }
        return target.applyMatrix4(this.bindMatrixInverse);
      };
    }()
  });
  function Bone() {
    Object3D.call(this);
    this.type = "Bone";
  }
  Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Bone,
    isBone: true
  });
  var _offsetMatrix = new Matrix4();
  var _identityMatrix = new Matrix4();
  function Skeleton(bones = [], boneInverses = []) {
    this.uuid = MathUtils.generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  Object.assign(Skeleton.prototype, {
    init: function() {
      const bones = this.bones;
      const boneInverses = this.boneInverses;
      this.boneMatrices = new Float32Array(bones.length * 16);
      if (boneInverses.length === 0) {
        this.calculateInverses();
      } else {
        if (bones.length !== boneInverses.length) {
          console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
          this.boneInverses = [];
          for (let i = 0, il = this.bones.length; i < il; i++) {
            this.boneInverses.push(new Matrix4());
          }
        }
      }
    },
    calculateInverses: function() {
      this.boneInverses.length = 0;
      for (let i = 0, il = this.bones.length; i < il; i++) {
        const inverse = new Matrix4();
        if (this.bones[i]) {
          inverse.copy(this.bones[i].matrixWorld).invert();
        }
        this.boneInverses.push(inverse);
      }
    },
    pose: function() {
      for (let i = 0, il = this.bones.length; i < il; i++) {
        const bone = this.bones[i];
        if (bone) {
          bone.matrixWorld.copy(this.boneInverses[i]).invert();
        }
      }
      for (let i = 0, il = this.bones.length; i < il; i++) {
        const bone = this.bones[i];
        if (bone) {
          if (bone.parent && bone.parent.isBone) {
            bone.matrix.copy(bone.parent.matrixWorld).invert();
            bone.matrix.multiply(bone.matrixWorld);
          } else {
            bone.matrix.copy(bone.matrixWorld);
          }
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        }
      }
    },
    update: function() {
      const bones = this.bones;
      const boneInverses = this.boneInverses;
      const boneMatrices = this.boneMatrices;
      const boneTexture = this.boneTexture;
      for (let i = 0, il = bones.length; i < il; i++) {
        const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
        _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
        _offsetMatrix.toArray(boneMatrices, i * 16);
      }
      if (boneTexture !== null) {
        boneTexture.needsUpdate = true;
      }
    },
    clone: function() {
      return new Skeleton(this.bones, this.boneInverses);
    },
    getBoneByName: function(name) {
      for (let i = 0, il = this.bones.length; i < il; i++) {
        const bone = this.bones[i];
        if (bone.name === name) {
          return bone;
        }
      }
      return void 0;
    },
    dispose: function() {
      if (this.boneTexture !== null) {
        this.boneTexture.dispose();
        this.boneTexture = null;
      }
    },
    fromJSON: function(json, bones) {
      this.uuid = json.uuid;
      for (let i = 0, l = json.bones.length; i < l; i++) {
        const uuid = json.bones[i];
        let bone = bones[uuid];
        if (bone === void 0) {
          console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
          bone = new Bone();
        }
        this.bones.push(bone);
        this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
      }
      this.init();
      return this;
    },
    toJSON: function() {
      const data = {
        metadata: {
          version: 4.5,
          type: "Skeleton",
          generator: "Skeleton.toJSON"
        },
        bones: [],
        boneInverses: []
      };
      data.uuid = this.uuid;
      const bones = this.bones;
      const boneInverses = this.boneInverses;
      for (let i = 0, l = bones.length; i < l; i++) {
        const bone = bones[i];
        data.bones.push(bone.uuid);
        const boneInverse = boneInverses[i];
        data.boneInverses.push(boneInverse.toArray());
      }
      return data;
    }
  });
  var _instanceLocalMatrix = new Matrix4();
  var _instanceWorldMatrix = new Matrix4();
  var _instanceIntersects = [];
  var _mesh = new Mesh();
  function InstancedMesh(geometry, material, count) {
    Mesh.call(this, geometry, material);
    this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.frustumCulled = false;
  }
  InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: InstancedMesh,
    isInstancedMesh: true,
    copy: function(source) {
      Mesh.prototype.copy.call(this, source);
      this.instanceMatrix.copy(source.instanceMatrix);
      this.count = source.count;
      return this;
    },
    getColorAt: function(index, color) {
      color.fromArray(this.instanceColor.array, index * 3);
    },
    getMatrixAt: function(index, matrix) {
      matrix.fromArray(this.instanceMatrix.array, index * 16);
    },
    raycast: function(raycaster, intersects2) {
      const matrixWorld = this.matrixWorld;
      const raycastTimes = this.count;
      _mesh.geometry = this.geometry;
      _mesh.material = this.material;
      if (_mesh.material === void 0)
        return;
      for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
        this.getMatrixAt(instanceId, _instanceLocalMatrix);
        _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
        _mesh.matrixWorld = _instanceWorldMatrix;
        _mesh.raycast(raycaster, _instanceIntersects);
        for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
          const intersect = _instanceIntersects[i];
          intersect.instanceId = instanceId;
          intersect.object = this;
          intersects2.push(intersect);
        }
        _instanceIntersects.length = 0;
      }
    },
    setColorAt: function(index, color) {
      if (this.instanceColor === null) {
        this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
      }
      color.toArray(this.instanceColor.array, index * 3);
    },
    setMatrixAt: function(index, matrix) {
      matrix.toArray(this.instanceMatrix.array, index * 16);
    },
    updateMorphTargets: function() {
    }
  });
  function LineBasicMaterial(parameters) {
    Material.call(this);
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.morphTargets = false;
    this.setValues(parameters);
  }
  LineBasicMaterial.prototype = Object.create(Material.prototype);
  LineBasicMaterial.prototype.constructor = LineBasicMaterial;
  LineBasicMaterial.prototype.isLineBasicMaterial = true;
  LineBasicMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
  };
  var _start = new Vector3();
  var _end = new Vector3();
  var _inverseMatrix$1 = new Matrix4();
  var _ray$1 = new Ray();
  var _sphere$2 = new Sphere();
  function Line(geometry, material, mode) {
    if (mode === 1) {
      console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
    }
    Object3D.call(this);
    this.type = "Line";
    this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
    this.material = material !== void 0 ? material : new LineBasicMaterial();
    this.updateMorphTargets();
  }
  Line.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Line,
    isLine: true,
    copy: function(source) {
      Object3D.prototype.copy.call(this, source);
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    },
    computeLineDistances: function() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        if (geometry.index === null) {
          const positionAttribute = geometry.attributes.position;
          const lineDistances = [0];
          for (let i = 1, l = positionAttribute.count; i < l; i++) {
            _start.fromBufferAttribute(positionAttribute, i - 1);
            _end.fromBufferAttribute(positionAttribute, i);
            lineDistances[i] = lineDistances[i - 1];
            lineDistances[i] += _start.distanceTo(_end);
          }
          geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else if (geometry.isGeometry) {
        const vertices = geometry.vertices;
        const lineDistances = geometry.lineDistances;
        lineDistances[0] = 0;
        for (let i = 1, l = vertices.length; i < l; i++) {
          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
        }
      }
      return this;
    },
    raycast: function(raycaster, intersects2) {
      const geometry = this.geometry;
      const matrixWorld = this.matrixWorld;
      const threshold = raycaster.params.Line.threshold;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$2.copy(geometry.boundingSphere);
      _sphere$2.applyMatrix4(matrixWorld);
      _sphere$2.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere$2) === false)
        return;
      _inverseMatrix$1.copy(matrixWorld).invert();
      _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
      const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      const localThresholdSq = localThreshold * localThreshold;
      const vStart = new Vector3();
      const vEnd = new Vector3();
      const interSegment = new Vector3();
      const interRay = new Vector3();
      const step = this.isLineSegments ? 2 : 1;
      if (geometry.isBufferGeometry) {
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positionAttribute = attributes.position;
        if (index !== null) {
          const indices = index.array;
          for (let i = 0, l = indices.length - 1; i < l; i += step) {
            const a = indices[i];
            const b = indices[i + 1];
            vStart.fromBufferAttribute(positionAttribute, a);
            vEnd.fromBufferAttribute(positionAttribute, b);
            const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localThresholdSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects2.push({
              distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        } else {
          for (let i = 0, l = positionAttribute.count - 1; i < l; i += step) {
            vStart.fromBufferAttribute(positionAttribute, i);
            vEnd.fromBufferAttribute(positionAttribute, i + 1);
            const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localThresholdSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects2.push({
              distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      } else if (geometry.isGeometry) {
        const vertices = geometry.vertices;
        const nbVertices = vertices.length;
        for (let i = 0; i < nbVertices - 1; i += step) {
          const distSq = _ray$1.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    },
    updateMorphTargets: function() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
              const name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        const morphTargets = geometry.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
  });
  var _start$1 = new Vector3();
  var _end$1 = new Vector3();
  function LineSegments(geometry, material) {
    Line.call(this, geometry, material);
    this.type = "LineSegments";
  }
  LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineSegments,
    isLineSegments: true,
    computeLineDistances: function() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        if (geometry.index === null) {
          const positionAttribute = geometry.attributes.position;
          const lineDistances = [];
          for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
            _start$1.fromBufferAttribute(positionAttribute, i);
            _end$1.fromBufferAttribute(positionAttribute, i + 1);
            lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
            lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
          }
          geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else if (geometry.isGeometry) {
        const vertices = geometry.vertices;
        const lineDistances = geometry.lineDistances;
        for (let i = 0, l = vertices.length; i < l; i += 2) {
          _start$1.copy(vertices[i]);
          _end$1.copy(vertices[i + 1]);
          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
        }
      }
      return this;
    }
  });
  function LineLoop(geometry, material) {
    Line.call(this, geometry, material);
    this.type = "LineLoop";
  }
  LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineLoop,
    isLineLoop: true
  });
  function PointsMaterial(parameters) {
    Material.call(this);
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  PointsMaterial.prototype = Object.create(Material.prototype);
  PointsMaterial.prototype.constructor = PointsMaterial;
  PointsMaterial.prototype.isPointsMaterial = true;
  PointsMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
  };
  var _inverseMatrix$2 = new Matrix4();
  var _ray$2 = new Ray();
  var _sphere$3 = new Sphere();
  var _position$1 = new Vector3();
  function Points(geometry, material) {
    Object3D.call(this);
    this.type = "Points";
    this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
    this.material = material !== void 0 ? material : new PointsMaterial();
    this.updateMorphTargets();
  }
  Points.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Points,
    isPoints: true,
    copy: function(source) {
      Object3D.prototype.copy.call(this, source);
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    },
    raycast: function(raycaster, intersects2) {
      const geometry = this.geometry;
      const matrixWorld = this.matrixWorld;
      const threshold = raycaster.params.Points.threshold;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$3.copy(geometry.boundingSphere);
      _sphere$3.applyMatrix4(matrixWorld);
      _sphere$3.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere$3) === false)
        return;
      _inverseMatrix$2.copy(matrixWorld).invert();
      _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
      const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      const localThresholdSq = localThreshold * localThreshold;
      if (geometry.isBufferGeometry) {
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positionAttribute = attributes.position;
        if (index !== null) {
          const indices = index.array;
          for (let i = 0, il = indices.length; i < il; i++) {
            const a = indices[i];
            _position$1.fromBufferAttribute(positionAttribute, a);
            testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
          }
        } else {
          for (let i = 0, l = positionAttribute.count; i < l; i++) {
            _position$1.fromBufferAttribute(positionAttribute, i);
            testPoint(_position$1, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
          }
        }
      } else {
        const vertices = geometry.vertices;
        for (let i = 0, l = vertices.length; i < l; i++) {
          testPoint(vertices[i], i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      }
    },
    updateMorphTargets: function() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
              const name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        const morphTargets = geometry.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
  });
  function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
    const rayPointDistanceSq = _ray$2.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
      const intersectPoint = new Vector3();
      _ray$2.closestPointToPoint(point, intersectPoint);
      intersectPoint.applyMatrix4(matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far)
        return;
      intersects2.push({
        distance,
        distanceToRay: Math.sqrt(rayPointDistanceSq),
        point: intersectPoint,
        index,
        face: null,
        object
      });
    }
  }
  function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== void 0 ? format : RGBFormat;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
    constructor: VideoTexture,
    clone: function() {
      return new this.constructor(this.image).copy(this);
    },
    isVideoTexture: true,
    update: function() {
      const video = this.image;
      const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
      if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
        this.needsUpdate = true;
      }
    }
  });
  function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {width, height};
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
  CompressedTexture.prototype = Object.create(Texture.prototype);
  CompressedTexture.prototype.constructor = CompressedTexture;
  CompressedTexture.prototype.isCompressedTexture = true;
  function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }
  CanvasTexture.prototype = Object.create(Texture.prototype);
  CanvasTexture.prototype.constructor = CanvasTexture;
  CanvasTexture.prototype.isCanvasTexture = true;
  function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat)
      type = UnsignedShortType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {width, height};
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
  DepthTexture.prototype = Object.create(Texture.prototype);
  DepthTexture.prototype.constructor = DepthTexture;
  DepthTexture.prototype.isDepthTexture = true;
  var _geometryId = 0;
  var _m1$3 = new Matrix4();
  var _obj$1 = new Object3D();
  var _offset$1 = new Vector3();
  function Geometry() {
    Object.defineProperty(this, "id", {value: _geometryId += 2});
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }
  Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Geometry,
    isGeometry: true,
    applyMatrix4: function(matrix) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      for (let i = 0, il = this.vertices.length; i < il; i++) {
        const vertex = this.vertices[i];
        vertex.applyMatrix4(matrix);
      }
      for (let i = 0, il = this.faces.length; i < il; i++) {
        const face = this.faces[i];
        face.normal.applyMatrix3(normalMatrix).normalize();
        for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {
          face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
        }
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      this.verticesNeedUpdate = true;
      this.normalsNeedUpdate = true;
      return this;
    },
    rotateX: function(angle) {
      _m1$3.makeRotationX(angle);
      this.applyMatrix4(_m1$3);
      return this;
    },
    rotateY: function(angle) {
      _m1$3.makeRotationY(angle);
      this.applyMatrix4(_m1$3);
      return this;
    },
    rotateZ: function(angle) {
      _m1$3.makeRotationZ(angle);
      this.applyMatrix4(_m1$3);
      return this;
    },
    translate: function(x, y, z) {
      _m1$3.makeTranslation(x, y, z);
      this.applyMatrix4(_m1$3);
      return this;
    },
    scale: function(x, y, z) {
      _m1$3.makeScale(x, y, z);
      this.applyMatrix4(_m1$3);
      return this;
    },
    lookAt: function(vector) {
      _obj$1.lookAt(vector);
      _obj$1.updateMatrix();
      this.applyMatrix4(_obj$1.matrix);
      return this;
    },
    fromBufferGeometry: function(geometry) {
      const scope = this;
      const index = geometry.index !== null ? geometry.index : void 0;
      const attributes = geometry.attributes;
      if (attributes.position === void 0) {
        console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");
        return this;
      }
      const position = attributes.position;
      const normal = attributes.normal;
      const color = attributes.color;
      const uv = attributes.uv;
      const uv2 = attributes.uv2;
      if (uv2 !== void 0)
        this.faceVertexUvs[1] = [];
      for (let i = 0; i < position.count; i++) {
        scope.vertices.push(new Vector3().fromBufferAttribute(position, i));
        if (color !== void 0) {
          scope.colors.push(new Color().fromBufferAttribute(color, i));
        }
      }
      function addFace(a, b, c, materialIndex) {
        const vertexColors = color === void 0 ? [] : [
          scope.colors[a].clone(),
          scope.colors[b].clone(),
          scope.colors[c].clone()
        ];
        const vertexNormals = normal === void 0 ? [] : [
          new Vector3().fromBufferAttribute(normal, a),
          new Vector3().fromBufferAttribute(normal, b),
          new Vector3().fromBufferAttribute(normal, c)
        ];
        const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
        scope.faces.push(face);
        if (uv !== void 0) {
          scope.faceVertexUvs[0].push([
            new Vector2().fromBufferAttribute(uv, a),
            new Vector2().fromBufferAttribute(uv, b),
            new Vector2().fromBufferAttribute(uv, c)
          ]);
        }
        if (uv2 !== void 0) {
          scope.faceVertexUvs[1].push([
            new Vector2().fromBufferAttribute(uv2, a),
            new Vector2().fromBufferAttribute(uv2, b),
            new Vector2().fromBufferAttribute(uv2, c)
          ]);
        }
      }
      const groups = geometry.groups;
      if (groups.length > 0) {
        for (let i = 0; i < groups.length; i++) {
          const group2 = groups[i];
          const start = group2.start;
          const count = group2.count;
          for (let j = start, jl = start + count; j < jl; j += 3) {
            if (index !== void 0) {
              addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group2.materialIndex);
            } else {
              addFace(j, j + 1, j + 2, group2.materialIndex);
            }
          }
        }
      } else {
        if (index !== void 0) {
          for (let i = 0; i < index.count; i += 3) {
            addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));
          }
        } else {
          for (let i = 0; i < position.count; i += 3) {
            addFace(i, i + 1, i + 2);
          }
        }
      }
      this.computeFaceNormals();
      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }
      return this;
    },
    center: function() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset$1).negate();
      this.translate(_offset$1.x, _offset$1.y, _offset$1.z);
      return this;
    },
    normalize: function() {
      this.computeBoundingSphere();
      const center = this.boundingSphere.center;
      const radius = this.boundingSphere.radius;
      const s = radius === 0 ? 1 : 1 / radius;
      const matrix = new Matrix4();
      matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
      this.applyMatrix4(matrix);
      return this;
    },
    computeFaceNormals: function() {
      const cb = new Vector3(), ab = new Vector3();
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const vA = this.vertices[face.a];
        const vB = this.vertices[face.b];
        const vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        cb.normalize();
        face.normal.copy(cb);
      }
    },
    computeVertexNormals: function(areaWeighted = true) {
      const vertices = new Array(this.vertices.length);
      for (let v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v] = new Vector3();
      }
      if (areaWeighted) {
        const cb = new Vector3(), ab = new Vector3();
        for (let f = 0, fl = this.faces.length; f < fl; f++) {
          const face = this.faces[f];
          const vA = this.vertices[face.a];
          const vB = this.vertices[face.b];
          const vC = this.vertices[face.c];
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          cb.cross(ab);
          vertices[face.a].add(cb);
          vertices[face.b].add(cb);
          vertices[face.c].add(cb);
        }
      } else {
        this.computeFaceNormals();
        for (let f = 0, fl = this.faces.length; f < fl; f++) {
          const face = this.faces[f];
          vertices[face.a].add(face.normal);
          vertices[face.b].add(face.normal);
          vertices[face.c].add(face.normal);
        }
      }
      for (let v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v].normalize();
      }
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const vertexNormals = face.vertexNormals;
        if (vertexNormals.length === 3) {
          vertexNormals[0].copy(vertices[face.a]);
          vertexNormals[1].copy(vertices[face.b]);
          vertexNormals[2].copy(vertices[face.c]);
        } else {
          vertexNormals[0] = vertices[face.a].clone();
          vertexNormals[1] = vertices[face.b].clone();
          vertexNormals[2] = vertices[face.c].clone();
        }
      }
      if (this.faces.length > 0) {
        this.normalsNeedUpdate = true;
      }
    },
    computeFlatVertexNormals: function() {
      this.computeFaceNormals();
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const vertexNormals = face.vertexNormals;
        if (vertexNormals.length === 3) {
          vertexNormals[0].copy(face.normal);
          vertexNormals[1].copy(face.normal);
          vertexNormals[2].copy(face.normal);
        } else {
          vertexNormals[0] = face.normal.clone();
          vertexNormals[1] = face.normal.clone();
          vertexNormals[2] = face.normal.clone();
        }
      }
      if (this.faces.length > 0) {
        this.normalsNeedUpdate = true;
      }
    },
    computeMorphNormals: function() {
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        if (!face.__originalFaceNormal) {
          face.__originalFaceNormal = face.normal.clone();
        } else {
          face.__originalFaceNormal.copy(face.normal);
        }
        if (!face.__originalVertexNormals)
          face.__originalVertexNormals = [];
        for (let i = 0, il = face.vertexNormals.length; i < il; i++) {
          if (!face.__originalVertexNormals[i]) {
            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
          } else {
            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
          }
        }
      }
      const tmpGeo = new Geometry();
      tmpGeo.faces = this.faces;
      for (let i = 0, il = this.morphTargets.length; i < il; i++) {
        if (!this.morphNormals[i]) {
          this.morphNormals[i] = {};
          this.morphNormals[i].faceNormals = [];
          this.morphNormals[i].vertexNormals = [];
          const dstNormalsFace = this.morphNormals[i].faceNormals;
          const dstNormalsVertex = this.morphNormals[i].vertexNormals;
          for (let f = 0, fl = this.faces.length; f < fl; f++) {
            const faceNormal = new Vector3();
            const vertexNormals = {a: new Vector3(), b: new Vector3(), c: new Vector3()};
            dstNormalsFace.push(faceNormal);
            dstNormalsVertex.push(vertexNormals);
          }
        }
        const morphNormals = this.morphNormals[i];
        tmpGeo.vertices = this.morphTargets[i].vertices;
        tmpGeo.computeFaceNormals();
        tmpGeo.computeVertexNormals();
        for (let f = 0, fl = this.faces.length; f < fl; f++) {
          const face = this.faces[f];
          const faceNormal = morphNormals.faceNormals[f];
          const vertexNormals = morphNormals.vertexNormals[f];
          faceNormal.copy(face.normal);
          vertexNormals.a.copy(face.vertexNormals[0]);
          vertexNormals.b.copy(face.vertexNormals[1]);
          vertexNormals.c.copy(face.vertexNormals[2]);
        }
      }
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        face.normal = face.__originalFaceNormal;
        face.vertexNormals = face.__originalVertexNormals;
      }
    },
    computeBoundingBox: function() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(geometry, matrix, materialIndexOffset = 0) {
      if (!(geometry && geometry.isGeometry)) {
        console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
        return;
      }
      let normalMatrix;
      const vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
      if (matrix !== void 0) {
        normalMatrix = new Matrix3().getNormalMatrix(matrix);
      }
      for (let i = 0, il = vertices2.length; i < il; i++) {
        const vertex = vertices2[i];
        const vertexCopy = vertex.clone();
        if (matrix !== void 0)
          vertexCopy.applyMatrix4(matrix);
        vertices1.push(vertexCopy);
      }
      for (let i = 0, il = colors2.length; i < il; i++) {
        colors1.push(colors2[i].clone());
      }
      for (let i = 0, il = faces2.length; i < il; i++) {
        const face = faces2[i];
        let normal, color;
        const faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
        const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
        faceCopy.normal.copy(face.normal);
        if (normalMatrix !== void 0) {
          faceCopy.normal.applyMatrix3(normalMatrix).normalize();
        }
        for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {
          normal = faceVertexNormals[j].clone();
          if (normalMatrix !== void 0) {
            normal.applyMatrix3(normalMatrix).normalize();
          }
          faceCopy.vertexNormals.push(normal);
        }
        faceCopy.color.copy(face.color);
        for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {
          color = faceVertexColors[j];
          faceCopy.vertexColors.push(color.clone());
        }
        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
        faces1.push(faceCopy);
      }
      for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {
        const faceVertexUvs2 = geometry.faceVertexUvs[i];
        if (this.faceVertexUvs[i] === void 0)
          this.faceVertexUvs[i] = [];
        for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {
          const uvs2 = faceVertexUvs2[j], uvsCopy = [];
          for (let k = 0, kl = uvs2.length; k < kl; k++) {
            uvsCopy.push(uvs2[k].clone());
          }
          this.faceVertexUvs[i].push(uvsCopy);
        }
      }
    },
    mergeMesh: function(mesh) {
      if (!(mesh && mesh.isMesh)) {
        console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
        return;
      }
      if (mesh.matrixAutoUpdate)
        mesh.updateMatrix();
      this.merge(mesh.geometry, mesh.matrix);
    },
    mergeVertices: function(precisionPoints = 4) {
      const verticesMap = {};
      const unique = [], changes = [];
      const precision = Math.pow(10, precisionPoints);
      for (let i = 0, il = this.vertices.length; i < il; i++) {
        const v = this.vertices[i];
        const key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
        if (verticesMap[key] === void 0) {
          verticesMap[key] = i;
          unique.push(this.vertices[i]);
          changes[i] = unique.length - 1;
        } else {
          changes[i] = changes[verticesMap[key]];
        }
      }
      const faceIndicesToRemove = [];
      for (let i = 0, il = this.faces.length; i < il; i++) {
        const face = this.faces[i];
        face.a = changes[face.a];
        face.b = changes[face.b];
        face.c = changes[face.c];
        const indices = [face.a, face.b, face.c];
        for (let n = 0; n < 3; n++) {
          if (indices[n] === indices[(n + 1) % 3]) {
            faceIndicesToRemove.push(i);
            break;
          }
        }
      }
      for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {
        const idx = faceIndicesToRemove[i];
        this.faces.splice(idx, 1);
        for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
          this.faceVertexUvs[j].splice(idx, 1);
        }
      }
      const diff = this.vertices.length - unique.length;
      this.vertices = unique;
      return diff;
    },
    setFromPoints: function(points) {
      this.vertices = [];
      for (let i = 0, l = points.length; i < l; i++) {
        const point = points[i];
        this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function() {
      const faces = this.faces;
      const length = faces.length;
      for (let i = 0; i < length; i++) {
        faces[i]._id = i;
      }
      function materialIndexSort(a, b) {
        return a.materialIndex - b.materialIndex;
      }
      faces.sort(materialIndexSort);
      const uvs1 = this.faceVertexUvs[0];
      const uvs2 = this.faceVertexUvs[1];
      let newUvs1, newUvs2;
      if (uvs1 && uvs1.length === length)
        newUvs1 = [];
      if (uvs2 && uvs2.length === length)
        newUvs2 = [];
      for (let i = 0; i < length; i++) {
        const id = faces[i]._id;
        if (newUvs1)
          newUvs1.push(uvs1[id]);
        if (newUvs2)
          newUvs2.push(uvs2[id]);
      }
      if (newUvs1)
        this.faceVertexUvs[0] = newUvs1;
      if (newUvs2)
        this.faceVertexUvs[1] = newUvs2;
    },
    toJSON: function() {
      const data = {
        metadata: {
          version: 4.5,
          type: "Geometry",
          generator: "Geometry.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (this.parameters !== void 0) {
        const parameters = this.parameters;
        for (const key in parameters) {
          if (parameters[key] !== void 0)
            data[key] = parameters[key];
        }
        return data;
      }
      const vertices = [];
      for (let i = 0; i < this.vertices.length; i++) {
        const vertex = this.vertices[i];
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
      const faces = [];
      const normals = [];
      const normalsHash = {};
      const colors = [];
      const colorsHash = {};
      const uvs = [];
      const uvsHash = {};
      for (let i = 0; i < this.faces.length; i++) {
        const face = this.faces[i];
        const hasMaterial = true;
        const hasFaceUv = false;
        const hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;
        const hasFaceNormal = face.normal.length() > 0;
        const hasFaceVertexNormal = face.vertexNormals.length > 0;
        const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
        const hasFaceVertexColor = face.vertexColors.length > 0;
        let faceType = 0;
        faceType = setBit(faceType, 0, 0);
        faceType = setBit(faceType, 1, hasMaterial);
        faceType = setBit(faceType, 2, hasFaceUv);
        faceType = setBit(faceType, 3, hasFaceVertexUv);
        faceType = setBit(faceType, 4, hasFaceNormal);
        faceType = setBit(faceType, 5, hasFaceVertexNormal);
        faceType = setBit(faceType, 6, hasFaceColor);
        faceType = setBit(faceType, 7, hasFaceVertexColor);
        faces.push(faceType);
        faces.push(face.a, face.b, face.c);
        faces.push(face.materialIndex);
        if (hasFaceVertexUv) {
          const faceVertexUvs = this.faceVertexUvs[0][i];
          faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
        }
        if (hasFaceNormal) {
          faces.push(getNormalIndex(face.normal));
        }
        if (hasFaceVertexNormal) {
          const vertexNormals = face.vertexNormals;
          faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
        }
        if (hasFaceColor) {
          faces.push(getColorIndex(face.color));
        }
        if (hasFaceVertexColor) {
          const vertexColors = face.vertexColors;
          faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
        }
      }
      function setBit(value, position, enabled) {
        return enabled ? value | 1 << position : value & ~(1 << position);
      }
      function getNormalIndex(normal) {
        const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
        if (normalsHash[hash] !== void 0) {
          return normalsHash[hash];
        }
        normalsHash[hash] = normals.length / 3;
        normals.push(normal.x, normal.y, normal.z);
        return normalsHash[hash];
      }
      function getColorIndex(color) {
        const hash = color.r.toString() + color.g.toString() + color.b.toString();
        if (colorsHash[hash] !== void 0) {
          return colorsHash[hash];
        }
        colorsHash[hash] = colors.length;
        colors.push(color.getHex());
        return colorsHash[hash];
      }
      function getUvIndex(uv) {
        const hash = uv.x.toString() + uv.y.toString();
        if (uvsHash[hash] !== void 0) {
          return uvsHash[hash];
        }
        uvsHash[hash] = uvs.length / 2;
        uvs.push(uv.x, uv.y);
        return uvsHash[hash];
      }
      data.data = {};
      data.data.vertices = vertices;
      data.data.normals = normals;
      if (colors.length > 0)
        data.data.colors = colors;
      if (uvs.length > 0)
        data.data.uvs = [uvs];
      data.data.faces = faces;
      return data;
    },
    clone: function() {
      return new Geometry().copy(this);
    },
    copy: function(source) {
      this.vertices = [];
      this.colors = [];
      this.faces = [];
      this.faceVertexUvs = [[]];
      this.morphTargets = [];
      this.morphNormals = [];
      this.skinWeights = [];
      this.skinIndices = [];
      this.lineDistances = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.name = source.name;
      const vertices = source.vertices;
      for (let i = 0, il = vertices.length; i < il; i++) {
        this.vertices.push(vertices[i].clone());
      }
      const colors = source.colors;
      for (let i = 0, il = colors.length; i < il; i++) {
        this.colors.push(colors[i].clone());
      }
      const faces = source.faces;
      for (let i = 0, il = faces.length; i < il; i++) {
        this.faces.push(faces[i].clone());
      }
      for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {
        const faceVertexUvs = source.faceVertexUvs[i];
        if (this.faceVertexUvs[i] === void 0) {
          this.faceVertexUvs[i] = [];
        }
        for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {
          const uvs = faceVertexUvs[j], uvsCopy = [];
          for (let k = 0, kl = uvs.length; k < kl; k++) {
            const uv = uvs[k];
            uvsCopy.push(uv.clone());
          }
          this.faceVertexUvs[i].push(uvsCopy);
        }
      }
      const morphTargets = source.morphTargets;
      for (let i = 0, il = morphTargets.length; i < il; i++) {
        const morphTarget = {};
        morphTarget.name = morphTargets[i].name;
        if (morphTargets[i].vertices !== void 0) {
          morphTarget.vertices = [];
          for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
            morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
          }
        }
        if (morphTargets[i].normals !== void 0) {
          morphTarget.normals = [];
          for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
            morphTarget.normals.push(morphTargets[i].normals[j].clone());
          }
        }
        this.morphTargets.push(morphTarget);
      }
      const morphNormals = source.morphNormals;
      for (let i = 0, il = morphNormals.length; i < il; i++) {
        const morphNormal = {};
        if (morphNormals[i].vertexNormals !== void 0) {
          morphNormal.vertexNormals = [];
          for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
            const srcVertexNormal = morphNormals[i].vertexNormals[j];
            const destVertexNormal = {};
            destVertexNormal.a = srcVertexNormal.a.clone();
            destVertexNormal.b = srcVertexNormal.b.clone();
            destVertexNormal.c = srcVertexNormal.c.clone();
            morphNormal.vertexNormals.push(destVertexNormal);
          }
        }
        if (morphNormals[i].faceNormals !== void 0) {
          morphNormal.faceNormals = [];
          for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
            morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
          }
        }
        this.morphNormals.push(morphNormal);
      }
      const skinWeights = source.skinWeights;
      for (let i = 0, il = skinWeights.length; i < il; i++) {
        this.skinWeights.push(skinWeights[i].clone());
      }
      const skinIndices = source.skinIndices;
      for (let i = 0, il = skinIndices.length; i < il; i++) {
        this.skinIndices.push(skinIndices[i].clone());
      }
      const lineDistances = source.lineDistances;
      for (let i = 0, il = lineDistances.length; i < il; i++) {
        this.lineDistances.push(lineDistances[i]);
      }
      const boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }
      const boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }
      this.elementsNeedUpdate = source.elementsNeedUpdate;
      this.verticesNeedUpdate = source.verticesNeedUpdate;
      this.uvsNeedUpdate = source.uvsNeedUpdate;
      this.normalsNeedUpdate = source.normalsNeedUpdate;
      this.colorsNeedUpdate = source.colorsNeedUpdate;
      this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
      this.groupsNeedUpdate = source.groupsNeedUpdate;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({type: "dispose"});
    }
  });
  var _v0$2 = new Vector3();
  var _v1$5 = new Vector3();
  var _normal$1 = new Vector3();
  var _triangle = new Triangle();
  var Earcut = {
    triangulate: function(data, holeIndices, dim) {
      dim = dim || 2;
      const hasHoles = holeIndices && holeIndices.length;
      const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      let outerNode = linkedList(data, 0, outerLen, dim, true);
      const triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      let minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (let i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
      return triangles;
    }
  };
  function linkedList(data, start, end, dim, clockwise) {
    let i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i = start; i < end; i += dim)
        last = insertNode(i, data[i], data[i + 1], last);
    } else {
      for (i = end - dim; i >= start; i -= dim)
        last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p = start, again;
    do {
      again = false;
      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next)
          break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    let p = ear.next.next;
    while (p !== ear.prev) {
      if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    while (p && p.z >= minZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
      const a = p.prev, b = p.next.next;
      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim);
        triangles.push(p.i / dim);
        triangles.push(b.i / dim);
        removeNode(p);
        removeNode(p.next);
        p = start = b;
      }
      p = p.next;
    } while (p !== start);
    return filterPoints(p);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a = start;
    do {
      let b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          let c = splitPolygon(a, b);
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);
          earcutLinked(a, triangles, dim, minX, minY, invSize);
          earcutLinked(c, triangles, dim, minX, minY, invSize);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i, len, start, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i = 0; i < queue.length; i++) {
      eliminateHole(queue[i], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
  }
  function compareX(a, b) {
    return a.x - b.x;
  }
  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
      const b = splitPolygon(outerNode, hole);
      filterPoints(outerNode, outerNode.next);
      filterPoints(b, b.next);
    }
  }
  function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          if (x === hx) {
            if (hy === p.y)
              return p;
            if (hy === p.next.y)
              return p.next;
          }
          m = p.x < p.next.x ? p : p.next;
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m)
      return null;
    if (hx === qx)
      return m;
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x);
        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
      if (p.z === null)
        p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }
  function sortLinked(list) {
    let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x, y, minX, minY, invSize) {
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  }
  function getLeftmost(start) {
    let p = start, leftmost = start;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
        leftmost = p;
      p = p.next;
    } while (p !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
    return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
  }
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
  }
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a, b) {
    let p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
        return true;
      p = p.next;
    } while (p !== a);
    return false;
  }
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }
  function middleInside(a, b) {
    let p = a, inside = false;
    const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
    do {
      if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
        inside = !inside;
      p = p.next;
    } while (p !== a);
    return inside;
  }
  function splitPolygon(a, b) {
    const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i, x, y, last) {
    const p = new Node(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
      p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
      p.nextZ.prevZ = p.prevZ;
  }
  function Node(i, x, y) {
    this.i = i;
    this.x = x;
    this.y = y;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  function signedArea(data, start, end, dim) {
    let sum = 0;
    for (let i = start, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  }
  var ShapeUtils = {
    area: function(contour) {
      const n = contour.length;
      let a = 0;
      for (let p = n - 1, q = 0; q < n; p = q++) {
        a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
      }
      return a * 0.5;
    },
    isClockWise: function(pts) {
      return ShapeUtils.area(pts) < 0;
    },
    triangulateShape: function(contour, holes) {
      const vertices = [];
      const holeIndices = [];
      const faces = [];
      removeDupEndPts(contour);
      addContour(vertices, contour);
      let holeIndex = contour.length;
      holes.forEach(removeDupEndPts);
      for (let i = 0; i < holes.length; i++) {
        holeIndices.push(holeIndex);
        holeIndex += holes[i].length;
        addContour(vertices, holes[i]);
      }
      const triangles = Earcut.triangulate(vertices, holeIndices);
      for (let i = 0; i < triangles.length; i += 3) {
        faces.push(triangles.slice(i, i + 3));
      }
      return faces;
    }
  };
  function removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) {
      points.pop();
    }
  }
  function addContour(vertices, contour) {
    for (let i = 0; i < contour.length; i++) {
      vertices.push(contour[i].x);
      vertices.push(contour[i].y);
    }
  }
  var ExtrudeBufferGeometry = class extends BufferGeometry {
    constructor(shapes, options) {
      super();
      this.type = "ExtrudeBufferGeometry";
      this.parameters = {
        shapes,
        options
      };
      shapes = Array.isArray(shapes) ? shapes : [shapes];
      const scope = this;
      const verticesArray = [];
      const uvArray = [];
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        addShape(shape);
      }
      this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
      this.computeVertexNormals();
      function addShape(shape) {
        const placeholder = [];
        const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
        const steps = options.steps !== void 0 ? options.steps : 1;
        let depth = options.depth !== void 0 ? options.depth : 100;
        let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
        let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 6;
        let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 2;
        let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
        let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
        const extrudePath = options.extrudePath;
        const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
        if (options.amount !== void 0) {
          console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
          depth = options.amount;
        }
        let extrudePts, extrudeByPath = false;
        let splineTube, binormal, normal, position2;
        if (extrudePath) {
          extrudePts = extrudePath.getSpacedPoints(steps);
          extrudeByPath = true;
          bevelEnabled = false;
          splineTube = extrudePath.computeFrenetFrames(steps, false);
          binormal = new Vector3();
          normal = new Vector3();
          position2 = new Vector3();
        }
        if (!bevelEnabled) {
          bevelSegments = 0;
          bevelThickness = 0;
          bevelSize = 0;
          bevelOffset = 0;
        }
        const shapePoints = shape.extractPoints(curveSegments);
        let vertices = shapePoints.shape;
        const holes = shapePoints.holes;
        const reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
          vertices = vertices.reverse();
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            if (ShapeUtils.isClockWise(ahole)) {
              holes[h] = ahole.reverse();
            }
          }
        }
        const faces = ShapeUtils.triangulateShape(vertices, holes);
        const contour = vertices;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          vertices = vertices.concat(ahole);
        }
        function scalePt2(pt, vec, size) {
          if (!vec)
            console.error("THREE.ExtrudeGeometry: vec does not exist");
          return vec.clone().multiplyScalar(size).add(pt);
        }
        const vlen = vertices.length, flen = faces.length;
        function getBevelVec(inPt, inPrev, inNext) {
          let v_trans_x, v_trans_y, shrink_by;
          const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
          const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
          const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
          const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
          if (Math.abs(collinear0) > Number.EPSILON) {
            const v_prev_len = Math.sqrt(v_prev_lensq);
            const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
            const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
            const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
            const ptNextShift_x = inNext.x - v_next_y / v_next_len;
            const ptNextShift_y = inNext.y + v_next_x / v_next_len;
            const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
            v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
            v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
            const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
            if (v_trans_lensq <= 2) {
              return new Vector2(v_trans_x, v_trans_y);
            } else {
              shrink_by = Math.sqrt(v_trans_lensq / 2);
            }
          } else {
            let direction_eq = false;
            if (v_prev_x > Number.EPSILON) {
              if (v_next_x > Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (v_prev_x < -Number.EPSILON) {
                if (v_next_x < -Number.EPSILON) {
                  direction_eq = true;
                }
              } else {
                if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                  direction_eq = true;
                }
              }
            }
            if (direction_eq) {
              v_trans_x = -v_prev_y;
              v_trans_y = v_prev_x;
              shrink_by = Math.sqrt(v_prev_lensq);
            } else {
              v_trans_x = v_prev_x;
              v_trans_y = v_prev_y;
              shrink_by = Math.sqrt(v_prev_lensq / 2);
            }
          }
          return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        const contourMovements = [];
        for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
        }
        const holesMovements = [];
        let oneHoleMovements, verticesMovements = contourMovements.concat();
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = [];
          for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
            if (j === il)
              j = 0;
            if (k === il)
              k = 0;
            oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
          }
          holesMovements.push(oneHoleMovements);
          verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        for (let b = 0; b < bevelSegments; b++) {
          const t = b / bevelSegments;
          const z = bevelThickness * Math.cos(t * Math.PI / 2);
          const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
          for (let i = 0, il = contour.length; i < il; i++) {
            const vert = scalePt2(contour[i], contourMovements[i], bs2);
            v(vert.x, vert.y, -z);
          }
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            oneHoleMovements = holesMovements[h];
            for (let i = 0, il = ahole.length; i < il; i++) {
              const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
              v(vert.x, vert.y, -z);
            }
          }
        }
        const bs = bevelSize + bevelOffset;
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, 0);
          } else {
            normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
            position2.copy(extrudePts[0]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
        for (let s = 1; s <= steps; s++) {
          for (let i = 0; i < vlen; i++) {
            const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth / steps * s);
            } else {
              normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
              binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
              position2.copy(extrudePts[s]).add(normal).add(binormal);
              v(position2.x, position2.y, position2.z);
            }
          }
        }
        for (let b = bevelSegments - 1; b >= 0; b--) {
          const t = b / bevelSegments;
          const z = bevelThickness * Math.cos(t * Math.PI / 2);
          const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
          for (let i = 0, il = contour.length; i < il; i++) {
            const vert = scalePt2(contour[i], contourMovements[i], bs2);
            v(vert.x, vert.y, depth + z);
          }
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            oneHoleMovements = holesMovements[h];
            for (let i = 0, il = ahole.length; i < il; i++) {
              const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
              if (!extrudeByPath) {
                v(vert.x, vert.y, depth + z);
              } else {
                v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
              }
            }
          }
        }
        buildLidFaces();
        buildSideFaces();
        function buildLidFaces() {
          const start = verticesArray.length / 3;
          if (bevelEnabled) {
            let layer = 0;
            let offset = vlen * layer;
            for (let i = 0; i < flen; i++) {
              const face = faces[i];
              f3(face[2] + offset, face[1] + offset, face[0] + offset);
            }
            layer = steps + bevelSegments * 2;
            offset = vlen * layer;
            for (let i = 0; i < flen; i++) {
              const face = faces[i];
              f3(face[0] + offset, face[1] + offset, face[2] + offset);
            }
          } else {
            for (let i = 0; i < flen; i++) {
              const face = faces[i];
              f3(face[2], face[1], face[0]);
            }
            for (let i = 0; i < flen; i++) {
              const face = faces[i];
              f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
            }
          }
          scope.addGroup(start, verticesArray.length / 3 - start, 0);
        }
        function buildSideFaces() {
          const start = verticesArray.length / 3;
          let layeroffset = 0;
          sidewalls(contour, layeroffset);
          layeroffset += contour.length;
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            sidewalls(ahole, layeroffset);
            layeroffset += ahole.length;
          }
          scope.addGroup(start, verticesArray.length / 3 - start, 1);
        }
        function sidewalls(contour2, layeroffset) {
          let i = contour2.length;
          while (--i >= 0) {
            const j = i;
            let k = i - 1;
            if (k < 0)
              k = contour2.length - 1;
            for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
              const slen1 = vlen * s;
              const slen2 = vlen * (s + 1);
              const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
              f4(a, b, c, d);
            }
          }
        }
        function v(x, y, z) {
          placeholder.push(x);
          placeholder.push(y);
          placeholder.push(z);
        }
        function f3(a, b, c) {
          addVertex(a);
          addVertex(b);
          addVertex(c);
          const nextIndex = verticesArray.length / 3;
          const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
          addUV(uvs[0]);
          addUV(uvs[1]);
          addUV(uvs[2]);
        }
        function f4(a, b, c, d) {
          addVertex(a);
          addVertex(b);
          addVertex(d);
          addVertex(b);
          addVertex(c);
          addVertex(d);
          const nextIndex = verticesArray.length / 3;
          const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
          addUV(uvs[0]);
          addUV(uvs[1]);
          addUV(uvs[3]);
          addUV(uvs[1]);
          addUV(uvs[2]);
          addUV(uvs[3]);
        }
        function addVertex(index) {
          verticesArray.push(placeholder[index * 3 + 0]);
          verticesArray.push(placeholder[index * 3 + 1]);
          verticesArray.push(placeholder[index * 3 + 2]);
        }
        function addUV(vector2) {
          uvArray.push(vector2.x);
          uvArray.push(vector2.y);
        }
      }
    }
    toJSON() {
      const data = BufferGeometry.prototype.toJSON.call(this);
      const shapes = this.parameters.shapes;
      const options = this.parameters.options;
      return toJSON(shapes, options, data);
    }
  };
  var WorldUVGenerator = {
    generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
      const a_x = vertices[indexA * 3];
      const a_y = vertices[indexA * 3 + 1];
      const b_x = vertices[indexB * 3];
      const b_y = vertices[indexB * 3 + 1];
      const c_x = vertices[indexC * 3];
      const c_y = vertices[indexC * 3 + 1];
      return [
        new Vector2(a_x, a_y),
        new Vector2(b_x, b_y),
        new Vector2(c_x, c_y)
      ];
    },
    generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
      const a_x = vertices[indexA * 3];
      const a_y = vertices[indexA * 3 + 1];
      const a_z = vertices[indexA * 3 + 2];
      const b_x = vertices[indexB * 3];
      const b_y = vertices[indexB * 3 + 1];
      const b_z = vertices[indexB * 3 + 2];
      const c_x = vertices[indexC * 3];
      const c_y = vertices[indexC * 3 + 1];
      const c_z = vertices[indexC * 3 + 2];
      const d_x = vertices[indexD * 3];
      const d_y = vertices[indexD * 3 + 1];
      const d_z = vertices[indexD * 3 + 2];
      if (Math.abs(a_y - b_y) < 0.01) {
        return [
          new Vector2(a_x, 1 - a_z),
          new Vector2(b_x, 1 - b_z),
          new Vector2(c_x, 1 - c_z),
          new Vector2(d_x, 1 - d_z)
        ];
      } else {
        return [
          new Vector2(a_y, 1 - a_z),
          new Vector2(b_y, 1 - b_z),
          new Vector2(c_y, 1 - c_z),
          new Vector2(d_y, 1 - d_z)
        ];
      }
    }
  };
  function toJSON(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    if (options.extrudePath !== void 0)
      data.options.extrudePath = options.extrudePath.toJSON();
    return data;
  }
  var ExtrudeGeometry = class extends Geometry {
    constructor(shapes, options) {
      super();
      this.type = "ExtrudeGeometry";
      this.parameters = {
        shapes,
        options
      };
      this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
      this.mergeVertices();
    }
    toJSON() {
      const data = super.toJSON();
      const shapes = this.parameters.shapes;
      const options = this.parameters.options;
      return toJSON$1(shapes, options, data);
    }
  };
  function toJSON$1(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    if (options.extrudePath !== void 0)
      data.options.extrudePath = options.extrudePath.toJSON();
    return data;
  }
  function ParametricBufferGeometry(func, slices, stacks) {
    BufferGeometry.call(this);
    this.type = "ParametricBufferGeometry";
    this.parameters = {
      func,
      slices,
      stacks
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const EPS = 1e-5;
    const normal = new Vector3();
    const p0 = new Vector3(), p1 = new Vector3();
    const pu = new Vector3(), pv = new Vector3();
    if (func.length < 3) {
      console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    }
    const sliceCount = slices + 1;
    for (let i = 0; i <= stacks; i++) {
      const v = i / stacks;
      for (let j = 0; j <= slices; j++) {
        const u = j / slices;
        func(u, v, p0);
        vertices.push(p0.x, p0.y, p0.z);
        if (u - EPS >= 0) {
          func(u - EPS, v, p1);
          pu.subVectors(p0, p1);
        } else {
          func(u + EPS, v, p1);
          pu.subVectors(p1, p0);
        }
        if (v - EPS >= 0) {
          func(u, v - EPS, p1);
          pv.subVectors(p0, p1);
        } else {
          func(u, v + EPS, p1);
          pv.subVectors(p1, p0);
        }
        normal.crossVectors(pu, pv).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u, v);
      }
    }
    for (let i = 0; i < stacks; i++) {
      for (let j = 0; j < slices; j++) {
        const a = i * sliceCount + j;
        const b = i * sliceCount + j + 1;
        const c = (i + 1) * sliceCount + j + 1;
        const d = (i + 1) * sliceCount + j;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
  function ParametricGeometry(func, slices, stacks) {
    Geometry.call(this);
    this.type = "ParametricGeometry";
    this.parameters = {
      func,
      slices,
      stacks
    };
    this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
    this.mergeVertices();
  }
  ParametricGeometry.prototype = Object.create(Geometry.prototype);
  ParametricGeometry.prototype.constructor = ParametricGeometry;
  var ShapeBufferGeometry = class extends BufferGeometry {
    constructor(shapes, curveSegments = 12) {
      super();
      this.type = "ShapeBufferGeometry";
      this.parameters = {
        shapes,
        curveSegments
      };
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let groupStart = 0;
      let groupCount = 0;
      if (Array.isArray(shapes) === false) {
        addShape(shapes);
      } else {
        for (let i = 0; i < shapes.length; i++) {
          addShape(shapes[i]);
          this.addGroup(groupStart, groupCount, i);
          groupStart += groupCount;
          groupCount = 0;
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function addShape(shape) {
        const indexOffset = vertices.length / 3;
        const points = shape.extractPoints(curveSegments);
        let shapeVertices = points.shape;
        const shapeHoles = points.holes;
        if (ShapeUtils.isClockWise(shapeVertices) === false) {
          shapeVertices = shapeVertices.reverse();
        }
        for (let i = 0, l = shapeHoles.length; i < l; i++) {
          const shapeHole = shapeHoles[i];
          if (ShapeUtils.isClockWise(shapeHole) === true) {
            shapeHoles[i] = shapeHole.reverse();
          }
        }
        const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
        for (let i = 0, l = shapeHoles.length; i < l; i++) {
          const shapeHole = shapeHoles[i];
          shapeVertices = shapeVertices.concat(shapeHole);
        }
        for (let i = 0, l = shapeVertices.length; i < l; i++) {
          const vertex = shapeVertices[i];
          vertices.push(vertex.x, vertex.y, 0);
          normals.push(0, 0, 1);
          uvs.push(vertex.x, vertex.y);
        }
        for (let i = 0, l = faces.length; i < l; i++) {
          const face = faces[i];
          const a = face[0] + indexOffset;
          const b = face[1] + indexOffset;
          const c = face[2] + indexOffset;
          indices.push(a, b, c);
          groupCount += 3;
        }
      }
    }
    toJSON() {
      const data = BufferGeometry.prototype.toJSON.call(this);
      const shapes = this.parameters.shapes;
      return toJSON$2(shapes, data);
    }
  };
  function toJSON$2(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    return data;
  }
  var ShapeGeometry = class extends Geometry {
    constructor(shapes, curveSegments) {
      super();
      this.type = "ShapeGeometry";
      if (typeof curveSegments === "object") {
        console.warn("THREE.ShapeGeometry: Options parameter has been removed.");
        curveSegments = curveSegments.curveSegments;
      }
      this.parameters = {
        shapes,
        curveSegments
      };
      this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
      this.mergeVertices();
    }
    toJSON() {
      const data = Geometry.prototype.toJSON.call(this);
      const shapes = this.parameters.shapes;
      return toJSON$3(shapes, data);
    }
  };
  function toJSON$3(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    return data;
  }
  function ShadowMaterial(parameters) {
    Material.call(this);
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  ShadowMaterial.prototype = Object.create(Material.prototype);
  ShadowMaterial.prototype.constructor = ShadowMaterial;
  ShadowMaterial.prototype.isShadowMaterial = true;
  ShadowMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    return this;
  };
  function RawShaderMaterial(parameters) {
    ShaderMaterial.call(this, parameters);
    this.type = "RawShaderMaterial";
  }
  RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
  RawShaderMaterial.prototype.constructor = RawShaderMaterial;
  RawShaderMaterial.prototype.isRawShaderMaterial = true;
  function MeshStandardMaterial(parameters) {
    Material.call(this);
    this.defines = {STANDARD: ""};
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.vertexTangents = false;
    this.setValues(parameters);
  }
  MeshStandardMaterial.prototype = Object.create(Material.prototype);
  MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
  MeshStandardMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = {STANDARD: ""};
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.vertexTangents = source.vertexTangents;
    return this;
  };
  function MeshPhysicalMaterial(parameters) {
    MeshStandardMaterial.call(this);
    this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    };
    this.type = "MeshPhysicalMaterial";
    this.clearcoat = 0;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.reflectivity = 0.5;
    Object.defineProperty(this, "ior", {
      get: function() {
        return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
      },
      set: function(ior) {
        this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
      }
    });
    this.sheen = null;
    this.transmission = 0;
    this.transmissionMap = null;
    this.setValues(parameters);
  }
  MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
  MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
  MeshPhysicalMaterial.prototype.copy = function(source) {
    MeshStandardMaterial.prototype.copy.call(this, source);
    this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    };
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.reflectivity = source.reflectivity;
    if (source.sheen) {
      this.sheen = (this.sheen || new Color()).copy(source.sheen);
    } else {
      this.sheen = null;
    }
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    return this;
  };
  function MeshPhongMaterial(parameters) {
    Material.call(this);
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  MeshPhongMaterial.prototype = Object.create(Material.prototype);
  MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
  MeshPhongMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };
  function MeshToonMaterial(parameters) {
    Material.call(this);
    this.defines = {TOON: ""};
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  MeshToonMaterial.prototype = Object.create(Material.prototype);
  MeshToonMaterial.prototype.constructor = MeshToonMaterial;
  MeshToonMaterial.prototype.isMeshToonMaterial = true;
  MeshToonMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };
  function MeshNormalMaterial(parameters) {
    Material.call(this);
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  MeshNormalMaterial.prototype = Object.create(Material.prototype);
  MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
  MeshNormalMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };
  function MeshLambertMaterial(parameters) {
    Material.call(this);
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  MeshLambertMaterial.prototype = Object.create(Material.prototype);
  MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
  MeshLambertMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };
  function MeshMatcapMaterial(parameters) {
    Material.call(this);
    this.defines = {MATCAP: ""};
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  MeshMatcapMaterial.prototype = Object.create(Material.prototype);
  MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
  MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
  MeshMatcapMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = {MATCAP: ""};
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };
  function LineDashedMaterial(parameters) {
    LineBasicMaterial.call(this);
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
  LineDashedMaterial.prototype.constructor = LineDashedMaterial;
  LineDashedMaterial.prototype.isLineDashedMaterial = true;
  LineDashedMaterial.prototype.copy = function(source) {
    LineBasicMaterial.prototype.copy.call(this, source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  };
  var Materials = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ShadowMaterial,
    SpriteMaterial,
    RawShaderMaterial,
    ShaderMaterial,
    PointsMaterial,
    MeshPhysicalMaterial,
    MeshStandardMaterial,
    MeshPhongMaterial,
    MeshToonMaterial,
    MeshNormalMaterial,
    MeshLambertMaterial,
    MeshDepthMaterial,
    MeshDistanceMaterial,
    MeshBasicMaterial,
    MeshMatcapMaterial,
    LineDashedMaterial,
    LineBasicMaterial,
    Material
  });
  var AnimationUtils = {
    arraySlice: function(array, from, to) {
      if (AnimationUtils.isTypedArray(array)) {
        return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
      }
      return array.slice(from, to);
    },
    convertArray: function(array, type, forceClone) {
      if (!array || !forceClone && array.constructor === type)
        return array;
      if (typeof type.BYTES_PER_ELEMENT === "number") {
        return new type(array);
      }
      return Array.prototype.slice.call(array);
    },
    isTypedArray: function(object) {
      return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    getKeyframeOrder: function(times) {
      function compareTime(i, j) {
        return times[i] - times[j];
      }
      const n = times.length;
      const result = new Array(n);
      for (let i = 0; i !== n; ++i)
        result[i] = i;
      result.sort(compareTime);
      return result;
    },
    sortedArray: function(values, stride, order) {
      const nValues = values.length;
      const result = new values.constructor(nValues);
      for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
        const srcOffset = order[i] * stride;
        for (let j = 0; j !== stride; ++j) {
          result[dstOffset++] = values[srcOffset + j];
        }
      }
      return result;
    },
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
      let i = 1, key = jsonKeys[0];
      while (key !== void 0 && key[valuePropertyName] === void 0) {
        key = jsonKeys[i++];
      }
      if (key === void 0)
        return;
      let value = key[valuePropertyName];
      if (value === void 0)
        return;
      if (Array.isArray(value)) {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            values.push.apply(values, value);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      } else if (value.toArray !== void 0) {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            value.toArray(values, values.length);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      } else {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            values.push(value);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      }
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
      const clip = sourceClip.clone();
      clip.name = name;
      const tracks = [];
      for (let i = 0; i < clip.tracks.length; ++i) {
        const track = clip.tracks[i];
        const valueSize = track.getValueSize();
        const times = [];
        const values = [];
        for (let j = 0; j < track.times.length; ++j) {
          const frame = track.times[j] * fps;
          if (frame < startFrame || frame >= endFrame)
            continue;
          times.push(track.times[j]);
          for (let k = 0; k < valueSize; ++k) {
            values.push(track.values[j * valueSize + k]);
          }
        }
        if (times.length === 0)
          continue;
        track.times = AnimationUtils.convertArray(times, track.times.constructor);
        track.values = AnimationUtils.convertArray(values, track.values.constructor);
        tracks.push(track);
      }
      clip.tracks = tracks;
      let minStartTime = Infinity;
      for (let i = 0; i < clip.tracks.length; ++i) {
        if (minStartTime > clip.tracks[i].times[0]) {
          minStartTime = clip.tracks[i].times[0];
        }
      }
      for (let i = 0; i < clip.tracks.length; ++i) {
        clip.tracks[i].shift(-1 * minStartTime);
      }
      clip.resetDuration();
      return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
      if (fps <= 0)
        fps = 30;
      const numTracks = referenceClip.tracks.length;
      const referenceTime = referenceFrame / fps;
      for (let i = 0; i < numTracks; ++i) {
        const referenceTrack = referenceClip.tracks[i];
        const referenceTrackType = referenceTrack.ValueTypeName;
        if (referenceTrackType === "bool" || referenceTrackType === "string")
          continue;
        const targetTrack = targetClip.tracks.find(function(track) {
          return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
        });
        if (targetTrack === void 0)
          continue;
        let referenceOffset = 0;
        const referenceValueSize = referenceTrack.getValueSize();
        if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          referenceOffset = referenceValueSize / 3;
        }
        let targetOffset = 0;
        const targetValueSize = targetTrack.getValueSize();
        if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          targetOffset = targetValueSize / 3;
        }
        const lastIndex = referenceTrack.times.length - 1;
        let referenceValue;
        if (referenceTime <= referenceTrack.times[0]) {
          const startIndex = referenceOffset;
          const endIndex = referenceValueSize - referenceOffset;
          referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
        } else if (referenceTime >= referenceTrack.times[lastIndex]) {
          const startIndex = lastIndex * referenceValueSize + referenceOffset;
          const endIndex = startIndex + referenceValueSize - referenceOffset;
          referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
        } else {
          const interpolant = referenceTrack.createInterpolant();
          const startIndex = referenceOffset;
          const endIndex = referenceValueSize - referenceOffset;
          interpolant.evaluate(referenceTime);
          referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
        }
        if (referenceTrackType === "quaternion") {
          const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
          referenceQuat.toArray(referenceValue);
        }
        const numTimes = targetTrack.times.length;
        for (let j = 0; j < numTimes; ++j) {
          const valueStart = j * targetValueSize + targetOffset;
          if (referenceTrackType === "quaternion") {
            Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
          } else {
            const valueEnd = targetValueSize - targetOffset * 2;
            for (let k = 0; k < valueEnd; ++k) {
              targetTrack.values[valueStart + k] -= referenceValue[k];
            }
          }
        }
      }
      targetClip.blendMode = AdditiveAnimationBlendMode;
      return targetClip;
    }
  };
  function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
  }
  Object.assign(Interpolant.prototype, {
    evaluate: function(t) {
      const pp = this.parameterPositions;
      let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
      validate_interval: {
        seek: {
          let right;
          linear_scan: {
            forward_scan:
              if (!(t < t1)) {
                for (let giveUpAt = i1 + 2; ; ) {
                  if (t1 === void 0) {
                    if (t < t0)
                      break forward_scan;
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_(i1 - 1, t, t0);
                  }
                  if (i1 === giveUpAt)
                    break;
                  t0 = t1;
                  t1 = pp[++i1];
                  if (t < t1) {
                    break seek;
                  }
                }
                right = pp.length;
                break linear_scan;
              }
            if (!(t >= t0)) {
              const t1global = pp[1];
              if (t < t1global) {
                i1 = 2;
                t0 = t1global;
              }
              for (let giveUpAt = i1 - 2; ; ) {
                if (t0 === void 0) {
                  this._cachedIndex = 0;
                  return this.beforeStart_(0, t, t1);
                }
                if (i1 === giveUpAt)
                  break;
                t1 = t0;
                t0 = pp[--i1 - 1];
                if (t >= t0) {
                  break seek;
                }
              }
              right = i1;
              i1 = 0;
              break linear_scan;
            }
            break validate_interval;
          }
          while (i1 < right) {
            const mid = i1 + right >>> 1;
            if (t < pp[mid]) {
              right = mid;
            } else {
              i1 = mid + 1;
            }
          }
          t1 = pp[i1];
          t0 = pp[i1 - 1];
          if (t0 === void 0) {
            this._cachedIndex = 0;
            return this.beforeStart_(0, t, t1);
          }
          if (t1 === void 0) {
            i1 = pp.length;
            this._cachedIndex = i1;
            return this.afterEnd_(i1 - 1, t0, t);
          }
        }
        this._cachedIndex = i1;
        this.intervalChanged_(i1, t0, t1);
      }
      return this.interpolate_(i1, t0, t, t1);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function() {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(index) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
      for (let i = 0; i !== stride; ++i) {
        result[i] = values[offset + i];
      }
      return result;
    },
    interpolate_: function() {
      throw new Error("call to abstract method");
    },
    intervalChanged_: function() {
    }
  });
  Object.assign(Interpolant.prototype, {
    beforeStart_: Interpolant.prototype.copySampleValue_,
    afterEnd_: Interpolant.prototype.copySampleValue_
  });
  function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
  }
  CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: CubicInterpolant,
    DefaultSettings_: {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    },
    intervalChanged_: function(i1, t0, t1) {
      const pp = this.parameterPositions;
      let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
      if (tPrev === void 0) {
        switch (this.getSettings_().endingStart) {
          case ZeroSlopeEnding:
            iPrev = i1;
            tPrev = 2 * t0 - t1;
            break;
          case WrapAroundEnding:
            iPrev = pp.length - 2;
            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
            break;
          default:
            iPrev = i1;
            tPrev = t1;
        }
      }
      if (tNext === void 0) {
        switch (this.getSettings_().endingEnd) {
          case ZeroSlopeEnding:
            iNext = i1;
            tNext = 2 * t1 - t0;
            break;
          case WrapAroundEnding:
            iNext = 1;
            tNext = t1 + pp[1] - pp[0];
            break;
          default:
            iNext = i1 - 1;
            tNext = t0;
        }
      }
      const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
      this._weightPrev = halfDt / (t0 - tPrev);
      this._weightNext = halfDt / (tNext - t1);
      this._offsetPrev = iPrev * stride;
      this._offsetNext = iNext * stride;
    },
    interpolate_: function(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
      const sP = -wP * ppp + 2 * wP * pp - wP * p;
      const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
      const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
      const sN = wN * ppp - wN * pp;
      for (let i = 0; i !== stride; ++i) {
        result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
      }
      return result;
    }
  });
  function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: LinearInterpolant,
    interpolate_: function(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
      for (let i = 0; i !== stride; ++i) {
        result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
      }
      return result;
    }
  });
  function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: DiscreteInterpolant,
    interpolate_: function(i1) {
      return this.copySampleValue_(i1 - 1);
    }
  });
  function KeyframeTrack(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  Object.assign(KeyframeTrack, {
    toJSON: function(track) {
      const trackType = track.constructor;
      let json;
      if (trackType.toJSON !== void 0) {
        json = trackType.toJSON(track);
      } else {
        json = {
          name: track.name,
          times: AnimationUtils.convertArray(track.times, Array),
          values: AnimationUtils.convertArray(track.values, Array)
        };
        const interpolation = track.getInterpolation();
        if (interpolation !== track.DefaultInterpolation) {
          json.interpolation = interpolation;
        }
      }
      json.type = track.ValueTypeName;
      return json;
    }
  });
  Object.assign(KeyframeTrack.prototype, {
    constructor: KeyframeTrack,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function(result) {
      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodLinear: function(result) {
      return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: function(result) {
      return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    setInterpolation: function(interpolation) {
      let factoryMethod;
      switch (interpolation) {
        case InterpolateDiscrete:
          factoryMethod = this.InterpolantFactoryMethodDiscrete;
          break;
        case InterpolateLinear:
          factoryMethod = this.InterpolantFactoryMethodLinear;
          break;
        case InterpolateSmooth:
          factoryMethod = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (factoryMethod === void 0) {
        const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) {
          if (interpolation !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
          } else {
            throw new Error(message);
          }
        }
        console.warn("THREE.KeyframeTrack:", message);
        return this;
      }
      this.createInterpolant = factoryMethod;
      return this;
    },
    getInterpolation: function() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
          return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
          return InterpolateSmooth;
      }
    },
    getValueSize: function() {
      return this.values.length / this.times.length;
    },
    shift: function(timeOffset) {
      if (timeOffset !== 0) {
        const times = this.times;
        for (let i = 0, n = times.length; i !== n; ++i) {
          times[i] += timeOffset;
        }
      }
      return this;
    },
    scale: function(timeScale) {
      if (timeScale !== 1) {
        const times = this.times;
        for (let i = 0, n = times.length; i !== n; ++i) {
          times[i] *= timeScale;
        }
      }
      return this;
    },
    trim: function(startTime, endTime) {
      const times = this.times, nKeys = times.length;
      let from = 0, to = nKeys - 1;
      while (from !== nKeys && times[from] < startTime) {
        ++from;
      }
      while (to !== -1 && times[to] > endTime) {
        --to;
      }
      ++to;
      if (from !== 0 || to !== nKeys) {
        if (from >= to) {
          to = Math.max(to, 1);
          from = to - 1;
        }
        const stride = this.getValueSize();
        this.times = AnimationUtils.arraySlice(times, from, to);
        this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
      }
      return this;
    },
    validate: function() {
      let valid = true;
      const valueSize = this.getValueSize();
      if (valueSize - Math.floor(valueSize) !== 0) {
        console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
        valid = false;
      }
      const times = this.times, values = this.values, nKeys = times.length;
      if (nKeys === 0) {
        console.error("THREE.KeyframeTrack: Track is empty.", this);
        valid = false;
      }
      let prevTime = null;
      for (let i = 0; i !== nKeys; i++) {
        const currTime = times[i];
        if (typeof currTime === "number" && isNaN(currTime)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
          valid = false;
          break;
        }
        if (prevTime !== null && prevTime > currTime) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
          valid = false;
          break;
        }
        prevTime = currTime;
      }
      if (values !== void 0) {
        if (AnimationUtils.isTypedArray(values)) {
          for (let i = 0, n = values.length; i !== n; ++i) {
            const value = values[i];
            if (isNaN(value)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
              valid = false;
              break;
            }
          }
        }
      }
      return valid;
    },
    optimize: function() {
      const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
      let writeIndex = 1;
      for (let i = 1; i < lastIndex; ++i) {
        let keep = false;
        const time = times[i];
        const timeNext = times[i + 1];
        if (time !== timeNext && (i !== 1 || time !== time[0])) {
          if (!smoothInterpolation) {
            const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
            for (let j = 0; j !== stride; ++j) {
              const value = values[offset + j];
              if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                keep = true;
                break;
              }
            }
          } else {
            keep = true;
          }
        }
        if (keep) {
          if (i !== writeIndex) {
            times[writeIndex] = times[i];
            const readOffset = i * stride, writeOffset = writeIndex * stride;
            for (let j = 0; j !== stride; ++j) {
              values[writeOffset + j] = values[readOffset + j];
            }
          }
          ++writeIndex;
        }
      }
      if (lastIndex > 0) {
        times[writeIndex] = times[lastIndex];
        for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
          values[writeOffset + j] = values[readOffset + j];
        }
        ++writeIndex;
      }
      if (writeIndex !== times.length) {
        this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
        this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
      } else {
        this.times = times;
        this.values = values;
      }
      return this;
    },
    clone: function() {
      const times = AnimationUtils.arraySlice(this.times, 0);
      const values = AnimationUtils.arraySlice(this.values, 0);
      const TypedKeyframeTrack = this.constructor;
      const track = new TypedKeyframeTrack(this.name, times, values);
      track.createInterpolant = this.createInterpolant;
      return track;
    }
  });
  function BooleanKeyframeTrack(name, times, values) {
    KeyframeTrack.call(this, name, times, values);
  }
  BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: BooleanKeyframeTrack,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  });
  function ColorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }
  ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: ColorKeyframeTrack,
    ValueTypeName: "color"
  });
  function NumberKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }
  NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: NumberKeyframeTrack,
    ValueTypeName: "number"
  });
  function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: QuaternionLinearInterpolant,
    interpolate_: function(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
      let offset = i1 * stride;
      for (let end = offset + stride; offset !== end; offset += 4) {
        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
      }
      return result;
    }
  });
  function QuaternionKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }
  QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: QuaternionKeyframeTrack,
    ValueTypeName: "quaternion",
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodLinear: function(result) {
      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: void 0
  });
  function StringKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }
  StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: StringKeyframeTrack,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  });
  function VectorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }
  VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: VectorKeyframeTrack,
    ValueTypeName: "vector"
  });
  function AnimationClip(name, duration, tracks, blendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration !== void 0 ? duration : -1;
    this.blendMode = blendMode !== void 0 ? blendMode : NormalAnimationBlendMode;
    this.uuid = MathUtils.generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  function getTrackTypeForValueTypeName(typeName) {
    switch (typeName.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return NumberKeyframeTrack;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return VectorKeyframeTrack;
      case "color":
        return ColorKeyframeTrack;
      case "quaternion":
        return QuaternionKeyframeTrack;
      case "bool":
      case "boolean":
        return BooleanKeyframeTrack;
      case "string":
        return StringKeyframeTrack;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
  }
  function parseKeyframeTrack(json) {
    if (json.type === void 0) {
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    }
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === void 0) {
      const times = [], values = [];
      AnimationUtils.flattenJSON(json.keys, times, values, "value");
      json.times = times;
      json.values = values;
    }
    if (trackType.parse !== void 0) {
      return trackType.parse(json);
    } else {
      return new trackType(json.name, json.times, json.values, json.interpolation);
    }
  }
  Object.assign(AnimationClip, {
    parse: function(json) {
      const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
      for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
        tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
      }
      const clip = new AnimationClip(json.name, json.duration, tracks, json.blendMode);
      clip.uuid = json.uuid;
      return clip;
    },
    toJSON: function(clip) {
      const tracks = [], clipTracks = clip.tracks;
      const json = {
        name: clip.name,
        duration: clip.duration,
        tracks,
        uuid: clip.uuid,
        blendMode: clip.blendMode
      };
      for (let i = 0, n = clipTracks.length; i !== n; ++i) {
        tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
      }
      return json;
    },
    CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
      const numMorphTargets = morphTargetSequence.length;
      const tracks = [];
      for (let i = 0; i < numMorphTargets; i++) {
        let times = [];
        let values = [];
        times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
        values.push(0, 1, 0);
        const order = AnimationUtils.getKeyframeOrder(times);
        times = AnimationUtils.sortedArray(times, 1, order);
        values = AnimationUtils.sortedArray(values, 1, order);
        if (!noLoop && times[0] === 0) {
          times.push(numMorphTargets);
          values.push(values[0]);
        }
        tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
      }
      return new AnimationClip(name, -1, tracks);
    },
    findByName: function(objectOrClipArray, name) {
      let clipArray = objectOrClipArray;
      if (!Array.isArray(objectOrClipArray)) {
        const o = objectOrClipArray;
        clipArray = o.geometry && o.geometry.animations || o.animations;
      }
      for (let i = 0; i < clipArray.length; i++) {
        if (clipArray[i].name === name) {
          return clipArray[i];
        }
      }
      return null;
    },
    CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
      const animationToMorphTargets = {};
      const pattern = /^([\w-]*?)([\d]+)$/;
      for (let i = 0, il = morphTargets.length; i < il; i++) {
        const morphTarget = morphTargets[i];
        const parts = morphTarget.name.match(pattern);
        if (parts && parts.length > 1) {
          const name = parts[1];
          let animationMorphTargets = animationToMorphTargets[name];
          if (!animationMorphTargets) {
            animationToMorphTargets[name] = animationMorphTargets = [];
          }
          animationMorphTargets.push(morphTarget);
        }
      }
      const clips = [];
      for (const name in animationToMorphTargets) {
        clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
      }
      return clips;
    },
    parseAnimation: function(animation, bones) {
      if (!animation) {
        console.error("THREE.AnimationClip: No animation in JSONLoader data.");
        return null;
      }
      const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
        if (animationKeys.length !== 0) {
          const times = [];
          const values = [];
          AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
          if (times.length !== 0) {
            destTracks.push(new trackType(trackName, times, values));
          }
        }
      };
      const tracks = [];
      const clipName = animation.name || "default";
      const fps = animation.fps || 30;
      const blendMode = animation.blendMode;
      let duration = animation.length || -1;
      const hierarchyTracks = animation.hierarchy || [];
      for (let h = 0; h < hierarchyTracks.length; h++) {
        const animationKeys = hierarchyTracks[h].keys;
        if (!animationKeys || animationKeys.length === 0)
          continue;
        if (animationKeys[0].morphTargets) {
          const morphTargetNames = {};
          let k;
          for (k = 0; k < animationKeys.length; k++) {
            if (animationKeys[k].morphTargets) {
              for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
              }
            }
          }
          for (const morphTargetName in morphTargetNames) {
            const times = [];
            const values = [];
            for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
              const animationKey = animationKeys[k];
              times.push(animationKey.time);
              values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
            }
            tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
          }
          duration = morphTargetNames.length * (fps || 1);
        } else {
          const boneName = ".bones[" + bones[h].name + "]";
          addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
          addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
          addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
        }
      }
      if (tracks.length === 0) {
        return null;
      }
      const clip = new AnimationClip(clipName, duration, tracks, blendMode);
      return clip;
    }
  });
  Object.assign(AnimationClip.prototype, {
    resetDuration: function() {
      const tracks = this.tracks;
      let duration = 0;
      for (let i = 0, n = tracks.length; i !== n; ++i) {
        const track = this.tracks[i];
        duration = Math.max(duration, track.times[track.times.length - 1]);
      }
      this.duration = duration;
      return this;
    },
    trim: function() {
      for (let i = 0; i < this.tracks.length; i++) {
        this.tracks[i].trim(0, this.duration);
      }
      return this;
    },
    validate: function() {
      let valid = true;
      for (let i = 0; i < this.tracks.length; i++) {
        valid = valid && this.tracks[i].validate();
      }
      return valid;
    },
    optimize: function() {
      for (let i = 0; i < this.tracks.length; i++) {
        this.tracks[i].optimize();
      }
      return this;
    },
    clone: function() {
      const tracks = [];
      for (let i = 0; i < this.tracks.length; i++) {
        tracks.push(this.tracks[i].clone());
      }
      return new AnimationClip(this.name, this.duration, tracks, this.blendMode);
    },
    toJSON: function() {
      return AnimationClip.toJSON(this);
    }
  });
  var Cache = {
    enabled: false,
    files: {},
    add: function(key, file) {
      if (this.enabled === false)
        return;
      this.files[key] = file;
    },
    get: function(key) {
      if (this.enabled === false)
        return;
      return this.files[key];
    },
    remove: function(key) {
      delete this.files[key];
    },
    clear: function() {
      this.files = {};
    }
  };
  function LoadingManager(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i = 0, l = handlers.length; i < l; i += 2) {
        const regex = handlers[i];
        const loader = handlers[i + 1];
        if (regex.global)
          regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
  var DefaultLoadingManager = new LoadingManager();
  function Loader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  Object.assign(Loader.prototype, {
    load: function() {
    },
    loadAsync: function(url, onProgress) {
      const scope = this;
      return new Promise(function(resolve, reject) {
        scope.load(url, resolve, onProgress, reject);
      });
    },
    parse: function() {
    },
    setCrossOrigin: function(crossOrigin) {
      this.crossOrigin = crossOrigin;
      return this;
    },
    setWithCredentials: function(value) {
      this.withCredentials = value;
      return this;
    },
    setPath: function(path) {
      this.path = path;
      return this;
    },
    setResourcePath: function(resourcePath) {
      this.resourcePath = resourcePath;
      return this;
    },
    setRequestHeader: function(requestHeader) {
      this.requestHeader = requestHeader;
      return this;
    }
  });
  var loading = {};
  function FileLoader(manager) {
    Loader.call(this, manager);
  }
  FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: FileLoader,
    load: function(url, onLoad, onProgress, onError) {
      if (url === void 0)
        url = "";
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      if (loading[url] !== void 0) {
        loading[url].push({
          onLoad,
          onProgress,
          onError
        });
        return;
      }
      const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
      const dataUriRegexResult = url.match(dataUriRegex);
      let request;
      if (dataUriRegexResult) {
        const mimeType = dataUriRegexResult[1];
        const isBase64 = !!dataUriRegexResult[2];
        let data = dataUriRegexResult[3];
        data = decodeURIComponent(data);
        if (isBase64)
          data = atob(data);
        try {
          let response;
          const responseType = (this.responseType || "").toLowerCase();
          switch (responseType) {
            case "arraybuffer":
            case "blob":
              const view = new Uint8Array(data.length);
              for (let i = 0; i < data.length; i++) {
                view[i] = data.charCodeAt(i);
              }
              if (responseType === "blob") {
                response = new Blob([view.buffer], {type: mimeType});
              } else {
                response = view.buffer;
              }
              break;
            case "document":
              const parser = new DOMParser();
              response = parser.parseFromString(data, mimeType);
              break;
            case "json":
              response = JSON.parse(data);
              break;
            default:
              response = data;
              break;
          }
          setTimeout(function() {
            if (onLoad)
              onLoad(response);
            scope.manager.itemEnd(url);
          }, 0);
        } catch (error) {
          setTimeout(function() {
            if (onError)
              onError(error);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }, 0);
        }
      } else {
        loading[url] = [];
        loading[url].push({
          onLoad,
          onProgress,
          onError
        });
        request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.addEventListener("load", function(event) {
          const response = this.response;
          const callbacks = loading[url];
          delete loading[url];
          if (this.status === 200 || this.status === 0) {
            if (this.status === 0)
              console.warn("THREE.FileLoader: HTTP Status 0 received.");
            Cache.add(url, response);
            for (let i = 0, il = callbacks.length; i < il; i++) {
              const callback = callbacks[i];
              if (callback.onLoad)
                callback.onLoad(response);
            }
            scope.manager.itemEnd(url);
          } else {
            for (let i = 0, il = callbacks.length; i < il; i++) {
              const callback = callbacks[i];
              if (callback.onError)
                callback.onError(event);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }
        }, false);
        request.addEventListener("progress", function(event) {
          const callbacks = loading[url];
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onProgress)
              callback.onProgress(event);
          }
        }, false);
        request.addEventListener("error", function(event) {
          const callbacks = loading[url];
          delete loading[url];
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, false);
        request.addEventListener("abort", function(event) {
          const callbacks = loading[url];
          delete loading[url];
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, false);
        if (this.responseType !== void 0)
          request.responseType = this.responseType;
        if (this.withCredentials !== void 0)
          request.withCredentials = this.withCredentials;
        if (request.overrideMimeType)
          request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
        for (const header in this.requestHeader) {
          request.setRequestHeader(header, this.requestHeader[header]);
        }
        request.send(null);
      }
      scope.manager.itemStart(url);
      return request;
    },
    setResponseType: function(value) {
      this.responseType = value;
      return this;
    },
    setMimeType: function(value) {
      this.mimeType = value;
      return this;
    }
  });
  function AnimationLoader(manager) {
    Loader.call(this, manager);
  }
  AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: AnimationLoader,
    load: function(url, onLoad, onProgress, onError) {
      const scope = this;
      const loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.setRequestHeader(scope.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function(text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    },
    parse: function(json) {
      const animations = [];
      for (let i = 0; i < json.length; i++) {
        const clip = AnimationClip.parse(json[i]);
        animations.push(clip);
      }
      return animations;
    }
  });
  function CompressedTextureLoader(manager) {
    Loader.call(this, manager);
  }
  CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: CompressedTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
      const scope = this;
      const images = [];
      const texture = new CompressedTexture();
      texture.image = images;
      const loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType("arraybuffer");
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      let loaded = 0;
      function loadTexture(i) {
        loader.load(url[i], function(buffer) {
          const texDatas = scope.parse(buffer, true);
          images[i] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps
          };
          loaded += 1;
          if (loaded === 6) {
            if (texDatas.mipmapCount === 1)
              texture.minFilter = LinearFilter;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }
        }, onProgress, onError);
      }
      if (Array.isArray(url)) {
        for (let i = 0, il = url.length; i < il; ++i) {
          loadTexture(i);
        }
      } else {
        loader.load(url, function(buffer) {
          const texDatas = scope.parse(buffer, true);
          if (texDatas.isCubemap) {
            const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
            for (let f = 0; f < faces; f++) {
              images[f] = {mipmaps: []};
              for (let i = 0; i < texDatas.mipmapCount; i++) {
                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                images[f].format = texDatas.format;
                images[f].width = texDatas.width;
                images[f].height = texDatas.height;
              }
            }
          } else {
            texture.image.width = texDatas.width;
            texture.image.height = texDatas.height;
            texture.mipmaps = texDatas.mipmaps;
          }
          if (texDatas.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }, onProgress, onError);
      }
      return texture;
    }
  });
  function ImageLoader(manager) {
    Loader.call(this, manager);
  }
  ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ImageLoader,
    load: function(url, onLoad, onProgress, onError) {
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
      function onImageLoad() {
        image.removeEventListener("load", onImageLoad, false);
        image.removeEventListener("error", onImageError, false);
        Cache.add(url, this);
        if (onLoad)
          onLoad(this);
        scope.manager.itemEnd(url);
      }
      function onImageError(event) {
        image.removeEventListener("load", onImageLoad, false);
        image.removeEventListener("error", onImageError, false);
        if (onError)
          onError(event);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }
      image.addEventListener("load", onImageLoad, false);
      image.addEventListener("error", onImageError, false);
      if (url.substr(0, 5) !== "data:") {
        if (this.crossOrigin !== void 0)
          image.crossOrigin = this.crossOrigin;
      }
      scope.manager.itemStart(url);
      image.src = url;
      return image;
    }
  });
  function CubeTextureLoader(manager) {
    Loader.call(this, manager);
  }
  CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: CubeTextureLoader,
    load: function(urls, onLoad, onProgress, onError) {
      const texture = new CubeTexture();
      const loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      let loaded = 0;
      function loadTexture(i) {
        loader.load(urls[i], function(image) {
          texture.images[i] = image;
          loaded++;
          if (loaded === 6) {
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }
        }, void 0, onError);
      }
      for (let i = 0; i < urls.length; ++i) {
        loadTexture(i);
      }
      return texture;
    }
  });
  function DataTextureLoader(manager) {
    Loader.call(this, manager);
  }
  DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: DataTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
      const scope = this;
      const texture = new DataTexture();
      const loader = new FileLoader(this.manager);
      loader.setResponseType("arraybuffer");
      loader.setRequestHeader(this.requestHeader);
      loader.setPath(this.path);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function(buffer) {
        const texData = scope.parse(buffer);
        if (!texData)
          return;
        if (texData.image !== void 0) {
          texture.image = texData.image;
        } else if (texData.data !== void 0) {
          texture.image.width = texData.width;
          texture.image.height = texData.height;
          texture.image.data = texData.data;
        }
        texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
        texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
        texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
        texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
        texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
        if (texData.format !== void 0) {
          texture.format = texData.format;
        }
        if (texData.type !== void 0) {
          texture.type = texData.type;
        }
        if (texData.mipmaps !== void 0) {
          texture.mipmaps = texData.mipmaps;
          texture.minFilter = LinearMipmapLinearFilter;
        }
        if (texData.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture, texData);
      }, onProgress, onError);
      return texture;
    }
  });
  function TextureLoader(manager) {
    Loader.call(this, manager);
  }
  TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: TextureLoader,
    load: function(url, onLoad, onProgress, onError) {
      const texture = new Texture();
      const loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      loader.load(url, function(image) {
        texture.image = image;
        const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
        texture.format = isJPEG ? RGBFormat : RGBAFormat;
        texture.needsUpdate = true;
        if (onLoad !== void 0) {
          onLoad(texture);
        }
      }, onProgress, onError);
      return texture;
    }
  });
  function Curve() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  Object.assign(Curve.prototype, {
    getPoint: function() {
      console.warn("THREE.Curve: .getPoint() not implemented.");
      return null;
    },
    getPointAt: function(u, optionalTarget) {
      const t = this.getUtoTmapping(u);
      return this.getPoint(t, optionalTarget);
    },
    getPoints: function(divisions = 5) {
      const points = [];
      for (let d = 0; d <= divisions; d++) {
        points.push(this.getPoint(d / divisions));
      }
      return points;
    },
    getSpacedPoints: function(divisions = 5) {
      const points = [];
      for (let d = 0; d <= divisions; d++) {
        points.push(this.getPointAt(d / divisions));
      }
      return points;
    },
    getLength: function() {
      const lengths = this.getLengths();
      return lengths[lengths.length - 1];
    },
    getLengths: function(divisions) {
      if (divisions === void 0)
        divisions = this.arcLengthDivisions;
      if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
        return this.cacheArcLengths;
      }
      this.needsUpdate = false;
      const cache = [];
      let current, last = this.getPoint(0);
      let sum = 0;
      cache.push(0);
      for (let p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        sum += current.distanceTo(last);
        cache.push(sum);
        last = current;
      }
      this.cacheArcLengths = cache;
      return cache;
    },
    updateArcLengths: function() {
      this.needsUpdate = true;
      this.getLengths();
    },
    getUtoTmapping: function(u, distance) {
      const arcLengths = this.getLengths();
      let i = 0;
      const il = arcLengths.length;
      let targetArcLength;
      if (distance) {
        targetArcLength = distance;
      } else {
        targetArcLength = u * arcLengths[il - 1];
      }
      let low = 0, high = il - 1, comparison;
      while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
          low = i + 1;
        } else if (comparison > 0) {
          high = i - 1;
        } else {
          high = i;
          break;
        }
      }
      i = high;
      if (arcLengths[i] === targetArcLength) {
        return i / (il - 1);
      }
      const lengthBefore = arcLengths[i];
      const lengthAfter = arcLengths[i + 1];
      const segmentLength = lengthAfter - lengthBefore;
      const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      const t = (i + segmentFraction) / (il - 1);
      return t;
    },
    getTangent: function(t, optionalTarget) {
      const delta = 1e-4;
      let t1 = t - delta;
      let t2 = t + delta;
      if (t1 < 0)
        t1 = 0;
      if (t2 > 1)
        t2 = 1;
      const pt1 = this.getPoint(t1);
      const pt2 = this.getPoint(t2);
      const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
      tangent.copy(pt2).sub(pt1).normalize();
      return tangent;
    },
    getTangentAt: function(u, optionalTarget) {
      const t = this.getUtoTmapping(u);
      return this.getTangent(t, optionalTarget);
    },
    computeFrenetFrames: function(segments, closed) {
      const normal = new Vector3();
      const tangents = [];
      const normals = [];
      const binormals = [];
      const vec = new Vector3();
      const mat = new Matrix4();
      for (let i = 0; i <= segments; i++) {
        const u = i / segments;
        tangents[i] = this.getTangentAt(u, new Vector3());
        tangents[i].normalize();
      }
      normals[0] = new Vector3();
      binormals[0] = new Vector3();
      let min = Number.MAX_VALUE;
      const tx = Math.abs(tangents[0].x);
      const ty = Math.abs(tangents[0].y);
      const tz = Math.abs(tangents[0].z);
      if (tx <= min) {
        min = tx;
        normal.set(1, 0, 0);
      }
      if (ty <= min) {
        min = ty;
        normal.set(0, 1, 0);
      }
      if (tz <= min) {
        normal.set(0, 0, 1);
      }
      vec.crossVectors(tangents[0], normal).normalize();
      normals[0].crossVectors(tangents[0], vec);
      binormals[0].crossVectors(tangents[0], normals[0]);
      for (let i = 1; i <= segments; i++) {
        normals[i] = normals[i - 1].clone();
        binormals[i] = binormals[i - 1].clone();
        vec.crossVectors(tangents[i - 1], tangents[i]);
        if (vec.length() > Number.EPSILON) {
          vec.normalize();
          const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
          normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
      if (closed === true) {
        let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
        theta /= segments;
        if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
          theta = -theta;
        }
        for (let i = 1; i <= segments; i++) {
          normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
          binormals[i].crossVectors(tangents[i], normals[i]);
        }
      }
      return {
        tangents,
        normals,
        binormals
      };
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.arcLengthDivisions = source.arcLengthDivisions;
      return this;
    },
    toJSON: function() {
      const data = {
        metadata: {
          version: 4.5,
          type: "Curve",
          generator: "Curve.toJSON"
        }
      };
      data.arcLengthDivisions = this.arcLengthDivisions;
      data.type = this.type;
      return data;
    },
    fromJSON: function(json) {
      this.arcLengthDivisions = json.arcLengthDivisions;
      return this;
    }
  });
  function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    Curve.call(this);
    this.type = "EllipseCurve";
    this.aX = aX || 0;
    this.aY = aY || 0;
    this.xRadius = xRadius || 1;
    this.yRadius = yRadius || 1;
    this.aStartAngle = aStartAngle || 0;
    this.aEndAngle = aEndAngle || 2 * Math.PI;
    this.aClockwise = aClockwise || false;
    this.aRotation = aRotation || 0;
  }
  EllipseCurve.prototype = Object.create(Curve.prototype);
  EllipseCurve.prototype.constructor = EllipseCurve;
  EllipseCurve.prototype.isEllipseCurve = true;
  EllipseCurve.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y - this.aY;
      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }
    return point.set(x, y);
  };
  EllipseCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  };
  EllipseCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  };
  EllipseCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  };
  function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
  ArcCurve.prototype = Object.create(EllipseCurve.prototype);
  ArcCurve.prototype.constructor = ArcCurve;
  ArcCurve.prototype.isArcCurve = true;
  function CubicPoly() {
    let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    function init(x0, x1, t0, t1) {
      c0 = x0;
      c1 = t0;
      c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
      c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
      initCatmullRom: function(x0, x1, x2, x3, tension) {
        init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
      },
      initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
        let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1;
        t2 *= dt1;
        init(x1, x2, t1, t2);
      },
      calc: function(t) {
        const t2 = t * t;
        const t3 = t2 * t;
        return c0 + c1 * t + c2 * t2 + c3 * t3;
      }
    };
  }
  var tmp = new Vector3();
  var px = new CubicPoly();
  var py = new CubicPoly();
  var pz = new CubicPoly();
  function CatmullRomCurve3(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    Curve.call(this);
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  CatmullRomCurve3.prototype = Object.create(Curve.prototype);
  CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
  CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
  CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l];
    const p2 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
      let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  };
  CatmullRomCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  };
  CatmullRomCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  };
  CatmullRomCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  };
  function CatmullRom(t, p0, p1, p2, p3) {
    const v0 = (p2 - p0) * 0.5;
    const v1 = (p3 - p1) * 0.5;
    const t2 = t * t;
    const t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
  function QuadraticBezierP0(t, p) {
    const k = 1 - t;
    return k * k * p;
  }
  function QuadraticBezierP1(t, p) {
    return 2 * (1 - t) * t * p;
  }
  function QuadraticBezierP2(t, p) {
    return t * t * p;
  }
  function QuadraticBezier(t, p0, p1, p2) {
    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
  }
  function CubicBezierP0(t, p) {
    const k = 1 - t;
    return k * k * k * p;
  }
  function CubicBezierP1(t, p) {
    const k = 1 - t;
    return 3 * k * k * t * p;
  }
  function CubicBezierP2(t, p) {
    return 3 * (1 - t) * t * t * p;
  }
  function CubicBezierP3(t, p) {
    return t * t * t * p;
  }
  function CubicBezier(t, p0, p1, p2, p3) {
    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
  }
  function CubicBezierCurve(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    Curve.call(this);
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  CubicBezierCurve.prototype = Object.create(Curve.prototype);
  CubicBezierCurve.prototype.constructor = CubicBezierCurve;
  CubicBezierCurve.prototype.isCubicBezierCurve = true;
  CubicBezierCurve.prototype.getPoint = function(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    return point;
  };
  CubicBezierCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  };
  CubicBezierCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  };
  CubicBezierCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  };
  function CubicBezierCurve3(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    Curve.call(this);
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  CubicBezierCurve3.prototype = Object.create(Curve.prototype);
  CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
  CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
  CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
    return point;
  };
  CubicBezierCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  };
  CubicBezierCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  };
  CubicBezierCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  };
  function LineCurve(v1 = new Vector2(), v2 = new Vector2()) {
    Curve.call(this);
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  LineCurve.prototype = Object.create(Curve.prototype);
  LineCurve.prototype.constructor = LineCurve;
  LineCurve.prototype.isLineCurve = true;
  LineCurve.prototype.getPoint = function(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  };
  LineCurve.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  };
  LineCurve.prototype.getTangent = function(t, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  };
  LineCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  };
  LineCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  };
  LineCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  };
  function LineCurve3(v1 = new Vector3(), v2 = new Vector3()) {
    Curve.call(this);
    this.type = "LineCurve3";
    this.v1 = v1;
    this.v2 = v2;
  }
  LineCurve3.prototype = Object.create(Curve.prototype);
  LineCurve3.prototype.constructor = LineCurve3;
  LineCurve3.prototype.isLineCurve3 = true;
  LineCurve3.prototype.getPoint = function(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  };
  LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  };
  LineCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  };
  LineCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  };
  LineCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  };
  function QuadraticBezierCurve(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    Curve.call(this);
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
  QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
  QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
  QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    return point;
  };
  QuadraticBezierCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  };
  QuadraticBezierCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  };
  QuadraticBezierCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  };
  function QuadraticBezierCurve3(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    Curve.call(this);
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
  QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
  QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
  QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    return point;
  };
  QuadraticBezierCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  };
  QuadraticBezierCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  };
  QuadraticBezierCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  };
  function SplineCurve(points = []) {
    Curve.call(this);
    this.type = "SplineCurve";
    this.points = points;
  }
  SplineCurve.prototype = Object.create(Curve.prototype);
  SplineCurve.prototype.constructor = SplineCurve;
  SplineCurve.prototype.isSplineCurve = true;
  SplineCurve.prototype.getPoint = function(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
    return point;
  };
  SplineCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    return this;
  };
  SplineCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    return data;
  };
  SplineCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  };
  var Curves = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcCurve,
    CatmullRomCurve3,
    CubicBezierCurve,
    CubicBezierCurve3,
    EllipseCurve,
    LineCurve,
    LineCurve3,
    QuadraticBezierCurve,
    QuadraticBezierCurve3,
    SplineCurve
  });
  function CurvePath() {
    Curve.call(this);
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
    constructor: CurvePath,
    add: function(curve) {
      this.curves.push(curve);
    },
    closePath: function() {
      const startPoint = this.curves[0].getPoint(0);
      const endPoint = this.curves[this.curves.length - 1].getPoint(1);
      if (!startPoint.equals(endPoint)) {
        this.curves.push(new LineCurve(endPoint, startPoint));
      }
    },
    getPoint: function(t) {
      const d = t * this.getLength();
      const curveLengths = this.getCurveLengths();
      let i = 0;
      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          const diff = curveLengths[i] - d;
          const curve = this.curves[i];
          const segmentLength = curve.getLength();
          const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
          return curve.getPointAt(u);
        }
        i++;
      }
      return null;
    },
    getLength: function() {
      const lens = this.getCurveLengths();
      return lens[lens.length - 1];
    },
    updateArcLengths: function() {
      this.needsUpdate = true;
      this.cacheLengths = null;
      this.getCurveLengths();
    },
    getCurveLengths: function() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
        return this.cacheLengths;
      }
      const lengths = [];
      let sums = 0;
      for (let i = 0, l = this.curves.length; i < l; i++) {
        sums += this.curves[i].getLength();
        lengths.push(sums);
      }
      this.cacheLengths = lengths;
      return lengths;
    },
    getSpacedPoints: function(divisions = 40) {
      const points = [];
      for (let i = 0; i <= divisions; i++) {
        points.push(this.getPoint(i / divisions));
      }
      if (this.autoClose) {
        points.push(points[0]);
      }
      return points;
    },
    getPoints: function(divisions = 12) {
      const points = [];
      let last;
      for (let i = 0, curves = this.curves; i < curves.length; i++) {
        const curve = curves[i];
        const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
        const pts = curve.getPoints(resolution);
        for (let j = 0; j < pts.length; j++) {
          const point = pts[j];
          if (last && last.equals(point))
            continue;
          points.push(point);
          last = point;
        }
      }
      if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
        points.push(points[0]);
      }
      return points;
    },
    copy: function(source) {
      Curve.prototype.copy.call(this, source);
      this.curves = [];
      for (let i = 0, l = source.curves.length; i < l; i++) {
        const curve = source.curves[i];
        this.curves.push(curve.clone());
      }
      this.autoClose = source.autoClose;
      return this;
    },
    toJSON: function() {
      const data = Curve.prototype.toJSON.call(this);
      data.autoClose = this.autoClose;
      data.curves = [];
      for (let i = 0, l = this.curves.length; i < l; i++) {
        const curve = this.curves[i];
        data.curves.push(curve.toJSON());
      }
      return data;
    },
    fromJSON: function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.autoClose = json.autoClose;
      this.curves = [];
      for (let i = 0, l = json.curves.length; i < l; i++) {
        const curve = json.curves[i];
        this.curves.push(new Curves[curve.type]().fromJSON(curve));
      }
      return this;
    }
  });
  function Path(points) {
    CurvePath.call(this);
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
    constructor: Path,
    setFromPoints: function(points) {
      this.moveTo(points[0].x, points[0].y);
      for (let i = 1, l = points.length; i < l; i++) {
        this.lineTo(points[i].x, points[i].y);
      }
      return this;
    },
    moveTo: function(x, y) {
      this.currentPoint.set(x, y);
      return this;
    },
    lineTo: function(x, y) {
      const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
      this.curves.push(curve);
      this.currentPoint.set(x, y);
      return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
      const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    },
    splineThru: function(pts) {
      const npts = [this.currentPoint.clone()].concat(pts);
      const curve = new SplineCurve(npts);
      this.curves.push(curve);
      this.currentPoint.copy(pts[pts.length - 1]);
      return this;
    },
    arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      const x0 = this.currentPoint.x;
      const y0 = this.currentPoint.y;
      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    },
    absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    },
    ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      const x0 = this.currentPoint.x;
      const y0 = this.currentPoint.y;
      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      return this;
    },
    absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      if (this.curves.length > 0) {
        const firstPoint = curve.getPoint(0);
        if (!firstPoint.equals(this.currentPoint)) {
          this.lineTo(firstPoint.x, firstPoint.y);
        }
      }
      this.curves.push(curve);
      const lastPoint = curve.getPoint(1);
      this.currentPoint.copy(lastPoint);
      return this;
    },
    copy: function(source) {
      CurvePath.prototype.copy.call(this, source);
      this.currentPoint.copy(source.currentPoint);
      return this;
    },
    toJSON: function() {
      const data = CurvePath.prototype.toJSON.call(this);
      data.currentPoint = this.currentPoint.toArray();
      return data;
    },
    fromJSON: function(json) {
      CurvePath.prototype.fromJSON.call(this, json);
      this.currentPoint.fromArray(json.currentPoint);
      return this;
    }
  });
  function Shape(points) {
    Path.call(this, points);
    this.uuid = MathUtils.generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  Shape.prototype = Object.assign(Object.create(Path.prototype), {
    constructor: Shape,
    getPointsHoles: function(divisions) {
      const holesPts = [];
      for (let i = 0, l = this.holes.length; i < l; i++) {
        holesPts[i] = this.holes[i].getPoints(divisions);
      }
      return holesPts;
    },
    extractPoints: function(divisions) {
      return {
        shape: this.getPoints(divisions),
        holes: this.getPointsHoles(divisions)
      };
    },
    copy: function(source) {
      Path.prototype.copy.call(this, source);
      this.holes = [];
      for (let i = 0, l = source.holes.length; i < l; i++) {
        const hole = source.holes[i];
        this.holes.push(hole.clone());
      }
      return this;
    },
    toJSON: function() {
      const data = Path.prototype.toJSON.call(this);
      data.uuid = this.uuid;
      data.holes = [];
      for (let i = 0, l = this.holes.length; i < l; i++) {
        const hole = this.holes[i];
        data.holes.push(hole.toJSON());
      }
      return data;
    },
    fromJSON: function(json) {
      Path.prototype.fromJSON.call(this, json);
      this.uuid = json.uuid;
      this.holes = [];
      for (let i = 0, l = json.holes.length; i < l; i++) {
        const hole = json.holes[i];
        this.holes.push(new Path().fromJSON(hole));
      }
      return this;
    }
  });
  function Light(color, intensity = 1) {
    Object3D.call(this);
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  Light.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Light,
    isLight: true,
    copy: function(source) {
      Object3D.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.intensity = source.intensity;
      return this;
    },
    toJSON: function(meta) {
      const data = Object3D.prototype.toJSON.call(this, meta);
      data.object.color = this.color.getHex();
      data.object.intensity = this.intensity;
      if (this.groundColor !== void 0)
        data.object.groundColor = this.groundColor.getHex();
      if (this.distance !== void 0)
        data.object.distance = this.distance;
      if (this.angle !== void 0)
        data.object.angle = this.angle;
      if (this.decay !== void 0)
        data.object.decay = this.decay;
      if (this.penumbra !== void 0)
        data.object.penumbra = this.penumbra;
      if (this.shadow !== void 0)
        data.object.shadow = this.shadow.toJSON();
      return data;
    }
  });
  function HemisphereLight(skyColor, groundColor, intensity) {
    Light.call(this, skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: HemisphereLight,
    isHemisphereLight: true,
    copy: function(source) {
      Light.prototype.copy.call(this, source);
      this.groundColor.copy(source.groundColor);
      return this;
    }
  });
  function LightShadow(camera2) {
    this.camera = camera2;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  Object.assign(LightShadow.prototype, {
    _projScreenMatrix: new Matrix4(),
    _lightPositionWorld: new Vector3(),
    _lookTarget: new Vector3(),
    getViewportCount: function() {
      return this._viewportCount;
    },
    getFrustum: function() {
      return this._frustum;
    },
    updateMatrices: function(light) {
      const shadowCamera = this.camera, shadowMatrix = this.matrix, projScreenMatrix = this._projScreenMatrix, lookTarget = this._lookTarget, lightPositionWorld = this._lightPositionWorld;
      lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      shadowCamera.position.copy(lightPositionWorld);
      lookTarget.setFromMatrixPosition(light.target.matrixWorld);
      shadowCamera.lookAt(lookTarget);
      shadowCamera.updateMatrixWorld();
      projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(projScreenMatrix);
      shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      shadowMatrix.multiply(shadowCamera.projectionMatrix);
      shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    },
    getViewport: function(viewportIndex) {
      return this._viewports[viewportIndex];
    },
    getFrameExtents: function() {
      return this._frameExtents;
    },
    copy: function(source) {
      this.camera = source.camera.clone();
      this.bias = source.bias;
      this.radius = source.radius;
      this.mapSize.copy(source.mapSize);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON: function() {
      const object = {};
      if (this.bias !== 0)
        object.bias = this.bias;
      if (this.normalBias !== 0)
        object.normalBias = this.normalBias;
      if (this.radius !== 1)
        object.radius = this.radius;
      if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
        object.mapSize = this.mapSize.toArray();
      object.camera = this.camera.toJSON(false).object;
      delete object.camera.matrix;
      return object;
    }
  });
  function SpotLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: SpotLightShadow,
    isSpotLightShadow: true,
    updateMatrices: function(light) {
      const camera2 = this.camera;
      const fov2 = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
      const aspect2 = this.mapSize.width / this.mapSize.height;
      const far = light.distance || camera2.far;
      if (fov2 !== camera2.fov || aspect2 !== camera2.aspect || far !== camera2.far) {
        camera2.fov = fov2;
        camera2.aspect = aspect2;
        camera2.far = far;
        camera2.updateProjectionMatrix();
      }
      LightShadow.prototype.updateMatrices.call(this, light);
    }
  });
  function SpotLight(color, intensity, distance, angle, penumbra, decay) {
    Light.call(this, color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    Object.defineProperty(this, "power", {
      get: function() {
        return this.intensity * Math.PI;
      },
      set: function(power) {
        this.intensity = power / Math.PI;
      }
    });
    this.distance = distance !== void 0 ? distance : 0;
    this.angle = angle !== void 0 ? angle : Math.PI / 3;
    this.penumbra = penumbra !== void 0 ? penumbra : 0;
    this.decay = decay !== void 0 ? decay : 1;
    this.shadow = new SpotLightShadow();
  }
  SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: SpotLight,
    isSpotLight: true,
    copy: function(source) {
      Light.prototype.copy.call(this, source);
      this.distance = source.distance;
      this.angle = source.angle;
      this.penumbra = source.penumbra;
      this.decay = source.decay;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  });
  function PointLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: PointLightShadow,
    isPointLightShadow: true,
    updateMatrices: function(light, viewportIndex = 0) {
      const camera2 = this.camera, shadowMatrix = this.matrix, lightPositionWorld = this._lightPositionWorld, lookTarget = this._lookTarget, projScreenMatrix = this._projScreenMatrix;
      lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      camera2.position.copy(lightPositionWorld);
      lookTarget.copy(camera2.position);
      lookTarget.add(this._cubeDirections[viewportIndex]);
      camera2.up.copy(this._cubeUps[viewportIndex]);
      camera2.lookAt(lookTarget);
      camera2.updateMatrixWorld();
      shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
      projScreenMatrix.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(projScreenMatrix);
    }
  });
  function PointLight(color, intensity, distance, decay) {
    Light.call(this, color, intensity);
    this.type = "PointLight";
    Object.defineProperty(this, "power", {
      get: function() {
        return this.intensity * 4 * Math.PI;
      },
      set: function(power) {
        this.intensity = power / (4 * Math.PI);
      }
    });
    this.distance = distance !== void 0 ? distance : 0;
    this.decay = decay !== void 0 ? decay : 1;
    this.shadow = new PointLightShadow();
  }
  PointLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: PointLight,
    isPointLight: true,
    copy: function(source) {
      Light.prototype.copy.call(this, source);
      this.distance = source.distance;
      this.decay = source.decay;
      this.shadow = source.shadow.clone();
      return this;
    }
  });
  function OrthographicCamera(left, right, top, bottom, near, far) {
    Camera.call(this);
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left !== void 0 ? left : -1;
    this.right = right !== void 0 ? right : 1;
    this.top = top !== void 0 ? top : 1;
    this.bottom = bottom !== void 0 ? bottom : -1;
    this.near = near !== void 0 ? near : 0.1;
    this.far = far !== void 0 ? far : 2e3;
    this.updateProjectionMatrix();
  }
  OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: OrthographicCamera,
    isOrthographicCamera: true,
    copy: function(source, recursive) {
      Camera.prototype.copy.call(this, source, recursive);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      return this;
    },
    setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      const dx = (this.right - this.left) / (2 * this.zoom);
      const dy = (this.top - this.bottom) / (2 * this.zoom);
      const cx = (this.right + this.left) / 2;
      const cy = (this.top + this.bottom) / 2;
      let left = cx - dx;
      let right = cx + dx;
      let top = cy + dy;
      let bottom = cy - dy;
      if (this.view !== null && this.view.enabled) {
        const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
        const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    },
    toJSON: function(meta) {
      const data = Object3D.prototype.toJSON.call(this, meta);
      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      return data;
    }
  });
  function DirectionalLightShadow() {
    LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
  DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: DirectionalLightShadow,
    isDirectionalLightShadow: true,
    updateMatrices: function(light) {
      LightShadow.prototype.updateMatrices.call(this, light);
    }
  });
  function DirectionalLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: DirectionalLight,
    isDirectionalLight: true,
    copy: function(source) {
      Light.prototype.copy.call(this, source);
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  });
  function AmbientLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = "AmbientLight";
  }
  AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: AmbientLight,
    isAmbientLight: true
  });
  function RectAreaLight(color, intensity, width, height) {
    Light.call(this, color, intensity);
    this.type = "RectAreaLight";
    this.width = width !== void 0 ? width : 10;
    this.height = height !== void 0 ? height : 10;
  }
  RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: RectAreaLight,
    isRectAreaLight: true,
    copy: function(source) {
      Light.prototype.copy.call(this, source);
      this.width = source.width;
      this.height = source.height;
      return this;
    },
    toJSON: function(meta) {
      const data = Light.prototype.toJSON.call(this, meta);
      data.object.width = this.width;
      data.object.height = this.height;
      return data;
    }
  });
  var SphericalHarmonics3 = class {
    constructor() {
      Object.defineProperty(this, "isSphericalHarmonics3", {value: true});
      this.coefficients = [];
      for (let i = 0; i < 9; i++) {
        this.coefficients.push(new Vector3());
      }
    }
    set(coefficients) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].copy(coefficients[i]);
      }
      return this;
    }
    zero() {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].set(0, 0, 0);
      }
      return this;
    }
    getAt(normal, target) {
      const x = normal.x, y = normal.y, z = normal.z;
      const coeff = this.coefficients;
      target.copy(coeff[0]).multiplyScalar(0.282095);
      target.addScaledVector(coeff[1], 0.488603 * y);
      target.addScaledVector(coeff[2], 0.488603 * z);
      target.addScaledVector(coeff[3], 0.488603 * x);
      target.addScaledVector(coeff[4], 1.092548 * (x * y));
      target.addScaledVector(coeff[5], 1.092548 * (y * z));
      target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
      target.addScaledVector(coeff[7], 1.092548 * (x * z));
      target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
      return target;
    }
    getIrradianceAt(normal, target) {
      const x = normal.x, y = normal.y, z = normal.z;
      const coeff = this.coefficients;
      target.copy(coeff[0]).multiplyScalar(0.886227);
      target.addScaledVector(coeff[1], 2 * 0.511664 * y);
      target.addScaledVector(coeff[2], 2 * 0.511664 * z);
      target.addScaledVector(coeff[3], 2 * 0.511664 * x);
      target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
      target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
      target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
      target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
      target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
      return target;
    }
    add(sh) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].add(sh.coefficients[i]);
      }
      return this;
    }
    addScaledSH(sh, s) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].addScaledVector(sh.coefficients[i], s);
      }
      return this;
    }
    scale(s) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].multiplyScalar(s);
      }
      return this;
    }
    lerp(sh, alpha) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].lerp(sh.coefficients[i], alpha);
      }
      return this;
    }
    equals(sh) {
      for (let i = 0; i < 9; i++) {
        if (!this.coefficients[i].equals(sh.coefficients[i])) {
          return false;
        }
      }
      return true;
    }
    copy(sh) {
      return this.set(sh.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      const coefficients = this.coefficients;
      for (let i = 0; i < 9; i++) {
        coefficients[i].fromArray(array, offset + i * 3);
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const coefficients = this.coefficients;
      for (let i = 0; i < 9; i++) {
        coefficients[i].toArray(array, offset + i * 3);
      }
      return array;
    }
    static getBasisAt(normal, shBasis) {
      const x = normal.x, y = normal.y, z = normal.z;
      shBasis[0] = 0.282095;
      shBasis[1] = 0.488603 * y;
      shBasis[2] = 0.488603 * z;
      shBasis[3] = 0.488603 * x;
      shBasis[4] = 1.092548 * x * y;
      shBasis[5] = 1.092548 * y * z;
      shBasis[6] = 0.315392 * (3 * z * z - 1);
      shBasis[7] = 1.092548 * x * z;
      shBasis[8] = 0.546274 * (x * x - y * y);
    }
  };
  function LightProbe(sh, intensity) {
    Light.call(this, void 0, intensity);
    this.type = "LightProbe";
    this.sh = sh !== void 0 ? sh : new SphericalHarmonics3();
  }
  LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: LightProbe,
    isLightProbe: true,
    copy: function(source) {
      Light.prototype.copy.call(this, source);
      this.sh.copy(source.sh);
      return this;
    },
    fromJSON: function(json) {
      this.intensity = json.intensity;
      this.sh.fromArray(json.sh);
      return this;
    },
    toJSON: function(meta) {
      const data = Light.prototype.toJSON.call(this, meta);
      data.object.sh = this.sh.toArray();
      return data;
    }
  });
  function MaterialLoader(manager) {
    Loader.call(this, manager);
    this.textures = {};
  }
  MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: MaterialLoader,
    load: function(url, onLoad, onProgress, onError) {
      const scope = this;
      const loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.setRequestHeader(scope.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function(text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    },
    parse: function(json) {
      const textures = this.textures;
      function getTexture(name) {
        if (textures[name] === void 0) {
          console.warn("THREE.MaterialLoader: Undefined texture", name);
        }
        return textures[name];
      }
      const material = new Materials[json.type]();
      if (json.uuid !== void 0)
        material.uuid = json.uuid;
      if (json.name !== void 0)
        material.name = json.name;
      if (json.color !== void 0 && material.color !== void 0)
        material.color.setHex(json.color);
      if (json.roughness !== void 0)
        material.roughness = json.roughness;
      if (json.metalness !== void 0)
        material.metalness = json.metalness;
      if (json.sheen !== void 0)
        material.sheen = new Color().setHex(json.sheen);
      if (json.emissive !== void 0 && material.emissive !== void 0)
        material.emissive.setHex(json.emissive);
      if (json.specular !== void 0 && material.specular !== void 0)
        material.specular.setHex(json.specular);
      if (json.shininess !== void 0)
        material.shininess = json.shininess;
      if (json.clearcoat !== void 0)
        material.clearcoat = json.clearcoat;
      if (json.clearcoatRoughness !== void 0)
        material.clearcoatRoughness = json.clearcoatRoughness;
      if (json.fog !== void 0)
        material.fog = json.fog;
      if (json.flatShading !== void 0)
        material.flatShading = json.flatShading;
      if (json.blending !== void 0)
        material.blending = json.blending;
      if (json.combine !== void 0)
        material.combine = json.combine;
      if (json.side !== void 0)
        material.side = json.side;
      if (json.opacity !== void 0)
        material.opacity = json.opacity;
      if (json.transparent !== void 0)
        material.transparent = json.transparent;
      if (json.alphaTest !== void 0)
        material.alphaTest = json.alphaTest;
      if (json.depthTest !== void 0)
        material.depthTest = json.depthTest;
      if (json.depthWrite !== void 0)
        material.depthWrite = json.depthWrite;
      if (json.colorWrite !== void 0)
        material.colorWrite = json.colorWrite;
      if (json.stencilWrite !== void 0)
        material.stencilWrite = json.stencilWrite;
      if (json.stencilWriteMask !== void 0)
        material.stencilWriteMask = json.stencilWriteMask;
      if (json.stencilFunc !== void 0)
        material.stencilFunc = json.stencilFunc;
      if (json.stencilRef !== void 0)
        material.stencilRef = json.stencilRef;
      if (json.stencilFuncMask !== void 0)
        material.stencilFuncMask = json.stencilFuncMask;
      if (json.stencilFail !== void 0)
        material.stencilFail = json.stencilFail;
      if (json.stencilZFail !== void 0)
        material.stencilZFail = json.stencilZFail;
      if (json.stencilZPass !== void 0)
        material.stencilZPass = json.stencilZPass;
      if (json.wireframe !== void 0)
        material.wireframe = json.wireframe;
      if (json.wireframeLinewidth !== void 0)
        material.wireframeLinewidth = json.wireframeLinewidth;
      if (json.wireframeLinecap !== void 0)
        material.wireframeLinecap = json.wireframeLinecap;
      if (json.wireframeLinejoin !== void 0)
        material.wireframeLinejoin = json.wireframeLinejoin;
      if (json.rotation !== void 0)
        material.rotation = json.rotation;
      if (json.linewidth !== 1)
        material.linewidth = json.linewidth;
      if (json.dashSize !== void 0)
        material.dashSize = json.dashSize;
      if (json.gapSize !== void 0)
        material.gapSize = json.gapSize;
      if (json.scale !== void 0)
        material.scale = json.scale;
      if (json.polygonOffset !== void 0)
        material.polygonOffset = json.polygonOffset;
      if (json.polygonOffsetFactor !== void 0)
        material.polygonOffsetFactor = json.polygonOffsetFactor;
      if (json.polygonOffsetUnits !== void 0)
        material.polygonOffsetUnits = json.polygonOffsetUnits;
      if (json.skinning !== void 0)
        material.skinning = json.skinning;
      if (json.morphTargets !== void 0)
        material.morphTargets = json.morphTargets;
      if (json.morphNormals !== void 0)
        material.morphNormals = json.morphNormals;
      if (json.dithering !== void 0)
        material.dithering = json.dithering;
      if (json.vertexTangents !== void 0)
        material.vertexTangents = json.vertexTangents;
      if (json.visible !== void 0)
        material.visible = json.visible;
      if (json.toneMapped !== void 0)
        material.toneMapped = json.toneMapped;
      if (json.userData !== void 0)
        material.userData = json.userData;
      if (json.vertexColors !== void 0) {
        if (typeof json.vertexColors === "number") {
          material.vertexColors = json.vertexColors > 0 ? true : false;
        } else {
          material.vertexColors = json.vertexColors;
        }
      }
      if (json.uniforms !== void 0) {
        for (const name in json.uniforms) {
          const uniform = json.uniforms[name];
          material.uniforms[name] = {};
          switch (uniform.type) {
            case "t":
              material.uniforms[name].value = getTexture(uniform.value);
              break;
            case "c":
              material.uniforms[name].value = new Color().setHex(uniform.value);
              break;
            case "v2":
              material.uniforms[name].value = new Vector2().fromArray(uniform.value);
              break;
            case "v3":
              material.uniforms[name].value = new Vector3().fromArray(uniform.value);
              break;
            case "v4":
              material.uniforms[name].value = new Vector4().fromArray(uniform.value);
              break;
            case "m3":
              material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
              break;
            case "m4":
              material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
              break;
            default:
              material.uniforms[name].value = uniform.value;
          }
        }
      }
      if (json.defines !== void 0)
        material.defines = json.defines;
      if (json.vertexShader !== void 0)
        material.vertexShader = json.vertexShader;
      if (json.fragmentShader !== void 0)
        material.fragmentShader = json.fragmentShader;
      if (json.extensions !== void 0) {
        for (const key in json.extensions) {
          material.extensions[key] = json.extensions[key];
        }
      }
      if (json.shading !== void 0)
        material.flatShading = json.shading === 1;
      if (json.size !== void 0)
        material.size = json.size;
      if (json.sizeAttenuation !== void 0)
        material.sizeAttenuation = json.sizeAttenuation;
      if (json.map !== void 0)
        material.map = getTexture(json.map);
      if (json.matcap !== void 0)
        material.matcap = getTexture(json.matcap);
      if (json.alphaMap !== void 0)
        material.alphaMap = getTexture(json.alphaMap);
      if (json.bumpMap !== void 0)
        material.bumpMap = getTexture(json.bumpMap);
      if (json.bumpScale !== void 0)
        material.bumpScale = json.bumpScale;
      if (json.normalMap !== void 0)
        material.normalMap = getTexture(json.normalMap);
      if (json.normalMapType !== void 0)
        material.normalMapType = json.normalMapType;
      if (json.normalScale !== void 0) {
        let normalScale = json.normalScale;
        if (Array.isArray(normalScale) === false) {
          normalScale = [normalScale, normalScale];
        }
        material.normalScale = new Vector2().fromArray(normalScale);
      }
      if (json.displacementMap !== void 0)
        material.displacementMap = getTexture(json.displacementMap);
      if (json.displacementScale !== void 0)
        material.displacementScale = json.displacementScale;
      if (json.displacementBias !== void 0)
        material.displacementBias = json.displacementBias;
      if (json.roughnessMap !== void 0)
        material.roughnessMap = getTexture(json.roughnessMap);
      if (json.metalnessMap !== void 0)
        material.metalnessMap = getTexture(json.metalnessMap);
      if (json.emissiveMap !== void 0)
        material.emissiveMap = getTexture(json.emissiveMap);
      if (json.emissiveIntensity !== void 0)
        material.emissiveIntensity = json.emissiveIntensity;
      if (json.specularMap !== void 0)
        material.specularMap = getTexture(json.specularMap);
      if (json.envMap !== void 0)
        material.envMap = getTexture(json.envMap);
      if (json.envMapIntensity !== void 0)
        material.envMapIntensity = json.envMapIntensity;
      if (json.reflectivity !== void 0)
        material.reflectivity = json.reflectivity;
      if (json.refractionRatio !== void 0)
        material.refractionRatio = json.refractionRatio;
      if (json.lightMap !== void 0)
        material.lightMap = getTexture(json.lightMap);
      if (json.lightMapIntensity !== void 0)
        material.lightMapIntensity = json.lightMapIntensity;
      if (json.aoMap !== void 0)
        material.aoMap = getTexture(json.aoMap);
      if (json.aoMapIntensity !== void 0)
        material.aoMapIntensity = json.aoMapIntensity;
      if (json.gradientMap !== void 0)
        material.gradientMap = getTexture(json.gradientMap);
      if (json.clearcoatMap !== void 0)
        material.clearcoatMap = getTexture(json.clearcoatMap);
      if (json.clearcoatRoughnessMap !== void 0)
        material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
      if (json.clearcoatNormalMap !== void 0)
        material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
      if (json.clearcoatNormalScale !== void 0)
        material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
      if (json.transmission !== void 0)
        material.transmission = json.transmission;
      if (json.transmissionMap !== void 0)
        material.transmissionMap = getTexture(json.transmissionMap);
      return material;
    },
    setTextures: function(value) {
      this.textures = value;
      return this;
    }
  });
  var LoaderUtils = {
    decodeText: function(array) {
      if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(array);
      }
      let s = "";
      for (let i = 0, il = array.length; i < il; i++) {
        s += String.fromCharCode(array[i]);
      }
      try {
        return decodeURIComponent(escape(s));
      } catch (e) {
        return s;
      }
    },
    extractUrlBase: function(url) {
      const index = url.lastIndexOf("/");
      if (index === -1)
        return "./";
      return url.substr(0, index + 1);
    }
  };
  function InstancedBufferGeometry() {
    BufferGeometry.call(this);
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
    constructor: InstancedBufferGeometry,
    isInstancedBufferGeometry: true,
    copy: function(source) {
      BufferGeometry.prototype.copy.call(this, source);
      this.instanceCount = source.instanceCount;
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON: function() {
      const data = BufferGeometry.prototype.toJSON.call(this);
      data.instanceCount = this.instanceCount;
      data.isInstancedBufferGeometry = true;
      return data;
    }
  });
  function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
    if (typeof normalized === "number") {
      meshPerAttribute = normalized;
      normalized = false;
      console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
    }
    BufferAttribute.call(this, array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute || 1;
  }
  InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
    constructor: InstancedBufferAttribute,
    isInstancedBufferAttribute: true,
    copy: function(source) {
      BufferAttribute.prototype.copy.call(this, source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    },
    toJSON: function() {
      const data = BufferAttribute.prototype.toJSON.call(this);
      data.meshPerAttribute = this.meshPerAttribute;
      data.isInstancedBufferAttribute = true;
      return data;
    }
  });
  function BufferGeometryLoader(manager) {
    Loader.call(this, manager);
  }
  BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: BufferGeometryLoader,
    load: function(url, onLoad, onProgress, onError) {
      const scope = this;
      const loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.setRequestHeader(scope.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function(text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    },
    parse: function(json) {
      const interleavedBufferMap = {};
      const arrayBufferMap = {};
      function getInterleavedBuffer(json2, uuid) {
        if (interleavedBufferMap[uuid] !== void 0)
          return interleavedBufferMap[uuid];
        const interleavedBuffers = json2.interleavedBuffers;
        const interleavedBuffer = interleavedBuffers[uuid];
        const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
        const array = getTypedArray(interleavedBuffer.type, buffer);
        const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
        ib.uuid = interleavedBuffer.uuid;
        interleavedBufferMap[uuid] = ib;
        return ib;
      }
      function getArrayBuffer(json2, uuid) {
        if (arrayBufferMap[uuid] !== void 0)
          return arrayBufferMap[uuid];
        const arrayBuffers = json2.arrayBuffers;
        const arrayBuffer = arrayBuffers[uuid];
        const ab = new Uint32Array(arrayBuffer).buffer;
        arrayBufferMap[uuid] = ab;
        return ab;
      }
      const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
      const index = json.data.index;
      if (index !== void 0) {
        const typedArray = getTypedArray(index.type, index.array);
        geometry.setIndex(new BufferAttribute(typedArray, 1));
      }
      const attributes = json.data.attributes;
      for (const key in attributes) {
        const attribute = attributes[key];
        let bufferAttribute;
        if (attribute.isInterleavedBufferAttribute) {
          const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
          bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
        } else {
          const typedArray = getTypedArray(attribute.type, attribute.array);
          const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
          bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
        }
        if (attribute.name !== void 0)
          bufferAttribute.name = attribute.name;
        geometry.setAttribute(key, bufferAttribute);
      }
      const morphAttributes = json.data.morphAttributes;
      if (morphAttributes) {
        for (const key in morphAttributes) {
          const attributeArray = morphAttributes[key];
          const array = [];
          for (let i = 0, il = attributeArray.length; i < il; i++) {
            const attribute = attributeArray[i];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
              const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
              bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
              const typedArray = getTypedArray(attribute.type, attribute.array);
              bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== void 0)
              bufferAttribute.name = attribute.name;
            array.push(bufferAttribute);
          }
          geometry.morphAttributes[key] = array;
        }
      }
      const morphTargetsRelative = json.data.morphTargetsRelative;
      if (morphTargetsRelative) {
        geometry.morphTargetsRelative = true;
      }
      const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
      if (groups !== void 0) {
        for (let i = 0, n = groups.length; i !== n; ++i) {
          const group2 = groups[i];
          geometry.addGroup(group2.start, group2.count, group2.materialIndex);
        }
      }
      const boundingSphere = json.data.boundingSphere;
      if (boundingSphere !== void 0) {
        const center = new Vector3();
        if (boundingSphere.center !== void 0) {
          center.fromArray(boundingSphere.center);
        }
        geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
      }
      if (json.name)
        geometry.name = json.name;
      if (json.userData)
        geometry.userData = json.userData;
      return geometry;
    }
  });
  function ImageBitmapLoader(manager) {
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    Loader.call(this, manager);
    this.options = {premultiplyAlpha: "none"};
  }
  ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ImageBitmapLoader,
    isImageBitmapLoader: true,
    setOptions: function setOptions(options) {
      this.options = options;
      return this;
    },
    load: function(url, onLoad, onProgress, onError) {
      if (url === void 0)
        url = "";
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      const fetchOptions = {};
      fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
      fetch(url, fetchOptions).then(function(res) {
        return res.blob();
      }).then(function(blob) {
        return createImageBitmap(blob, scope.options);
      }).then(function(imageBitmap) {
        Cache.add(url, imageBitmap);
        if (onLoad)
          onLoad(imageBitmap);
        scope.manager.itemEnd(url);
      }).catch(function(e) {
        if (onError)
          onError(e);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
      scope.manager.itemStart(url);
    }
  });
  function ShapePath() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }
  Object.assign(ShapePath.prototype, {
    moveTo: function(x, y) {
      this.currentPath = new Path();
      this.subPaths.push(this.currentPath);
      this.currentPath.moveTo(x, y);
      return this;
    },
    lineTo: function(x, y) {
      this.currentPath.lineTo(x, y);
      return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
      this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
      return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
      return this;
    },
    splineThru: function(pts) {
      this.currentPath.splineThru(pts);
      return this;
    },
    toShapes: function(isCCW, noHoles) {
      function toShapesNoHoles(inSubpaths) {
        const shapes2 = [];
        for (let i = 0, l = inSubpaths.length; i < l; i++) {
          const tmpPath2 = inSubpaths[i];
          const tmpShape2 = new Shape();
          tmpShape2.curves = tmpPath2.curves;
          shapes2.push(tmpShape2);
        }
        return shapes2;
      }
      function isPointInsidePolygon(inPt, inPolygon) {
        const polyLen = inPolygon.length;
        let inside = false;
        for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
          let edgeLowPt = inPolygon[p];
          let edgeHighPt = inPolygon[q];
          let edgeDx = edgeHighPt.x - edgeLowPt.x;
          let edgeDy = edgeHighPt.y - edgeLowPt.y;
          if (Math.abs(edgeDy) > Number.EPSILON) {
            if (edgeDy < 0) {
              edgeLowPt = inPolygon[q];
              edgeDx = -edgeDx;
              edgeHighPt = inPolygon[p];
              edgeDy = -edgeDy;
            }
            if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
              continue;
            if (inPt.y === edgeLowPt.y) {
              if (inPt.x === edgeLowPt.x)
                return true;
            } else {
              const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
              if (perpEdge === 0)
                return true;
              if (perpEdge < 0)
                continue;
              inside = !inside;
            }
          } else {
            if (inPt.y !== edgeLowPt.y)
              continue;
            if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
              return true;
          }
        }
        return inside;
      }
      const isClockWise = ShapeUtils.isClockWise;
      const subPaths = this.subPaths;
      if (subPaths.length === 0)
        return [];
      if (noHoles === true)
        return toShapesNoHoles(subPaths);
      let solid, tmpPath, tmpShape;
      const shapes = [];
      if (subPaths.length === 1) {
        tmpPath = subPaths[0];
        tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        return shapes;
      }
      let holesFirst = !isClockWise(subPaths[0].getPoints());
      holesFirst = isCCW ? !holesFirst : holesFirst;
      const betterShapeHoles = [];
      const newShapes = [];
      let newShapeHoles = [];
      let mainIdx = 0;
      let tmpPoints;
      newShapes[mainIdx] = void 0;
      newShapeHoles[mainIdx] = [];
      for (let i = 0, l = subPaths.length; i < l; i++) {
        tmpPath = subPaths[i];
        tmpPoints = tmpPath.getPoints();
        solid = isClockWise(tmpPoints);
        solid = isCCW ? !solid : solid;
        if (solid) {
          if (!holesFirst && newShapes[mainIdx])
            mainIdx++;
          newShapes[mainIdx] = {s: new Shape(), p: tmpPoints};
          newShapes[mainIdx].s.curves = tmpPath.curves;
          if (holesFirst)
            mainIdx++;
          newShapeHoles[mainIdx] = [];
        } else {
          newShapeHoles[mainIdx].push({h: tmpPath, p: tmpPoints[0]});
        }
      }
      if (!newShapes[0])
        return toShapesNoHoles(subPaths);
      if (newShapes.length > 1) {
        let ambiguous = false;
        const toChange = [];
        for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
          betterShapeHoles[sIdx] = [];
        }
        for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
          const sho = newShapeHoles[sIdx];
          for (let hIdx = 0; hIdx < sho.length; hIdx++) {
            const ho = sho[hIdx];
            let hole_unassigned = true;
            for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
              if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                if (sIdx !== s2Idx)
                  toChange.push({froms: sIdx, tos: s2Idx, hole: hIdx});
                if (hole_unassigned) {
                  hole_unassigned = false;
                  betterShapeHoles[s2Idx].push(ho);
                } else {
                  ambiguous = true;
                }
              }
            }
            if (hole_unassigned) {
              betterShapeHoles[sIdx].push(ho);
            }
          }
        }
        if (toChange.length > 0) {
          if (!ambiguous)
            newShapeHoles = betterShapeHoles;
        }
      }
      let tmpHoles;
      for (let i = 0, il = newShapes.length; i < il; i++) {
        tmpShape = newShapes[i].s;
        shapes.push(tmpShape);
        tmpHoles = newShapeHoles[i];
        for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
          tmpShape.holes.push(tmpHoles[j].h);
        }
      }
      return shapes;
    }
  });
  function Font(data) {
    this.type = "Font";
    this.data = data;
  }
  Object.assign(Font.prototype, {
    isFont: true,
    generateShapes: function(text, size = 100) {
      const shapes = [];
      const paths = createPaths(text, size, this.data);
      for (let p = 0, pl = paths.length; p < pl; p++) {
        Array.prototype.push.apply(shapes, paths[p].toShapes());
      }
      return shapes;
    }
  });
  function createPaths(text, size, data) {
    const chars = Array.from ? Array.from(text) : String(text).split("");
    const scale = size / data.resolution;
    const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
    const paths = [];
    let offsetX = 0, offsetY = 0;
    for (let i = 0; i < chars.length; i++) {
      const char = chars[i];
      if (char === "\n") {
        offsetX = 0;
        offsetY -= line_height;
      } else {
        const ret = createPath(char, scale, offsetX, offsetY, data);
        offsetX += ret.offsetX;
        paths.push(ret.path);
      }
    }
    return paths;
  }
  function createPath(char, scale, offsetX, offsetY, data) {
    const glyph = data.glyphs[char] || data.glyphs["?"];
    if (!glyph) {
      console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
      return;
    }
    const path = new ShapePath();
    let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
      const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
      for (let i = 0, l = outline.length; i < l; ) {
        const action = outline[i++];
        switch (action) {
          case "m":
            x = outline[i++] * scale + offsetX;
            y = outline[i++] * scale + offsetY;
            path.moveTo(x, y);
            break;
          case "l":
            x = outline[i++] * scale + offsetX;
            y = outline[i++] * scale + offsetY;
            path.lineTo(x, y);
            break;
          case "q":
            cpx = outline[i++] * scale + offsetX;
            cpy = outline[i++] * scale + offsetY;
            cpx1 = outline[i++] * scale + offsetX;
            cpy1 = outline[i++] * scale + offsetY;
            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
            break;
          case "b":
            cpx = outline[i++] * scale + offsetX;
            cpy = outline[i++] * scale + offsetY;
            cpx1 = outline[i++] * scale + offsetX;
            cpy1 = outline[i++] * scale + offsetY;
            cpx2 = outline[i++] * scale + offsetX;
            cpy2 = outline[i++] * scale + offsetY;
            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
            break;
        }
      }
    }
    return {offsetX: glyph.ha * scale, path};
  }
  function FontLoader(manager) {
    Loader.call(this, manager);
  }
  FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: FontLoader,
    load: function(url, onLoad, onProgress, onError) {
      const scope = this;
      const loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function(text) {
        let json;
        try {
          json = JSON.parse(text);
        } catch (e) {
          console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
          json = JSON.parse(text.substring(65, text.length - 2));
        }
        const font = scope.parse(json);
        if (onLoad)
          onLoad(font);
      }, onProgress, onError);
    },
    parse: function(json) {
      return new Font(json);
    }
  });
  var _context;
  var AudioContext = {
    getContext: function() {
      if (_context === void 0) {
        _context = new (window.AudioContext || window.webkitAudioContext)();
      }
      return _context;
    },
    setContext: function(value) {
      _context = value;
    }
  };
  function AudioLoader(manager) {
    Loader.call(this, manager);
  }
  AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: AudioLoader,
    load: function(url, onLoad, onProgress, onError) {
      const scope = this;
      const loader = new FileLoader(scope.manager);
      loader.setResponseType("arraybuffer");
      loader.setPath(scope.path);
      loader.setRequestHeader(scope.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function(buffer) {
        try {
          const bufferCopy = buffer.slice(0);
          const context = AudioContext.getContext();
          context.decodeAudioData(bufferCopy, function(audioBuffer) {
            onLoad(audioBuffer);
          });
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  });
  function HemisphereLightProbe(skyColor, groundColor, intensity) {
    LightProbe.call(this, void 0, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }
  HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
    constructor: HemisphereLightProbe,
    isHemisphereLightProbe: true,
    copy: function(source) {
      LightProbe.prototype.copy.call(this, source);
      return this;
    },
    toJSON: function(meta) {
      const data = LightProbe.prototype.toJSON.call(this, meta);
      return data;
    }
  });
  function AmbientLightProbe(color, intensity) {
    LightProbe.call(this, void 0, intensity);
    const color1 = new Color().set(color);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
  AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
    constructor: AmbientLightProbe,
    isAmbientLightProbe: true,
    copy: function(source) {
      LightProbe.prototype.copy.call(this, source);
      return this;
    },
    toJSON: function(meta) {
      const data = LightProbe.prototype.toJSON.call(this, meta);
      return data;
    }
  });
  var _eyeRight = new Matrix4();
  var _eyeLeft = new Matrix4();
  function StereoCamera() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  Object.assign(StereoCamera.prototype, {
    update: function(camera2) {
      const cache = this._cache;
      const needsUpdate = cache.focus !== camera2.focus || cache.fov !== camera2.fov || cache.aspect !== camera2.aspect * this.aspect || cache.near !== camera2.near || cache.far !== camera2.far || cache.zoom !== camera2.zoom || cache.eyeSep !== this.eyeSep;
      if (needsUpdate) {
        cache.focus = camera2.focus;
        cache.fov = camera2.fov;
        cache.aspect = camera2.aspect * this.aspect;
        cache.near = camera2.near;
        cache.far = camera2.far;
        cache.zoom = camera2.zoom;
        cache.eyeSep = this.eyeSep;
        const projectionMatrix = camera2.projectionMatrix.clone();
        const eyeSepHalf = cache.eyeSep / 2;
        const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
        const ymax = cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5) / cache.zoom;
        let xmin, xmax;
        _eyeLeft.elements[12] = -eyeSepHalf;
        _eyeRight.elements[12] = eyeSepHalf;
        xmin = -ymax * cache.aspect + eyeSepOnProjection;
        xmax = ymax * cache.aspect + eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraL.projectionMatrix.copy(projectionMatrix);
        xmin = -ymax * cache.aspect - eyeSepOnProjection;
        xmax = ymax * cache.aspect - eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraR.projectionMatrix.copy(projectionMatrix);
      }
      this.cameraL.matrixWorld.copy(camera2.matrixWorld).multiply(_eyeLeft);
      this.cameraR.matrixWorld.copy(camera2.matrixWorld).multiply(_eyeRight);
    }
  });
  var Clock = class {
    constructor(autoStart) {
      this.autoStart = autoStart !== void 0 ? autoStart : true;
      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    }
    start() {
      this.startTime = now();
      this.oldTime = this.startTime;
      this.elapsedTime = 0;
      this.running = true;
    }
    stop() {
      this.getElapsedTime();
      this.running = false;
      this.autoStart = false;
    }
    getElapsedTime() {
      this.getDelta();
      return this.elapsedTime;
    }
    getDelta() {
      let diff = 0;
      if (this.autoStart && !this.running) {
        this.start();
        return 0;
      }
      if (this.running) {
        const newTime = now();
        diff = (newTime - this.oldTime) / 1e3;
        this.oldTime = newTime;
        this.elapsedTime += diff;
      }
      return diff;
    }
  };
  function now() {
    return (typeof performance === "undefined" ? Date : performance).now();
  }
  var Audio = class extends Object3D {
    constructor(listener) {
      super();
      this.type = "Audio";
      this.listener = listener;
      this.context = listener.context;
      this.gain = this.context.createGain();
      this.gain.connect(listener.getInput());
      this.autoplay = false;
      this.buffer = null;
      this.detune = 0;
      this.loop = false;
      this.loopStart = 0;
      this.loopEnd = 0;
      this.offset = 0;
      this.duration = void 0;
      this.playbackRate = 1;
      this.isPlaying = false;
      this.hasPlaybackControl = true;
      this.source = null;
      this.sourceType = "empty";
      this._startedAt = 0;
      this._progress = 0;
      this._connected = false;
      this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(audioNode) {
      this.hasPlaybackControl = false;
      this.sourceType = "audioNode";
      this.source = audioNode;
      this.connect();
      return this;
    }
    setMediaElementSource(mediaElement) {
      this.hasPlaybackControl = false;
      this.sourceType = "mediaNode";
      this.source = this.context.createMediaElementSource(mediaElement);
      this.connect();
      return this;
    }
    setMediaStreamSource(mediaStream) {
      this.hasPlaybackControl = false;
      this.sourceType = "mediaStreamNode";
      this.source = this.context.createMediaStreamSource(mediaStream);
      this.connect();
      return this;
    }
    setBuffer(audioBuffer) {
      this.buffer = audioBuffer;
      this.sourceType = "buffer";
      if (this.autoplay)
        this.play();
      return this;
    }
    play(delay = 0) {
      if (this.isPlaying === true) {
        console.warn("THREE.Audio: Audio is already playing.");
        return;
      }
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this._startedAt = this.context.currentTime + delay;
      const source = this.context.createBufferSource();
      source.buffer = this.buffer;
      source.loop = this.loop;
      source.loopStart = this.loopStart;
      source.loopEnd = this.loopEnd;
      source.onended = this.onEnded.bind(this);
      source.start(this._startedAt, this._progress + this.offset, this.duration);
      this.isPlaying = true;
      this.source = source;
      this.setDetune(this.detune);
      this.setPlaybackRate(this.playbackRate);
      return this.connect();
    }
    pause() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      if (this.isPlaying === true) {
        this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
        if (this.loop === true) {
          this._progress = this._progress % (this.duration || this.buffer.duration);
        }
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
      }
      return this;
    }
    stop() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this._progress = 0;
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
      return this;
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let i = 1, l = this.filters.length; i < l; i++) {
          this.filters[i - 1].connect(this.filters[i]);
        }
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else {
        this.source.connect(this.getOutput());
      }
      this._connected = true;
      return this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let i = 1, l = this.filters.length; i < l; i++) {
          this.filters[i - 1].disconnect(this.filters[i]);
        }
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else {
        this.source.disconnect(this.getOutput());
      }
      this._connected = false;
      return this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(value) {
      if (!value)
        value = [];
      if (this._connected === true) {
        this.disconnect();
        this.filters = value.slice();
        this.connect();
      } else {
        this.filters = value.slice();
      }
      return this;
    }
    setDetune(value) {
      this.detune = value;
      if (this.source.detune === void 0)
        return;
      if (this.isPlaying === true) {
        this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
      }
      return this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(filter) {
      return this.setFilters(filter ? [filter] : []);
    }
    setPlaybackRate(value) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this.playbackRate = value;
      if (this.isPlaying === true) {
        this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
      }
      return this;
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return false;
      }
      return this.loop;
    }
    setLoop(value) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this.loop = value;
      if (this.isPlaying === true) {
        this.source.loop = this.loop;
      }
      return this;
    }
    setLoopStart(value) {
      this.loopStart = value;
      return this;
    }
    setLoopEnd(value) {
      this.loopEnd = value;
      return this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(value) {
      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
      return this;
    }
  };
  var AudioAnalyser = class {
    constructor(audio, fftSize = 2048) {
      this.analyser = audio.context.createAnalyser();
      this.analyser.fftSize = fftSize;
      this.data = new Uint8Array(this.analyser.frequencyBinCount);
      audio.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
      this.analyser.getByteFrequencyData(this.data);
      return this.data;
    }
    getAverageFrequency() {
      let value = 0;
      const data = this.getFrequencyData();
      for (let i = 0; i < data.length; i++) {
        value += data[i];
      }
      return value / data.length;
    }
  };
  function PropertyMixer(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  Object.assign(PropertyMixer.prototype, {
    accumulate: function(accuIndex, weight) {
      const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
      let currentWeight = this.cumulativeWeight;
      if (currentWeight === 0) {
        for (let i = 0; i !== stride; ++i) {
          buffer[offset + i] = buffer[i];
        }
        currentWeight = weight;
      } else {
        currentWeight += weight;
        const mix = weight / currentWeight;
        this._mixBufferRegion(buffer, offset, 0, mix, stride);
      }
      this.cumulativeWeight = currentWeight;
    },
    accumulateAdditive: function(weight) {
      const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
      if (this.cumulativeWeightAdditive === 0) {
        this._setIdentity();
      }
      this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
      this.cumulativeWeightAdditive += weight;
    },
    apply: function(accuIndex) {
      const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
      if (weight < 1) {
        const originalValueOffset = stride * this._origIndex;
        this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
      }
      if (weightAdditive > 0) {
        this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
      }
      for (let i = stride, e = stride + stride; i !== e; ++i) {
        if (buffer[i] !== buffer[i + stride]) {
          binding.setValue(buffer, offset);
          break;
        }
      }
    },
    saveOriginalState: function() {
      const binding = this.binding;
      const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
      binding.getValue(buffer, originalValueOffset);
      for (let i = stride, e = originalValueOffset; i !== e; ++i) {
        buffer[i] = buffer[originalValueOffset + i % stride];
      }
      this._setIdentity();
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
    },
    restoreOriginalState: function() {
      const originalValueOffset = this.valueSize * 3;
      this.binding.setValue(this.buffer, originalValueOffset);
    },
    _setAdditiveIdentityNumeric: function() {
      const startIndex = this._addIndex * this.valueSize;
      const endIndex = startIndex + this.valueSize;
      for (let i = startIndex; i < endIndex; i++) {
        this.buffer[i] = 0;
      }
    },
    _setAdditiveIdentityQuaternion: function() {
      this._setAdditiveIdentityNumeric();
      this.buffer[this._addIndex * this.valueSize + 3] = 1;
    },
    _setAdditiveIdentityOther: function() {
      const startIndex = this._origIndex * this.valueSize;
      const targetIndex = this._addIndex * this.valueSize;
      for (let i = 0; i < this.valueSize; i++) {
        this.buffer[targetIndex + i] = this.buffer[startIndex + i];
      }
    },
    _select: function(buffer, dstOffset, srcOffset, t, stride) {
      if (t >= 0.5) {
        for (let i = 0; i !== stride; ++i) {
          buffer[dstOffset + i] = buffer[srcOffset + i];
        }
      }
    },
    _slerp: function(buffer, dstOffset, srcOffset, t) {
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    },
    _slerpAdditive: function(buffer, dstOffset, srcOffset, t, stride) {
      const workOffset = this._workIndex * stride;
      Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
    },
    _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
      const s = 1 - t;
      for (let i = 0; i !== stride; ++i) {
        const j = dstOffset + i;
        buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
      }
    },
    _lerpAdditive: function(buffer, dstOffset, srcOffset, t, stride) {
      for (let i = 0; i !== stride; ++i) {
        const j = dstOffset + i;
        buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
      }
    }
  });
  var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
  var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
  var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
  var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
  var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
  var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
  var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
  var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
  var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
  var _supportedObjectNames = ["material", "materials", "bones"];
  function Composite(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  Object.assign(Composite.prototype, {
    getValue: function(array, offset) {
      this.bind();
      const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
      if (binding !== void 0)
        binding.getValue(array, offset);
    },
    setValue: function(array, offset) {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].setValue(array, offset);
      }
    },
    bind: function() {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].bind();
      }
    },
    unbind: function() {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].unbind();
      }
    }
  });
  function PropertyBinding(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
  }
  Object.assign(PropertyBinding, {
    Composite,
    create: function(root, path, parsedPath) {
      if (!(root && root.isAnimationObjectGroup)) {
        return new PropertyBinding(root, path, parsedPath);
      } else {
        return new PropertyBinding.Composite(root, path, parsedPath);
      }
    },
    sanitizeNodeName: function(name) {
      return name.replace(/\s/g, "_").replace(_reservedRe, "");
    },
    parseTrackName: function(trackName) {
      const matches = _trackRe.exec(trackName);
      if (!matches) {
        throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
      }
      const results = {
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        propertyIndex: matches[6]
      };
      const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
      if (lastDot !== void 0 && lastDot !== -1) {
        const objectName = results.nodeName.substring(lastDot + 1);
        if (_supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
      }
      return results;
    },
    findNode: function(root, nodeName) {
      if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      }
      if (root.skeleton) {
        const bone = root.skeleton.getBoneByName(nodeName);
        if (bone !== void 0) {
          return bone;
        }
      }
      if (root.children) {
        const searchNodeSubtree = function(children) {
          for (let i = 0; i < children.length; i++) {
            const childNode = children[i];
            if (childNode.name === nodeName || childNode.uuid === nodeName) {
              return childNode;
            }
            const result = searchNodeSubtree(childNode.children);
            if (result)
              return result;
          }
          return null;
        };
        const subTreeNode = searchNodeSubtree(root.children);
        if (subTreeNode) {
          return subTreeNode;
        }
      }
      return null;
    }
  });
  Object.assign(PropertyBinding.prototype, {
    _getValue_unavailable: function() {
    },
    _setValue_unavailable: function() {
    },
    BindingType: {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    },
    Versioning: {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [
      function getValue_direct(buffer, offset) {
        buffer[offset] = this.node[this.propertyName];
      },
      function getValue_array(buffer, offset) {
        const source = this.resolvedProperty;
        for (let i = 0, n = source.length; i !== n; ++i) {
          buffer[offset++] = source[i];
        }
      },
      function getValue_arrayElement(buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
      },
      function getValue_toArray(buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
      }
    ],
    SetterByBindingTypeAndVersioning: [
      [
        function setValue_direct(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
        },
        function setValue_direct_setNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.needsUpdate = true;
        },
        function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ],
      [
        function setValue_array(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
        },
        function setValue_array_setNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
          this.targetObject.needsUpdate = true;
        },
        function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ],
      [
        function setValue_arrayElement(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
        },
        function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.needsUpdate = true;
        },
        function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ],
      [
        function setValue_fromArray(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
        },
        function setValue_fromArray_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.needsUpdate = true;
        },
        function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ]
    ],
    getValue: function getValue_unbound(targetArray, offset) {
      this.bind();
      this.getValue(targetArray, offset);
    },
    setValue: function getValue_unbound2(sourceArray, offset) {
      this.bind();
      this.setValue(sourceArray, offset);
    },
    bind: function() {
      let targetObject = this.node;
      const parsedPath = this.parsedPath;
      const objectName = parsedPath.objectName;
      const propertyName = parsedPath.propertyName;
      let propertyIndex = parsedPath.propertyIndex;
      if (!targetObject) {
        targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
        this.node = targetObject;
      }
      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable;
      if (!targetObject) {
        console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        return;
      }
      if (objectName) {
        let objectIndex = parsedPath.objectIndex;
        switch (objectName) {
          case "materials":
            if (!targetObject.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!targetObject.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            targetObject = targetObject.material.materials;
            break;
          case "bones":
            if (!targetObject.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            targetObject = targetObject.skeleton.bones;
            for (let i = 0; i < targetObject.length; i++) {
              if (targetObject[i].name === objectIndex) {
                objectIndex = i;
                break;
              }
            }
            break;
          default:
            if (targetObject[objectName] === void 0) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            targetObject = targetObject[objectName];
        }
        if (objectIndex !== void 0) {
          if (targetObject[objectIndex] === void 0) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
            return;
          }
          targetObject = targetObject[objectIndex];
        }
      }
      const nodeProperty = targetObject[propertyName];
      if (nodeProperty === void 0) {
        const nodeName = parsedPath.nodeName;
        console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
        return;
      }
      let versioning = this.Versioning.None;
      this.targetObject = targetObject;
      if (targetObject.needsUpdate !== void 0) {
        versioning = this.Versioning.NeedsUpdate;
      } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
        versioning = this.Versioning.MatrixWorldNeedsUpdate;
      }
      let bindingType = this.BindingType.Direct;
      if (propertyIndex !== void 0) {
        if (propertyName === "morphTargetInfluences") {
          if (!targetObject.geometry) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            return;
          }
          if (targetObject.geometry.isBufferGeometry) {
            if (!targetObject.geometry.morphAttributes) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              return;
            }
            if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
              propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
            }
          } else {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
            return;
          }
        }
        bindingType = this.BindingType.ArrayElement;
        this.resolvedProperty = nodeProperty;
        this.propertyIndex = propertyIndex;
      } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
        bindingType = this.BindingType.HasFromToArray;
        this.resolvedProperty = nodeProperty;
      } else if (Array.isArray(nodeProperty)) {
        bindingType = this.BindingType.EntireArray;
        this.resolvedProperty = nodeProperty;
      } else {
        this.propertyName = propertyName;
      }
      this.getValue = this.GetterByBindingType[bindingType];
      this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    },
    unbind: function() {
      this.node = null;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
  });
  Object.assign(PropertyBinding.prototype, {
    _getValue_unbound: PropertyBinding.prototype.getValue,
    _setValue_unbound: PropertyBinding.prototype.setValue
  });
  function AnimationObjectGroup() {
    this.uuid = MathUtils.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      indices[arguments[i].uuid] = i;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  Object.assign(AnimationObjectGroup.prototype, {
    isAnimationObjectGroup: true,
    add: function() {
      const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
      let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
      for (let i = 0, n = arguments.length; i !== n; ++i) {
        const object = arguments[i], uuid = object.uuid;
        let index = indicesByUUID[uuid];
        if (index === void 0) {
          index = nObjects++;
          indicesByUUID[uuid] = index;
          objects.push(object);
          for (let j = 0, m = nBindings; j !== m; ++j) {
            bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
          }
        } else if (index < nCachedObjects) {
          knownObject = objects[index];
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[uuid] = firstActiveIndex;
          objects[firstActiveIndex] = object;
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
            let binding = bindingsForPath[index];
            bindingsForPath[index] = lastCached;
            if (binding === void 0) {
              binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
            }
            bindingsForPath[firstActiveIndex] = binding;
          }
        } else if (objects[index] !== knownObject) {
          console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    },
    remove: function() {
      const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
      let nCachedObjects = this.nCachedObjects_;
      for (let i = 0, n = arguments.length; i !== n; ++i) {
        const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
        if (index !== void 0 && index >= nCachedObjects) {
          const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
          indicesByUUID[firstActiveObject.uuid] = index;
          objects[index] = firstActiveObject;
          indicesByUUID[uuid] = lastCachedIndex;
          objects[lastCachedIndex] = object;
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
            bindingsForPath[index] = firstActive;
            bindingsForPath[lastCachedIndex] = binding;
          }
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    },
    uncache: function() {
      const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
      let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
      for (let i = 0, n = arguments.length; i !== n; ++i) {
        const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
        if (index !== void 0) {
          delete indicesByUUID[uuid];
          if (index < nCachedObjects) {
            const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;
            indicesByUUID[lastObject.uuid] = firstActiveIndex;
            objects[firstActiveIndex] = lastObject;
            objects.pop();
            for (let j = 0, m = nBindings; j !== m; ++j) {
              const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
              bindingsForPath[index] = lastCached;
              bindingsForPath[firstActiveIndex] = last;
              bindingsForPath.pop();
            }
          } else {
            const lastIndex = --nObjects, lastObject = objects[lastIndex];
            if (lastIndex > 0) {
              indicesByUUID[lastObject.uuid] = index;
            }
            objects[index] = lastObject;
            objects.pop();
            for (let j = 0, m = nBindings; j !== m; ++j) {
              const bindingsForPath = bindings[j];
              bindingsForPath[index] = bindingsForPath[lastIndex];
              bindingsForPath.pop();
            }
          }
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    },
    subscribe_: function(path, parsedPath) {
      const indicesByPath = this._bindingsIndicesByPath;
      let index = indicesByPath[path];
      const bindings = this._bindings;
      if (index !== void 0)
        return bindings[index];
      const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
      index = bindings.length;
      indicesByPath[path] = index;
      paths.push(path);
      parsedPaths.push(parsedPath);
      bindings.push(bindingsForPath);
      for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
        const object = objects[i];
        bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
      }
      return bindingsForPath;
    },
    unsubscribe_: function(path) {
      const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
      if (index !== void 0) {
        const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
        indicesByPath[lastBindingsPath] = index;
        bindings[index] = lastBindings;
        bindings.pop();
        parsedPaths[index] = parsedPaths[lastBindingsIndex];
        parsedPaths.pop();
        paths[index] = paths[lastBindingsIndex];
        paths.pop();
      }
    }
  });
  var AnimationAction = class {
    constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
      this._mixer = mixer;
      this._clip = clip;
      this._localRoot = localRoot;
      this.blendMode = blendMode;
      const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
      const interpolantSettings = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
      for (let i = 0; i !== nTracks; ++i) {
        const interpolant = tracks[i].createInterpolant(null);
        interpolants[i] = interpolant;
        interpolant.settings = interpolantSettings;
      }
      this._interpolantSettings = interpolantSettings;
      this._interpolants = interpolants;
      this._propertyBindings = new Array(nTracks);
      this._cacheIndex = null;
      this._byClipCacheIndex = null;
      this._timeScaleInterpolant = null;
      this._weightInterpolant = null;
      this.loop = LoopRepeat;
      this._loopCount = -1;
      this._startTime = null;
      this.time = 0;
      this.timeScale = 1;
      this._effectiveTimeScale = 1;
      this.weight = 1;
      this._effectiveWeight = 1;
      this.repetitions = Infinity;
      this.paused = false;
      this.enabled = true;
      this.clampWhenFinished = false;
      this.zeroSlopeAtStart = true;
      this.zeroSlopeAtEnd = true;
    }
    play() {
      this._mixer._activateAction(this);
      return this;
    }
    stop() {
      this._mixer._deactivateAction(this);
      return this.reset();
    }
    reset() {
      this.paused = false;
      this.enabled = true;
      this.time = 0;
      this._loopCount = -1;
      this._startTime = null;
      return this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(time) {
      this._startTime = time;
      return this;
    }
    setLoop(mode, repetitions) {
      this.loop = mode;
      this.repetitions = repetitions;
      return this;
    }
    setEffectiveWeight(weight) {
      this.weight = weight;
      this._effectiveWeight = this.enabled ? weight : 0;
      return this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(duration) {
      return this._scheduleFading(duration, 0, 1);
    }
    fadeOut(duration) {
      return this._scheduleFading(duration, 1, 0);
    }
    crossFadeFrom(fadeOutAction, duration, warp) {
      fadeOutAction.fadeOut(duration);
      this.fadeIn(duration);
      if (warp) {
        const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
        fadeOutAction.warp(1, startEndRatio, duration);
        this.warp(endStartRatio, 1, duration);
      }
      return this;
    }
    crossFadeTo(fadeInAction, duration, warp) {
      return fadeInAction.crossFadeFrom(this, duration, warp);
    }
    stopFading() {
      const weightInterpolant = this._weightInterpolant;
      if (weightInterpolant !== null) {
        this._weightInterpolant = null;
        this._mixer._takeBackControlInterpolant(weightInterpolant);
      }
      return this;
    }
    setEffectiveTimeScale(timeScale) {
      this.timeScale = timeScale;
      this._effectiveTimeScale = this.paused ? 0 : timeScale;
      return this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(duration) {
      this.timeScale = this._clip.duration / duration;
      return this.stopWarping();
    }
    syncWith(action) {
      this.time = action.time;
      this.timeScale = action.timeScale;
      return this.stopWarping();
    }
    halt(duration) {
      return this.warp(this._effectiveTimeScale, 0, duration);
    }
    warp(startTimeScale, endTimeScale, duration) {
      const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
      let interpolant = this._timeScaleInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._timeScaleInterpolant = interpolant;
      }
      const times = interpolant.parameterPositions, values = interpolant.sampleValues;
      times[0] = now2;
      times[1] = now2 + duration;
      values[0] = startTimeScale / timeScale;
      values[1] = endTimeScale / timeScale;
      return this;
    }
    stopWarping() {
      const timeScaleInterpolant = this._timeScaleInterpolant;
      if (timeScaleInterpolant !== null) {
        this._timeScaleInterpolant = null;
        this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
      }
      return this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(time, deltaTime, timeDirection, accuIndex) {
      if (!this.enabled) {
        this._updateWeight(time);
        return;
      }
      const startTime = this._startTime;
      if (startTime !== null) {
        const timeRunning = (time - startTime) * timeDirection;
        if (timeRunning < 0 || timeDirection === 0) {
          return;
        }
        this._startTime = null;
        deltaTime = timeDirection * timeRunning;
      }
      deltaTime *= this._updateTimeScale(time);
      const clipTime = this._updateTime(deltaTime);
      const weight = this._updateWeight(time);
      if (weight > 0) {
        const interpolants = this._interpolants;
        const propertyMixers = this._propertyBindings;
        switch (this.blendMode) {
          case AdditiveAnimationBlendMode:
            for (let j = 0, m = interpolants.length; j !== m; ++j) {
              interpolants[j].evaluate(clipTime);
              propertyMixers[j].accumulateAdditive(weight);
            }
            break;
          case NormalAnimationBlendMode:
          default:
            for (let j = 0, m = interpolants.length; j !== m; ++j) {
              interpolants[j].evaluate(clipTime);
              propertyMixers[j].accumulate(accuIndex, weight);
            }
        }
      }
    }
    _updateWeight(time) {
      let weight = 0;
      if (this.enabled) {
        weight = this.weight;
        const interpolant = this._weightInterpolant;
        if (interpolant !== null) {
          const interpolantValue = interpolant.evaluate(time)[0];
          weight *= interpolantValue;
          if (time > interpolant.parameterPositions[1]) {
            this.stopFading();
            if (interpolantValue === 0) {
              this.enabled = false;
            }
          }
        }
      }
      this._effectiveWeight = weight;
      return weight;
    }
    _updateTimeScale(time) {
      let timeScale = 0;
      if (!this.paused) {
        timeScale = this.timeScale;
        const interpolant = this._timeScaleInterpolant;
        if (interpolant !== null) {
          const interpolantValue = interpolant.evaluate(time)[0];
          timeScale *= interpolantValue;
          if (time > interpolant.parameterPositions[1]) {
            this.stopWarping();
            if (timeScale === 0) {
              this.paused = true;
            } else {
              this.timeScale = timeScale;
            }
          }
        }
      }
      this._effectiveTimeScale = timeScale;
      return timeScale;
    }
    _updateTime(deltaTime) {
      const duration = this._clip.duration;
      const loop = this.loop;
      let time = this.time + deltaTime;
      let loopCount = this._loopCount;
      const pingPong = loop === LoopPingPong;
      if (deltaTime === 0) {
        if (loopCount === -1)
          return time;
        return pingPong && (loopCount & 1) === 1 ? duration - time : time;
      }
      if (loop === LoopOnce) {
        if (loopCount === -1) {
          this._loopCount = 0;
          this._setEndings(true, true, false);
        }
        handle_stop: {
          if (time >= duration) {
            time = duration;
          } else if (time < 0) {
            time = 0;
          } else {
            this.time = time;
            break handle_stop;
          }
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime < 0 ? -1 : 1
          });
        }
      } else {
        if (loopCount === -1) {
          if (deltaTime >= 0) {
            loopCount = 0;
            this._setEndings(true, this.repetitions === 0, pingPong);
          } else {
            this._setEndings(this.repetitions === 0, true, pingPong);
          }
        }
        if (time >= duration || time < 0) {
          const loopDelta = Math.floor(time / duration);
          time -= duration * loopDelta;
          loopCount += Math.abs(loopDelta);
          const pending = this.repetitions - loopCount;
          if (pending <= 0) {
            if (this.clampWhenFinished)
              this.paused = true;
            else
              this.enabled = false;
            time = deltaTime > 0 ? duration : 0;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: deltaTime > 0 ? 1 : -1
            });
          } else {
            if (pending === 1) {
              const atStart = deltaTime < 0;
              this._setEndings(atStart, !atStart, pingPong);
            } else {
              this._setEndings(false, false, pingPong);
            }
            this._loopCount = loopCount;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta
            });
          }
        } else {
          this.time = time;
        }
        if (pingPong && (loopCount & 1) === 1) {
          return duration - time;
        }
      }
      return time;
    }
    _setEndings(atStart, atEnd, pingPong) {
      const settings4 = this._interpolantSettings;
      if (pingPong) {
        settings4.endingStart = ZeroSlopeEnding;
        settings4.endingEnd = ZeroSlopeEnding;
      } else {
        if (atStart) {
          settings4.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings4.endingStart = WrapAroundEnding;
        }
        if (atEnd) {
          settings4.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings4.endingEnd = WrapAroundEnding;
        }
      }
    }
    _scheduleFading(duration, weightNow, weightThen) {
      const mixer = this._mixer, now2 = mixer.time;
      let interpolant = this._weightInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._weightInterpolant = interpolant;
      }
      const times = interpolant.parameterPositions, values = interpolant.sampleValues;
      times[0] = now2;
      values[0] = weightNow;
      times[1] = now2 + duration;
      values[1] = weightThen;
      return this;
    }
  };
  function AnimationMixer(root) {
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: AnimationMixer,
    _bindAction: function(action, prototypeAction) {
      const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
      let bindingsByName = bindingsByRoot[rootUuid];
      if (bindingsByName === void 0) {
        bindingsByName = {};
        bindingsByRoot[rootUuid] = bindingsByName;
      }
      for (let i = 0; i !== nTracks; ++i) {
        const track = tracks[i], trackName = track.name;
        let binding = bindingsByName[trackName];
        if (binding !== void 0) {
          bindings[i] = binding;
        } else {
          binding = bindings[i];
          if (binding !== void 0) {
            if (binding._cacheIndex === null) {
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
            }
            continue;
          }
          const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
          binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
          ++binding.referenceCount;
          this._addInactiveBinding(binding, rootUuid, trackName);
          bindings[i] = binding;
        }
        interpolants[i].resultBuffer = binding.buffer;
      }
    },
    _activateAction: function(action) {
      if (!this._isActiveAction(action)) {
        if (action._cacheIndex === null) {
          const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
          this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
          this._addInactiveAction(action, clipUuid, rootUuid);
        }
        const bindings = action._propertyBindings;
        for (let i = 0, n = bindings.length; i !== n; ++i) {
          const binding = bindings[i];
          if (binding.useCount++ === 0) {
            this._lendBinding(binding);
            binding.saveOriginalState();
          }
        }
        this._lendAction(action);
      }
    },
    _deactivateAction: function(action) {
      if (this._isActiveAction(action)) {
        const bindings = action._propertyBindings;
        for (let i = 0, n = bindings.length; i !== n; ++i) {
          const binding = bindings[i];
          if (--binding.useCount === 0) {
            binding.restoreOriginalState();
            this._takeBackBinding(binding);
          }
        }
        this._takeBackAction(action);
      }
    },
    _initMemoryManager: function() {
      this._actions = [];
      this._nActiveActions = 0;
      this._actionsByClip = {};
      this._bindings = [];
      this._nActiveBindings = 0;
      this._bindingsByRootAndName = {};
      this._controlInterpolants = [];
      this._nActiveControlInterpolants = 0;
      const scope = this;
      this.stats = {
        actions: {
          get total() {
            return scope._actions.length;
          },
          get inUse() {
            return scope._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return scope._bindings.length;
          },
          get inUse() {
            return scope._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return scope._controlInterpolants.length;
          },
          get inUse() {
            return scope._nActiveControlInterpolants;
          }
        }
      };
    },
    _isActiveAction: function(action) {
      const index = action._cacheIndex;
      return index !== null && index < this._nActiveActions;
    },
    _addInactiveAction: function(action, clipUuid, rootUuid) {
      const actions = this._actions, actionsByClip = this._actionsByClip;
      let actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip === void 0) {
        actionsForClip = {
          knownActions: [action],
          actionByRoot: {}
        };
        action._byClipCacheIndex = 0;
        actionsByClip[clipUuid] = actionsForClip;
      } else {
        const knownActions = actionsForClip.knownActions;
        action._byClipCacheIndex = knownActions.length;
        knownActions.push(action);
      }
      action._cacheIndex = actions.length;
      actions.push(action);
      actionsForClip.actionByRoot[rootUuid] = action;
    },
    _removeInactiveAction: function(action) {
      const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
      lastInactiveAction._cacheIndex = cacheIndex;
      actions[cacheIndex] = lastInactiveAction;
      actions.pop();
      action._cacheIndex = null;
      const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
      lastKnownAction._byClipCacheIndex = byClipCacheIndex;
      knownActionsForClip[byClipCacheIndex] = lastKnownAction;
      knownActionsForClip.pop();
      action._byClipCacheIndex = null;
      const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
      delete actionByRoot[rootUuid];
      if (knownActionsForClip.length === 0) {
        delete actionsByClip[clipUuid];
      }
      this._removeInactiveBindingsForAction(action);
    },
    _removeInactiveBindingsForAction: function(action) {
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (--binding.referenceCount === 0) {
          this._removeInactiveBinding(binding);
        }
      }
    },
    _lendAction: function(action) {
      const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
      action._cacheIndex = lastActiveIndex;
      actions[lastActiveIndex] = action;
      firstInactiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = firstInactiveAction;
    },
    _takeBackAction: function(action) {
      const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
      action._cacheIndex = firstInactiveIndex;
      actions[firstInactiveIndex] = action;
      lastActiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = lastActiveAction;
    },
    _addInactiveBinding: function(binding, rootUuid, trackName) {
      const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
      let bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName === void 0) {
        bindingByName = {};
        bindingsByRoot[rootUuid] = bindingByName;
      }
      bindingByName[trackName] = binding;
      binding._cacheIndex = bindings.length;
      bindings.push(binding);
    },
    _removeInactiveBinding: function(binding) {
      const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
      lastInactiveBinding._cacheIndex = cacheIndex;
      bindings[cacheIndex] = lastInactiveBinding;
      bindings.pop();
      delete bindingByName[trackName];
      if (Object.keys(bindingByName).length === 0) {
        delete bindingsByRoot[rootUuid];
      }
    },
    _lendBinding: function(binding) {
      const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
      binding._cacheIndex = lastActiveIndex;
      bindings[lastActiveIndex] = binding;
      firstInactiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = firstInactiveBinding;
    },
    _takeBackBinding: function(binding) {
      const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
      binding._cacheIndex = firstInactiveIndex;
      bindings[firstInactiveIndex] = binding;
      lastActiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = lastActiveBinding;
    },
    _lendControlInterpolant: function() {
      const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
      let interpolant = interpolants[lastActiveIndex];
      if (interpolant === void 0) {
        interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
        interpolant.__cacheIndex = lastActiveIndex;
        interpolants[lastActiveIndex] = interpolant;
      }
      return interpolant;
    },
    _takeBackControlInterpolant: function(interpolant) {
      const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
      interpolant.__cacheIndex = firstInactiveIndex;
      interpolants[firstInactiveIndex] = interpolant;
      lastActiveInterpolant.__cacheIndex = prevIndex;
      interpolants[prevIndex] = lastActiveInterpolant;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    clipAction: function(clip, optionalRoot, blendMode) {
      const root = optionalRoot || this._root, rootUuid = root.uuid;
      let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
      const clipUuid = clipObject !== null ? clipObject.uuid : clip;
      const actionsForClip = this._actionsByClip[clipUuid];
      let prototypeAction = null;
      if (blendMode === void 0) {
        if (clipObject !== null) {
          blendMode = clipObject.blendMode;
        } else {
          blendMode = NormalAnimationBlendMode;
        }
      }
      if (actionsForClip !== void 0) {
        const existingAction = actionsForClip.actionByRoot[rootUuid];
        if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
          return existingAction;
        }
        prototypeAction = actionsForClip.knownActions[0];
        if (clipObject === null)
          clipObject = prototypeAction._clip;
      }
      if (clipObject === null)
        return null;
      const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
      this._bindAction(newAction, prototypeAction);
      this._addInactiveAction(newAction, clipUuid, rootUuid);
      return newAction;
    },
    existingAction: function(clip, optionalRoot) {
      const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
      if (actionsForClip !== void 0) {
        return actionsForClip.actionByRoot[rootUuid] || null;
      }
      return null;
    },
    stopAllAction: function() {
      const actions = this._actions, nActions = this._nActiveActions;
      for (let i = nActions - 1; i >= 0; --i) {
        actions[i].stop();
      }
      return this;
    },
    update: function(deltaTime) {
      deltaTime *= this.timeScale;
      const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
      for (let i = 0; i !== nActions; ++i) {
        const action = actions[i];
        action._update(time, deltaTime, timeDirection, accuIndex);
      }
      const bindings = this._bindings, nBindings = this._nActiveBindings;
      for (let i = 0; i !== nBindings; ++i) {
        bindings[i].apply(accuIndex);
      }
      return this;
    },
    setTime: function(timeInSeconds) {
      this.time = 0;
      for (let i = 0; i < this._actions.length; i++) {
        this._actions[i].time = 0;
      }
      return this.update(timeInSeconds);
    },
    getRoot: function() {
      return this._root;
    },
    uncacheClip: function(clip) {
      const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip !== void 0) {
        const actionsToRemove = actionsForClip.knownActions;
        for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
          const action = actionsToRemove[i];
          this._deactivateAction(action);
          const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
          action._cacheIndex = null;
          action._byClipCacheIndex = null;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          this._removeInactiveBindingsForAction(action);
        }
        delete actionsByClip[clipUuid];
      }
    },
    uncacheRoot: function(root) {
      const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
      for (const clipUuid in actionsByClip) {
        const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
        if (action !== void 0) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
      const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName !== void 0) {
        for (const trackName in bindingByName) {
          const binding = bindingByName[trackName];
          binding.restoreOriginalState();
          this._removeInactiveBinding(binding);
        }
      }
    },
    uncacheAction: function(clip, optionalRoot) {
      const action = this.existingAction(clip, optionalRoot);
      if (action !== null) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
  });
  var Uniform = class {
    constructor(value) {
      if (typeof value === "string") {
        console.warn("THREE.Uniform: Type parameter is no longer needed.");
        value = arguments[1];
      }
      this.value = value;
    }
    clone() {
      return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
    }
  };
  function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
    InterleavedBuffer.call(this, array, stride);
    this.meshPerAttribute = meshPerAttribute || 1;
  }
  InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
    constructor: InstancedInterleavedBuffer,
    isInstancedInterleavedBuffer: true,
    copy: function(source) {
      InterleavedBuffer.prototype.copy.call(this, source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    },
    clone: function(data) {
      const ib = InterleavedBuffer.prototype.clone.call(this, data);
      ib.meshPerAttribute = this.meshPerAttribute;
      return ib;
    },
    toJSON: function(data) {
      const json = InterleavedBuffer.prototype.toJSON.call(this, data);
      json.isInstancedInterleavedBuffer = true;
      json.meshPerAttribute = this.meshPerAttribute;
      return json;
    }
  });
  function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
    this.buffer = buffer;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.version = 0;
  }
  Object.defineProperty(GLBufferAttribute.prototype, "needsUpdate", {
    set: function(value) {
      if (value === true)
        this.version++;
    }
  });
  Object.assign(GLBufferAttribute.prototype, {
    isGLBufferAttribute: true,
    setBuffer: function(buffer) {
      this.buffer = buffer;
      return this;
    },
    setType: function(type, elementSize) {
      this.type = type;
      this.elementSize = elementSize;
      return this;
    },
    setItemSize: function(itemSize) {
      this.itemSize = itemSize;
      return this;
    },
    setCount: function(count) {
      this.count = count;
      return this;
    }
  });
  function Raycaster(origin, direction, near, far) {
    this.ray = new Ray(origin, direction);
    this.near = near || 0;
    this.far = far || Infinity;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: {threshold: 1},
      LOD: {},
      Points: {threshold: 1},
      Sprite: {}
    };
    Object.defineProperties(this.params, {
      PointCloud: {
        get: function() {
          console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
          return this.Points;
        }
      }
    });
  }
  function ascSort(a, b) {
    return a.distance - b.distance;
  }
  function intersectObject(object, raycaster, intersects2, recursive) {
    if (object.layers.test(raycaster.layers)) {
      object.raycast(raycaster, intersects2);
    }
    if (recursive === true) {
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        intersectObject(children[i], raycaster, intersects2, true);
      }
    }
  }
  Object.assign(Raycaster.prototype, {
    set: function(origin, direction) {
      this.ray.set(origin, direction);
    },
    setFromCamera: function(coords, camera2) {
      if (camera2 && camera2.isPerspectiveCamera) {
        this.ray.origin.setFromMatrixPosition(camera2.matrixWorld);
        this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera2).sub(this.ray.origin).normalize();
        this.camera = camera2;
      } else if (camera2 && camera2.isOrthographicCamera) {
        this.ray.origin.set(coords.x, coords.y, (camera2.near + camera2.far) / (camera2.near - camera2.far)).unproject(camera2);
        this.ray.direction.set(0, 0, -1).transformDirection(camera2.matrixWorld);
        this.camera = camera2;
      } else {
        console.error("THREE.Raycaster: Unsupported camera type.");
      }
    },
    intersectObject: function(object, recursive, optionalTarget) {
      const intersects2 = optionalTarget || [];
      intersectObject(object, this, intersects2, recursive);
      intersects2.sort(ascSort);
      return intersects2;
    },
    intersectObjects: function(objects, recursive, optionalTarget) {
      const intersects2 = optionalTarget || [];
      if (Array.isArray(objects) === false) {
        console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
        return intersects2;
      }
      for (let i = 0, l = objects.length; i < l; i++) {
        intersectObject(objects[i], this, intersects2, recursive);
      }
      intersects2.sort(ascSort);
      return intersects2;
    }
  });
  var Spherical = class {
    constructor(radius = 1, phi = 0, theta = 0) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this;
    }
    makeSafe() {
      const EPS = 1e-6;
      this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
      return this;
    }
    setFromVector3(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
      this.radius = Math.sqrt(x * x + y * y + z * z);
      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(x, z);
        this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
      }
      return this;
    }
  };
  var _vector$7 = /* @__PURE__ */ new Vector2();
  var Box2 = class {
    constructor(min, max) {
      Object.defineProperty(this, "isBox2", {value: true});
      this.min = min !== void 0 ? min : new Vector2(Infinity, Infinity);
      this.max = max !== void 0 ? max : new Vector2(-Infinity, -Infinity);
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
    setFromCenterAndSize(center, size) {
      const halfSize = _vector$7.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = Infinity;
      this.max.x = this.max.y = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(target) {
      if (target === void 0) {
        console.warn("THREE.Box2: .getCenter() target is now required");
        target = new Vector2();
      }
      return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
      if (target === void 0) {
        console.warn("THREE.Box2: .getSize() target is now required");
        target = new Vector2();
      }
      return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
    getParameter(point, target) {
      if (target === void 0) {
        console.warn("THREE.Box2: .getParameter() target is now required");
        target = new Vector2();
      }
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    }
    clampPoint(point, target) {
      if (target === void 0) {
        console.warn("THREE.Box2: .clampPoint() target is now required");
        target = new Vector2();
      }
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      const clampedPoint = _vector$7.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  var _startP = /* @__PURE__ */ new Vector3();
  var _startEnd = /* @__PURE__ */ new Vector3();
  var Line3 = class {
    constructor(start, end) {
      this.start = start !== void 0 ? start : new Vector3();
      this.end = end !== void 0 ? end : new Vector3();
    }
    set(start, end) {
      this.start.copy(start);
      this.end.copy(end);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(line) {
      this.start.copy(line.start);
      this.end.copy(line.end);
      return this;
    }
    getCenter(target) {
      if (target === void 0) {
        console.warn("THREE.Line3: .getCenter() target is now required");
        target = new Vector3();
      }
      return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(target) {
      if (target === void 0) {
        console.warn("THREE.Line3: .delta() target is now required");
        target = new Vector3();
      }
      return target.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(t, target) {
      if (target === void 0) {
        console.warn("THREE.Line3: .at() target is now required");
        target = new Vector3();
      }
      return this.delta(target).multiplyScalar(t).add(this.start);
    }
    closestPointToPointParameter(point, clampToLine) {
      _startP.subVectors(point, this.start);
      _startEnd.subVectors(this.end, this.start);
      const startEnd2 = _startEnd.dot(_startEnd);
      const startEnd_startP = _startEnd.dot(_startP);
      let t = startEnd_startP / startEnd2;
      if (clampToLine) {
        t = MathUtils.clamp(t, 0, 1);
      }
      return t;
    }
    closestPointToPoint(point, clampToLine, target) {
      const t = this.closestPointToPointParameter(point, clampToLine);
      if (target === void 0) {
        console.warn("THREE.Line3: .closestPointToPoint() target is now required");
        target = new Vector3();
      }
      return this.delta(target).multiplyScalar(t).add(this.start);
    }
    applyMatrix4(matrix) {
      this.start.applyMatrix4(matrix);
      this.end.applyMatrix4(matrix);
      return this;
    }
    equals(line) {
      return line.start.equals(this.start) && line.end.equals(this.end);
    }
  };
  function ImmediateRenderObject(material) {
    Object3D.call(this);
    this.material = material;
    this.render = function() {
    };
    this.hasPositions = false;
    this.hasNormals = false;
    this.hasColors = false;
    this.hasUvs = false;
    this.positionArray = null;
    this.normalArray = null;
    this.colorArray = null;
    this.uvArray = null;
    this.count = 0;
  }
  ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
  ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
  ImmediateRenderObject.prototype.isImmediateRenderObject = true;
  var _vector$9 = /* @__PURE__ */ new Vector3();
  var _boneMatrix = /* @__PURE__ */ new Matrix4();
  var _matrixWorldInv = /* @__PURE__ */ new Matrix4();
  var SkeletonHelper = class extends LineSegments {
    constructor(object) {
      const bones = getBoneList(object);
      const geometry = new BufferGeometry();
      const vertices = [];
      const colors = [];
      const color1 = new Color(0, 0, 1);
      const color2 = new Color(0, 1, 0);
      for (let i = 0; i < bones.length; i++) {
        const bone = bones[i];
        if (bone.parent && bone.parent.isBone) {
          vertices.push(0, 0, 0);
          vertices.push(0, 0, 0);
          colors.push(color1.r, color1.g, color1.b);
          colors.push(color2.r, color2.g, color2.b);
        }
      }
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      const material = new LineBasicMaterial({vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true});
      super(geometry, material);
      this.type = "SkeletonHelper";
      this.isSkeletonHelper = true;
      this.root = object;
      this.bones = bones;
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(force) {
      const bones = this.bones;
      const geometry = this.geometry;
      const position = geometry.getAttribute("position");
      _matrixWorldInv.copy(this.root.matrixWorld).invert();
      for (let i = 0, j = 0; i < bones.length; i++) {
        const bone = bones[i];
        if (bone.parent && bone.parent.isBone) {
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
          _vector$9.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j, _vector$9.x, _vector$9.y, _vector$9.z);
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
          _vector$9.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j + 1, _vector$9.x, _vector$9.y, _vector$9.z);
          j += 2;
        }
      }
      geometry.getAttribute("position").needsUpdate = true;
      super.updateMatrixWorld(force);
    }
  };
  function getBoneList(object) {
    const boneList = [];
    if (object && object.isBone) {
      boneList.push(object);
    }
    for (let i = 0; i < object.children.length; i++) {
      boneList.push.apply(boneList, getBoneList(object.children[i]));
    }
    return boneList;
  }
  var GridHelper = class extends LineSegments {
    constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
      color1 = new Color(color1);
      color2 = new Color(color2);
      const center = divisions / 2;
      const step = size / divisions;
      const halfSize = size / 2;
      const vertices = [], colors = [];
      for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
        vertices.push(-halfSize, 0, k, halfSize, 0, k);
        vertices.push(k, 0, -halfSize, k, 0, halfSize);
        const color = i === center ? color1 : color2;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
      }
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      const material = new LineBasicMaterial({vertexColors: true, toneMapped: false});
      super(geometry, material);
      this.type = "GridHelper";
    }
  };
  var _floatView = new Float32Array(1);
  var _int32View = new Int32Array(_floatView.buffer);
  var LOD_MIN = 4;
  var LOD_MAX = 8;
  var SIZE_MAX = Math.pow(2, LOD_MAX);
  var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
  var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  var ENCODINGS = {
    [LinearEncoding]: 0,
    [sRGBEncoding]: 1,
    [RGBEEncoding]: 2,
    [RGBM7Encoding]: 3,
    [RGBM16Encoding]: 4,
    [RGBDEncoding]: 5,
    [GammaEncoding]: 6
  };
  var PHI = (1 + Math.sqrt(5)) / 2;
  var INV_PHI = 1 / PHI;
  var _axisDirections = [
    /* @__PURE__ */ new Vector3(1, 1, 1),
    /* @__PURE__ */ new Vector3(-1, 1, 1),
    /* @__PURE__ */ new Vector3(1, 1, -1),
    /* @__PURE__ */ new Vector3(-1, 1, -1),
    /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
    /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
    /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
    /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
  ];
  Curve.create = function(construct, getPoint) {
    console.log("THREE.Curve.create() has been deprecated");
    construct.prototype = Object.create(Curve.prototype);
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;
    return construct;
  };
  Object.assign(CurvePath.prototype, {
    createPointsGeometry: function(divisions) {
      console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
      const pts = this.getPoints(divisions);
      return this.createGeometry(pts);
    },
    createSpacedPointsGeometry: function(divisions) {
      console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
      const pts = this.getSpacedPoints(divisions);
      return this.createGeometry(pts);
    },
    createGeometry: function(points) {
      console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
      const geometry = new Geometry();
      for (let i = 0, l = points.length; i < l; i++) {
        const point = points[i];
        geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
      }
      return geometry;
    }
  });
  Object.assign(Path.prototype, {
    fromPoints: function(points) {
      console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
      return this.setFromPoints(points);
    }
  });
  function ClosedSplineCurve3(points) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    CatmullRomCurve3.call(this, points);
    this.type = "catmullrom";
    this.closed = true;
  }
  ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
  function SplineCurve3(points) {
    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    CatmullRomCurve3.call(this, points);
    this.type = "catmullrom";
  }
  SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
  function Spline(points) {
    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
    CatmullRomCurve3.call(this, points);
    this.type = "catmullrom";
  }
  Spline.prototype = Object.create(CatmullRomCurve3.prototype);
  Object.assign(Spline.prototype, {
    initFromArray: function() {
      console.error("THREE.Spline: .initFromArray() has been removed.");
    },
    getControlPointsArray: function() {
      console.error("THREE.Spline: .getControlPointsArray() has been removed.");
    },
    reparametrizeByArcLength: function() {
      console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
    }
  });
  GridHelper.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  };
  SkeletonHelper.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  };
  Object.assign(Loader.prototype, {
    extractUrlBase: function(url) {
      console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
      return LoaderUtils.extractUrlBase(url);
    }
  });
  Loader.Handlers = {
    add: function() {
      console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
    },
    get: function() {
      console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
    }
  };
  Object.assign(Box2.prototype, {
    center: function(optionalTarget) {
      console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    },
    empty: function() {
      console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    },
    isIntersectionBox: function(box) {
      console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    },
    size: function(optionalTarget) {
      console.warn("THREE.Box2: .size() has been renamed to .getSize().");
      return this.getSize(optionalTarget);
    }
  });
  Object.assign(Box3.prototype, {
    center: function(optionalTarget) {
      console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    },
    empty: function() {
      console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    },
    isIntersectionBox: function(box) {
      console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    },
    isIntersectionSphere: function(sphere) {
      console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
      return this.intersectsSphere(sphere);
    },
    size: function(optionalTarget) {
      console.warn("THREE.Box3: .size() has been renamed to .getSize().");
      return this.getSize(optionalTarget);
    }
  });
  Object.assign(Sphere.prototype, {
    empty: function() {
      console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    }
  });
  Frustum.prototype.setFromMatrix = function(m) {
    console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
    return this.setFromProjectionMatrix(m);
  };
  Line3.prototype.center = function(optionalTarget) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  };
  Object.assign(MathUtils, {
    random16: function() {
      console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
      return Math.random();
    },
    nearestPowerOfTwo: function(value) {
      console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
      return MathUtils.floorPowerOfTwo(value);
    },
    nextPowerOfTwo: function(value) {
      console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
      return MathUtils.ceilPowerOfTwo(value);
    }
  });
  Object.assign(Matrix3.prototype, {
    flattenToArrayOffset: function(array, offset) {
      console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(array, offset);
    },
    multiplyVector3: function(vector) {
      console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
      return vector.applyMatrix3(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    },
    applyToBufferAttribute: function(attribute) {
      console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
      return attribute.applyMatrix3(this);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    },
    getInverse: function(matrix) {
      console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
      return this.copy(matrix).invert();
    }
  });
  Object.assign(Matrix4.prototype, {
    extractPosition: function(m) {
      console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
      return this.copyPosition(m);
    },
    flattenToArrayOffset: function(array, offset) {
      console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(array, offset);
    },
    getPosition: function() {
      console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
      return new Vector3().setFromMatrixColumn(this, 3);
    },
    setRotationFromQuaternion: function(q) {
      console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
      return this.makeRotationFromQuaternion(q);
    },
    multiplyToArray: function() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    },
    multiplyVector3: function(vector) {
      console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    },
    multiplyVector4: function(vector) {
      console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    },
    rotateAxis: function(v) {
      console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
      v.transformDirection(this);
    },
    crossVector: function(vector) {
      console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    },
    translate: function() {
      console.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function() {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function() {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    applyToBufferAttribute: function(attribute) {
      console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
      return attribute.applyMatrix4(this);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    },
    makeFrustum: function(left, right, bottom, top, near, far) {
      console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
      return this.makePerspective(left, right, top, bottom, near, far);
    },
    getInverse: function(matrix) {
      console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
      return this.copy(matrix).invert();
    }
  });
  Plane.prototype.isIntersectionLine = function(line) {
    console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
    return this.intersectsLine(line);
  };
  Object.assign(Quaternion.prototype, {
    multiplyVector3: function(vector) {
      console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
      return vector.applyQuaternion(this);
    },
    inverse: function() {
      console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
      return this.invert();
    }
  });
  Object.assign(Ray.prototype, {
    isIntersectionBox: function(box) {
      console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    },
    isIntersectionPlane: function(plane) {
      console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
      return this.intersectsPlane(plane);
    },
    isIntersectionSphere: function(sphere) {
      console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
      return this.intersectsSphere(sphere);
    }
  });
  Object.assign(Triangle.prototype, {
    area: function() {
      console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
      return this.getArea();
    },
    barycoordFromPoint: function(point, target) {
      console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
      return this.getBarycoord(point, target);
    },
    midpoint: function(target) {
      console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
      return this.getMidpoint(target);
    },
    normal: function(target) {
      console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
      return this.getNormal(target);
    },
    plane: function(target) {
      console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
      return this.getPlane(target);
    }
  });
  Object.assign(Triangle, {
    barycoordFromPoint: function(point, a, b, c, target) {
      console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
      return Triangle.getBarycoord(point, a, b, c, target);
    },
    normal: function(a, b, c, target) {
      console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
      return Triangle.getNormal(a, b, c, target);
    }
  });
  Object.assign(Shape.prototype, {
    extractAllPoints: function(divisions) {
      console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
      return this.extractPoints(divisions);
    },
    extrude: function(options) {
      console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
      return new ExtrudeGeometry(this, options);
    },
    makeGeometry: function(options) {
      console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
      return new ShapeGeometry(this, options);
    }
  });
  Object.assign(Vector2.prototype, {
    fromAttribute: function(attribute, index, offset) {
      console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index, offset);
    },
    distanceToManhattan: function(v) {
      console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
      return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function() {
      console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    }
  });
  Object.assign(Vector3.prototype, {
    setEulerFromRotationMatrix: function() {
      console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    },
    setEulerFromQuaternion: function() {
      console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    },
    getPositionFromMatrix: function(m) {
      console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
      return this.setFromMatrixPosition(m);
    },
    getScaleFromMatrix: function(m) {
      console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
      return this.setFromMatrixScale(m);
    },
    getColumnFromMatrix: function(index, matrix) {
      console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
      return this.setFromMatrixColumn(matrix, index);
    },
    applyProjection: function(m) {
      console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
      return this.applyMatrix4(m);
    },
    fromAttribute: function(attribute, index, offset) {
      console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index, offset);
    },
    distanceToManhattan: function(v) {
      console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
      return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function() {
      console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    }
  });
  Object.assign(Vector4.prototype, {
    fromAttribute: function(attribute, index, offset) {
      console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index, offset);
    },
    lengthManhattan: function() {
      console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    }
  });
  Object.assign(Geometry.prototype, {
    computeTangents: function() {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function() {
      console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
    },
    applyMatrix: function(matrix) {
      console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().");
      return this.applyMatrix4(matrix);
    }
  });
  Object.assign(Object3D.prototype, {
    getChildByName: function(name) {
      console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
      return this.getObjectByName(name);
    },
    renderDepth: function() {
      console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
    },
    translate: function(distance, axis) {
      console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
      return this.translateOnAxis(axis, distance);
    },
    getWorldRotation: function() {
      console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
    },
    applyMatrix: function(matrix) {
      console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
      return this.applyMatrix4(matrix);
    }
  });
  Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
      get: function() {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
        return this.rotation.order;
      },
      set: function(value) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
        this.rotation.order = value;
      }
    },
    useQuaternion: {
      get: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      },
      set: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      }
    }
  });
  Object.assign(Mesh.prototype, {
    setDrawMode: function() {
      console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  });
  Object.defineProperties(Mesh.prototype, {
    drawMode: {
      get: function() {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
        return TrianglesDrawMode;
      },
      set: function() {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      }
    }
  });
  Object.defineProperties(LOD.prototype, {
    objects: {
      get: function() {
        console.warn("THREE.LOD: .objects has been renamed to .levels.");
        return this.levels;
      }
    }
  });
  Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
    get: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    },
    set: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    }
  });
  SkinnedMesh.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  };
  Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
    get: function() {
      console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
      return this.arcLengthDivisions;
    },
    set: function(value) {
      console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
      this.arcLengthDivisions = value;
    }
  });
  PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    if (filmGauge !== void 0)
      this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
  };
  Object.defineProperties(Light.prototype, {
    onlyShadow: {
      set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      }
    },
    shadowCameraFov: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
        this.shadow.camera.fov = value;
      }
    },
    shadowCameraLeft: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
        this.shadow.camera.left = value;
      }
    },
    shadowCameraRight: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
        this.shadow.camera.right = value;
      }
    },
    shadowCameraTop: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
        this.shadow.camera.top = value;
      }
    },
    shadowCameraBottom: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
        this.shadow.camera.bottom = value;
      }
    },
    shadowCameraNear: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
        this.shadow.camera.near = value;
      }
    },
    shadowCameraFar: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
        this.shadow.camera.far = value;
      }
    },
    shadowCameraVisible: {
      set: function() {
        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
      }
    },
    shadowBias: {
      set: function(value) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
        this.shadow.bias = value;
      }
    },
    shadowDarkness: {
      set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      }
    },
    shadowMapWidth: {
      set: function(value) {
        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
        this.shadow.mapSize.width = value;
      }
    },
    shadowMapHeight: {
      set: function(value) {
        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
        this.shadow.mapSize.height = value;
      }
    }
  });
  Object.defineProperties(BufferAttribute.prototype, {
    length: {
      get: function() {
        console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
        return this.array.length;
      }
    },
    dynamic: {
      get: function() {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
        return this.usage === DynamicDrawUsage;
      },
      set: function() {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
        this.setUsage(DynamicDrawUsage);
      }
    }
  });
  Object.assign(BufferAttribute.prototype, {
    setDynamic: function(value) {
      console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
      this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
      return this;
    },
    copyIndicesArray: function() {
      console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
    },
    setArray: function() {
      console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    }
  });
  Object.assign(BufferGeometry.prototype, {
    addIndex: function(index) {
      console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
      this.setIndex(index);
    },
    addAttribute: function(name, attribute) {
      console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
      if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
        console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
        return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
      }
      if (name === "index") {
        console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
        this.setIndex(attribute);
        return this;
      }
      return this.setAttribute(name, attribute);
    },
    addDrawCall: function(start, count, indexOffset) {
      if (indexOffset !== void 0) {
        console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
      }
      console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
      this.addGroup(start, count);
    },
    clearDrawCalls: function() {
      console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
      this.clearGroups();
    },
    computeTangents: function() {
      console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
    },
    computeOffsets: function() {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    },
    removeAttribute: function(name) {
      console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
      return this.deleteAttribute(name);
    },
    applyMatrix: function(matrix) {
      console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
      return this.applyMatrix4(matrix);
    }
  });
  Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
      get: function() {
        console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
        return this.groups;
      }
    },
    offsets: {
      get: function() {
        console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
        return this.groups;
      }
    }
  });
  Object.defineProperties(InstancedBufferGeometry.prototype, {
    maxInstancedCount: {
      get: function() {
        console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
        return this.instanceCount;
      },
      set: function(value) {
        console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
        this.instanceCount = value;
      }
    }
  });
  Object.defineProperties(Raycaster.prototype, {
    linePrecision: {
      get: function() {
        console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
        return this.params.Line.threshold;
      },
      set: function(value) {
        console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
        this.params.Line.threshold = value;
      }
    }
  });
  Object.defineProperties(InterleavedBuffer.prototype, {
    dynamic: {
      get: function() {
        console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
        return this.usage === DynamicDrawUsage;
      },
      set: function(value) {
        console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
        this.setUsage(value);
      }
    }
  });
  Object.assign(InterleavedBuffer.prototype, {
    setDynamic: function(value) {
      console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
      this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
      return this;
    },
    setArray: function() {
      console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    }
  });
  Object.assign(ExtrudeBufferGeometry.prototype, {
    getArrays: function() {
      console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
    },
    addShapeList: function() {
      console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
    },
    addShape: function() {
      console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
    }
  });
  Object.assign(Scene.prototype, {
    dispose: function() {
      console.error("THREE.Scene: .dispose() has been removed.");
    }
  });
  Object.defineProperties(Uniform.prototype, {
    dynamic: {
      set: function() {
        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
      }
    },
    onUpdate: {
      value: function() {
        console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
        return this;
      }
    }
  });
  Object.defineProperties(Material.prototype, {
    wrapAround: {
      get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }
    },
    overdraw: {
      get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }
    },
    wrapRGB: {
      get: function() {
        console.warn("THREE.Material: .wrapRGB has been removed.");
        return new Color();
      }
    },
    shading: {
      get: function() {
        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      },
      set: function(value) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = value === FlatShading;
      }
    },
    stencilMask: {
      get: function() {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
        return this.stencilFuncMask;
      },
      set: function(value) {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
        this.stencilFuncMask = value;
      }
    }
  });
  Object.defineProperties(MeshPhongMaterial.prototype, {
    metal: {
      get: function() {
        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
        return false;
      },
      set: function() {
        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
      }
    }
  });
  Object.defineProperties(MeshPhysicalMaterial.prototype, {
    transparency: {
      get: function() {
        console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
        return this.transmission;
      },
      set: function(value) {
        console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
        this.transmission = value;
      }
    }
  });
  Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
      get: function() {
        console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
        return this.extensions.derivatives;
      },
      set: function(value) {
        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
        this.extensions.derivatives = value;
      }
    }
  });
  Object.assign(WebGLRenderer.prototype, {
    clearTarget: function(renderTarget, color, depth, stencil) {
      console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
      this.setRenderTarget(renderTarget);
      this.clear(color, depth, stencil);
    },
    animate: function(callback) {
      console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
      this.setAnimationLoop(callback);
    },
    getCurrentRenderTarget: function() {
      console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
      return this.getRenderTarget();
    },
    getMaxAnisotropy: function() {
      console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
      return this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function() {
      console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
      return this.capabilities.precision;
    },
    resetGLState: function() {
      console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
      return this.state.reset();
    },
    supportsFloatTextures: function() {
      console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
      return this.extensions.get("OES_texture_float");
    },
    supportsHalfFloatTextures: function() {
      console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
      return this.extensions.get("OES_texture_half_float");
    },
    supportsStandardDerivatives: function() {
      console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
      return this.extensions.get("OES_standard_derivatives");
    },
    supportsCompressedTextureS3TC: function() {
      console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
      return this.extensions.get("WEBGL_compressed_texture_s3tc");
    },
    supportsCompressedTexturePVRTC: function() {
      console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
      return this.extensions.get("WEBGL_compressed_texture_pvrtc");
    },
    supportsBlendMinMax: function() {
      console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
      return this.extensions.get("EXT_blend_minmax");
    },
    supportsVertexTextures: function() {
      console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
      return this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
      console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
      return this.extensions.get("ANGLE_instanced_arrays");
    },
    enableScissorTest: function(boolean) {
      console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
      this.setScissorTest(boolean);
    },
    initMaterial: function() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    },
    addPrePlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    },
    addPostPlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    },
    updateShadowMap: function() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    },
    setFaceCulling: function() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    },
    allocTextureUnit: function() {
      console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
    },
    setTexture: function() {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
    },
    setTexture2D: function() {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
    },
    setTextureCube: function() {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
    },
    getActiveMipMapLevel: function() {
      console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
      return this.getActiveMipmapLevel();
    }
  });
  Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
      get: function() {
        return this.shadowMap.enabled;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
        this.shadowMap.enabled = value;
      }
    },
    shadowMapType: {
      get: function() {
        return this.shadowMap.type;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
        this.shadowMap.type = value;
      }
    },
    shadowMapCullFace: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      }
    },
    context: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
        return this.getContext();
      }
    },
    vr: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
        return this.xr;
      }
    },
    gammaInput: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
        return false;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      }
    },
    gammaOutput: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
        return false;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
        this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
      }
    },
    toneMappingWhitePoint: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
        return 1;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      }
    }
  });
  Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      }
    },
    renderReverseSided: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      }
    },
    renderSingleSided: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      }
    }
  });
  Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        return this.texture.wrapS;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        this.texture.wrapS = value;
      }
    },
    wrapT: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
        return this.texture.wrapT;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
        this.texture.wrapT = value;
      }
    },
    magFilter: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
        return this.texture.magFilter;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
        this.texture.magFilter = value;
      }
    },
    minFilter: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
        return this.texture.minFilter;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
        this.texture.minFilter = value;
      }
    },
    anisotropy: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
        return this.texture.anisotropy;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
        this.texture.anisotropy = value;
      }
    },
    offset: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
        return this.texture.offset;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
        this.texture.offset = value;
      }
    },
    repeat: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
        return this.texture.repeat;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
        this.texture.repeat = value;
      }
    },
    format: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
        return this.texture.format;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
        this.texture.format = value;
      }
    },
    type: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
        return this.texture.type;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
        this.texture.type = value;
      }
    },
    generateMipmaps: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
        return this.texture.generateMipmaps;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
        this.texture.generateMipmaps = value;
      }
    }
  });
  Object.defineProperties(Audio.prototype, {
    load: {
      value: function(file) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        const scope = this;
        const audioLoader = new AudioLoader();
        audioLoader.load(file, function(buffer) {
          scope.setBuffer(buffer);
        });
        return this;
      }
    },
    startTime: {
      set: function() {
        console.warn("THREE.Audio: .startTime is now .play( delay ).");
      }
    }
  });
  AudioAnalyser.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData();
  };
  CubeCamera.prototype.updateCubeMap = function(renderer3, scene2) {
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
    return this.update(renderer3, scene2);
  };
  CubeCamera.prototype.clear = function(renderer3, color, depth, stencil) {
    console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
    return this.renderTarget.clear(renderer3, color, depth, stencil);
  };
  ImageUtils.crossOrigin = void 0;
  ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const loader = new TextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(url, onLoad, void 0, onError);
    if (mapping)
      texture.mapping = mapping;
    return texture;
  };
  ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const loader = new CubeTextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(urls, onLoad, void 0, onError);
    if (mapping)
      texture.mapping = mapping;
    return texture;
  };
  ImageUtils.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  };
  ImageUtils.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {
      revision: REVISION
    }}));
  }

  // node_modules/three/examples/jsm/controls/OrbitControls.js
  var OrbitControls = function(object, domElement) {
    if (domElement === void 0)
      console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
    if (domElement === document)
      console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
    this.object = object;
    this.domElement = domElement;
    this.enabled = true;
    this.target = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.enableKeys = true;
    this.keys = {LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40};
    this.mouseButtons = {LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN};
    this.touches = {ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN};
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this.getPolarAngle = function() {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
      return spherical.theta;
    };
    this.saveState = function() {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(changeEvent);
      scope.update();
      state = STATE.NONE;
    };
    this.update = function() {
      var offset = new Vector3();
      var quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      var quatInverse = quat.clone().invert();
      var lastPosition = new Vector3();
      var lastQuaternion = new Quaternion();
      var twoPI = 2 * Math.PI;
      return function update2() {
        var position = scope.object.position;
        offset.copy(position).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        var min = scope.minAzimuthAngle;
        var max = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI)
            min += twoPI;
          else if (min > Math.PI)
            min -= twoPI;
          if (max < -Math.PI)
            max += twoPI;
          else if (max > Math.PI)
            max -= twoPI;
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale;
        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale = 1;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
          scope.dispatchEvent(changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function() {
      scope.domElement.removeEventListener("contextmenu", onContextMenu, false);
      scope.domElement.removeEventListener("pointerdown", onPointerDown, false);
      scope.domElement.removeEventListener("wheel", onMouseWheel, false);
      scope.domElement.removeEventListener("touchstart", onTouchStart, false);
      scope.domElement.removeEventListener("touchend", onTouchEnd, false);
      scope.domElement.removeEventListener("touchmove", onTouchMove, false);
      scope.domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, false);
      scope.domElement.ownerDocument.removeEventListener("pointerup", onPointerUp, false);
      scope.domElement.removeEventListener("keydown", onKeyDown, false);
    };
    var scope = this;
    var changeEvent = {type: "change"};
    var startEvent = {type: "start"};
    var endEvent = {type: "end"};
    var STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    var state = STATE.NONE;
    var EPS = 1e-6;
    var spherical = new Spherical();
    var sphericalDelta = new Spherical();
    var scale = 1;
    var panOffset = new Vector3();
    var zoomChanged = false;
    var rotateStart = new Vector2();
    var rotateEnd = new Vector2();
    var rotateDelta = new Vector2();
    var panStart = new Vector2();
    var panEnd = new Vector2();
    var panDelta = new Vector2();
    var dollyStart = new Vector2();
    var dollyEnd = new Vector2();
    var dollyDelta = new Vector2();
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    var panLeft = function() {
      var v = new Vector3();
      return function panLeft2(distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    }();
    var panUp = function() {
      var v = new Vector3();
      return function panUp2(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    }();
    var pan = function() {
      var offset = new Vector3();
      return function pan2(deltaX, deltaY) {
        var element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          var position = scope.object.position;
          offset.copy(position).sub(scope.target);
          var targetDistance = offset.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale /= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale *= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      var element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseUp() {
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      var needsUpdate = false;
      switch (event.keyCode) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate(event) {
      if (event.touches.length == 1) {
        rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        rotateStart.set(x, y);
      }
    }
    function handleTouchStartPan(event) {
      if (event.touches.length == 1) {
        panStart.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        panStart.set(x, y);
      }
    }
    function handleTouchStartDolly(event) {
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      var distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartDollyPan(event) {
      if (scope.enableZoom)
        handleTouchStartDolly(event);
      if (scope.enablePan)
        handleTouchStartPan(event);
    }
    function handleTouchStartDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchStartDolly(event);
      if (scope.enableRotate)
        handleTouchStartRotate(event);
    }
    function handleTouchMoveRotate(event) {
      if (event.touches.length == 1) {
        rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        rotateEnd.set(x, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      var element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (event.touches.length == 1) {
        panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      var distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function handleTouchEnd() {
    }
    function onPointerDown(event) {
      if (scope.enabled === false)
        return;
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          onMouseDown(event);
          break;
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false)
        return;
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          onMouseMove(event);
          break;
      }
    }
    function onPointerUp(event) {
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          onMouseUp(event);
          break;
      }
    }
    function onMouseDown(event) {
      event.preventDefault();
      scope.domElement.focus ? scope.domElement.focus() : window.focus();
      var mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.domElement.ownerDocument.addEventListener("pointermove", onPointerMove, false);
        scope.domElement.ownerDocument.addEventListener("pointerup", onPointerUp, false);
        scope.dispatchEvent(startEvent);
      }
    }
    function onMouseMove(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseUp(event) {
      scope.domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, false);
      scope.domElement.ownerDocument.removeEventListener("pointerup", onPointerUp, false);
      if (scope.enabled === false)
        return;
      handleMouseUp(event);
      scope.dispatchEvent(endEvent);
      state = STATE.NONE;
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE)
        return;
      event.preventDefault();
      event.stopPropagation();
      scope.dispatchEvent(startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
      switch (event.touches.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate(event);
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan(event);
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan(event);
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate(event);
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(startEvent);
      }
    }
    function onTouchMove(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
      event.stopPropagation();
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onTouchEnd(event) {
      if (scope.enabled === false)
        return;
      handleTouchEnd(event);
      scope.dispatchEvent(endEvent);
      state = STATE.NONE;
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu, false);
    scope.domElement.addEventListener("pointerdown", onPointerDown, false);
    scope.domElement.addEventListener("wheel", onMouseWheel, false);
    scope.domElement.addEventListener("touchstart", onTouchStart, false);
    scope.domElement.addEventListener("touchend", onTouchEnd, false);
    scope.domElement.addEventListener("touchmove", onTouchMove, false);
    scope.domElement.addEventListener("keydown", onKeyDown, false);
    this.update();
  };
  OrbitControls.prototype = Object.create(EventDispatcher.prototype);
  OrbitControls.prototype.constructor = OrbitControls;
  var MapControls = function(object, domElement) {
    OrbitControls.call(this, object, domElement);
    this.screenSpacePanning = false;
    this.mouseButtons.LEFT = MOUSE.PAN;
    this.mouseButtons.RIGHT = MOUSE.ROTATE;
    this.touches.ONE = TOUCH.PAN;
    this.touches.TWO = TOUCH.DOLLY_ROTATE;
  };
  MapControls.prototype = Object.create(EventDispatcher.prototype);
  MapControls.prototype.constructor = MapControls;

  // index.banner.js
  var es6_tween2 = __toModule(require_Tween_min());

  // lib/anim/Eraser.js
  var es6_tween = __toModule(require_Tween_min());
  var ERASER_OPACITY_HIGH = 0.1;
  var ERASER_OPACITY_LOW = 1e-3;
  var ERASER_COLOR = settings.background_color;
  var Eraser = class {
    constructor() {
      this.o = 1;
      this.to = 1;
      this.material = new SpriteMaterial({color: ERASER_COLOR, transparent: true, opacity: 1});
      this.el = new Sprite(this.material);
      this.el.position.set(0, 0, -100);
      const s = Math.max(window.innerWidth, window.innerHeight);
      this.el.scale.set(s, s, 1);
    }
    setTargetOpacity(opacity, time = 300) {
      this.to = opacity;
    }
    blendUp(target = ERASER_OPACITY_HIGH) {
      this.to = target;
    }
    blendDown(target = ERASER_OPACITY_LOW) {
      this.to = target || ERASER_OPACITY_LOW;
      console.log("# Eraser blendDown", this.to);
      if (window.renderer) {
        window.renderer.autoClearColor = false;
      }
      this.material.transparent = true;
    }
    upDown(delay = 1e3) {
      this.blendUp();
      setTimeout(() => {
        this.blendDown();
      }, delay);
    }
    clearScreen() {
      if (window.renderer) {
        renderer.autoClearColor = "#000000";
      }
      this.o = 1;
      this.to = 1;
      this.material.opacity = 1;
      setTimeout(() => {
        this.material.transparent = true;
      }, 100);
    }
    update() {
      this.o = this.to - (this.to - this.o) * 0.9;
      this.material.opacity = this.o;
    }
  };

  // lib/anim/GenerateTexture.js
  var GenerateTexture = (stroke = "#eee", fill = "#fff", lineWidth = 10) => {
    const canvas = document.createElement("canvas");
    const size = 512;
    canvas.width = size;
    canvas.height = size;
    const c = canvas.getContext("2d");
    c.lineWidth = lineWidth;
    c.strokeStyle = stroke;
    c.fillStyle = fill;
    const s = size / 2;
    c.beginPath();
    c.arc(s, s, s - c.lineWidth, 0, Math.PI * 2, false);
    c.fill();
    c.stroke();
    c.closePath();
    const map = new Texture(canvas);
    map.needsUpdate = true;
    return map;
  };

  // app/data/circletextures-b64.js
  var CIRCLEIMAGESB64 = {
    "16723": "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",
    "16728": "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",
    "16737": "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",
    "16754": "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",
    "16758": "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",
    "16760": "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",
    "16762": "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",
    "16764": "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",
    "16765": "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",
    "16766": "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAVGklEQVR4AbxVtbYkVwxsYzaRHa4Ts7/AbEdmTA2hMbO/xUyhP2SZmWZ7mKmZaVpbpTdnmUnnVMPM1W2pVNI1RKQBGA8SeRw/XtfVk6FlbZu3O9vKLH+iyNLHAePBImvcdwLSKHwJ9x+B/4BdUtetLIosfDwr0nRd5vlaRFKQYiW+b+ZJsgPvfwPfAs/e52LcHwLWVfVm7Lp/VmXZQ5JSr9dCq/JckKSkYShVWQiSlXVVKkCKgBQpgbreWo99hITh8VfglftCQJlnDcC4W4jI48BPCLrHRCLHkdC2JA0CWZel0FBlJqkkWP0+idDEY88VkCVVUUqC9XVd0497KAk0vk9Onzb7x47+OG02HwGMu4UScG7HjgZg3A1E5GcgBKQsCvHmc0F/I7lYEs+/QIBWHGrg3ccaJhh7nlTwoVJoJIMq4G+hbeud/uNTp2TRaYu/WMjcNN1x8+z3gHE3UAIGx441AONOgGTfE5FlFkYXKsUqs8J5EvOVFSc2z6mg55m0EkG/xPVEpCZxVARJoQIu+JaAN5uJMx6rOmgZ1k2bZ0nOAK9v3lUL2P1uAzBuF8Fy+b8zGrHSqMpcwcCZfAywcjQmRFJoZY4kg1ASEEDD9NfqstKBtVJfEnOpcZ9Vt3uBRKkBst7pKBEb++uOCcBGDcC4ZbTbz6OSU8p4cOQI5HhOaAzem03FnU4FA1B7m4mt+n2tHisf4Z2E8Jk9X2AP3rkWhOr9SiuzlJLX6pPkeaulZMTYh622Me7Twe2p2yaAZyFg3Ars0eij0fHjMj17RiXPZBfttqpADQpQmRf5hcEFH3EnU/GmE7GHAyWKRskzaf5PwriW/6VAjb2pDJ4ebIH+4UP4TkuC1RJ7TS4oatXrglCb/hyqm2/6bwPGLeD2jsE8Sb+2hkOZYBjZuG/Jr9YgzZ07ZHLmzCYJjwES7F0mjco7HHqsIBQxYBJKUoTAOQ/4bg2GknIm+AEIXdFXfaiS4dGj+l7RB2SnWBOsVuJMxhLiTlWRTJJP4jp79nwOGDdDliS3RoA96n85OXVGZs2myo/Danz6FCvGKY9WOCwkhxOawdMgczzbsoBkGSinPCvlI1AfQZMszoAqLy6ohUmEIIuK4jfYOr2DBzkDqAAlny3XO3RQFt0O13Ff+nFvKpKE4JttMffs/gQwboBbIyBYzN7tHTiAYCasiAbD6nMGMEDMBATXAfMVq3VZH/M5dlyh8VQgQSSGsuYzK0qjL5WUhoHMTPNCm7DfzV27dI6Yu3fjKDwJpZ3W2cP/Ovv3q3oof7YSVceTZQo1BiDHHvZfA4zrIQ+jGxPgjSfPQPopGWbvM1ntOc/VgKOtauG/Y5r8+fLtAUiyp8sC+Ftzvg2tFVrbthlc22Zgbdu2bY5tz7Td0z3tmf5z9KH2/F7NjaiurdYaGXGra6pe5cs899xzb2a+wQ4eqSou14nJVrCwAW151l8eQ1cZ4cnjR4DRFyYwlOd1IAe8tk8MTNzPtbqzPD7ehh0gns+YAFpMmgkwfr82Obm+Oj35BrFmkE2eO5s64Pq1A7FmgMn1V6G7Nj0FAAwIZbtV3qOgjb5R9tD0EgFsPWAAFQIb4j3iRxd8/jjguJ6GeG/Qy6OjQElorLaelxUevvhCe81KJrkxP9+5v3AH4K5vJ16tFeHpaZbrWhH0GxUjcIVDHPLoZKwZZAHyQJMYPRBr+i3p9oekmcVbtzpToZ9J6FQ9771YFApzoSPKVaXHo1TcpKpOwAxU9W9sMJEHYYbrDXIptDaZyvsAfpjw4XEaMHX+PGBy7VpnNSFSra0Kn7IhpW3LiIlTp6rOoA3um1B8/ltiTb9102DWArGm12YuX/kAQoPGvDITDUDFTbSane3cuXEDyvTA4N3EdRX36NeleTElkzLZ5zLgpMSERlsoYYzvhYMUV2GkfjB4AqvfeHUMAE9DYLYqTr/DNP8EWJxxVc1AY4yDNgAT8GHe+rvEml7LuAdqQGLj/IlS86rUeBIIKHkn4aBzHS/cvtUF4P6mwavk0K7WAuUsVaJJm3CB5d+1CsQq/bgX9kiPJpiJElXeXmvjHVD3kjKLMRX3BFTbXF7KdRPATu2xZPzGCZi/jTW9tjB0+18DsDQ+8amr6cAANOoqPivVVMMAYqRzYJgwL0lttELsE8SX99T4fu+9PqVD3gOCUOpOVmX4pKXw4wDj90DHBF6lC8sTXbprruUQ9US1/EZKljly/QLk/c6/MfPjYk3ZwEIogneeJwzM37nr1zpTFy60APAu5O/HFgOAMKlJoL3JAYJ2yBBiVB8m7/Ma4FpCB3iYULWBNQIA22VwMgZt0HyPcSYq/QEgDVMy0XlpsTII9Xc/Y6QLHEE8fSYkhc3BWFMWoLcCEJQ/aXNxodbi7UBXkgHu5bP1udlWEKn2Umz0+PHOxuyM2I6iP1KhGXSAagdO7Q1eP4qjgPeyluoGq//16Zm2f9+rA3wunQHF91iAvvrBGIApiYUAwPUFYGYMlsvJWm2Z/myc4fN7yQytFszORl9erJD+kFjDohlbAUjc/GkNSgkLyRIp6I4ePWoVJp7S+XyFQssGkxd/qKqp/sQlevMGRggrE6sVoUHyUInYg1wPAH0JAb+vSRI/3jbZSrMYgXntxMfHjdUmTHm7k1SuKiTW1hi0yfW/USHwpLcSzEDeJCr7CNV0Ls0t3r7t5pn8hc7YsWOdmeR7tB85fKgF4Ynr5N2h2xS/iqDcZKXiXeFC3X2nL/kadQ22Fk0EsruCjJdqDWH1l50mbMtEr9Oalg01efcXGvfDzmdWV5KdZnIf228vE1ImrX4h0kTRPc1HMXdv/Nzpl8SSCnsqwY252S8dOXJYbLXeGz9xojN1+nRn/OTJztyVKxVTbU0wmc95vkeFE/fL6EX5TWBLfa/xvjjl4aK5NFsNSAQLtUsvsAm11RpoXACL6fmrV4WQ0GpDZCGT829960vIqk/uRwDbYiq/uRdBbfu7cePTY01AP9BkI+K1Y03Q/WMVl7Lz5t//fWf44D+3IEymFh8+dDB0uq405ZEMvEtbzSR4T9oxEEBRXB7mTQCIW5Ophva83ttqcigOHK0yhipUNqj8zyFinSBOX7rYWYg29TQh5HdCQV+ylMwRrXrg3jTn12NN+n8dL60l7ucsV0ePHOncCgBWeDrgadVVGIJ24k5cd+M/g5hOeKjUiBSK0421mW55Ki6F0m6tNkdqYcSLgAARagO97ikUlN5CaTH0BjhQNNr1QjTAX+FivH5Lv+wn+s3y2Lhl+e1YM3vtxit7sTnwJmKkTSVJeSbMg2ibslhakwKhSYFdpwSVb3OzzYrjLR4Wz4BZTvzxpM8GNb/L2QEWESpsyfvubvDLAgbvzcbjJqUPmcdnWEYU1SiYMHXuXEK0TbvG6VrXYR59AijnqA04SlY4EGsaL1nhfQzh0FReUBPHEcWgPKQCc8OKWSDU+x0bLwgbdBWHflcA+b0NEGnTgIGkeBKzChchQdHFrowBoFroCCs0r1DxXnluzKo/9zFxfVUDgD5q/AmH9401jZf5q9e+1tpaM3mLCl5o1/wZ1DNBDEBEbr+tiht0NEF92PUxcQNiJsxzymH3NWn/Xk8oYQdxE+dUXWwDgMBV079MBQhapAkFYFQTVhUqqxOTnc2Vpc+LNY2X1fGJn9iIAPICb9tr06QY9Jd2/r2NRzcXFzP4VbvG9gpQU2YxOOFmIrnugcJJ6KG9eoPoSWucQyuEQdg5WmFnYthR22hPM8Ui5oRtr8C2dg7Ala1s8DzY3PzOWNN4CaK/J1bRVJzMpuLyXqz/RzYDRNWEnCKHspf6AwXlaQ8PA8D39veIqngPC26K33aSwCOIWGPyc5evYI0NmCp/ASQMWzAePU3JqsTp8+fN7edjTeNlfX7+L0ePHcvEL1N+P97Z65Bne2+uxyyeR2sDiEeeMUCTcl/vMYGXUZywKbKU3xigkKFFWMGDnaXogUpv5PBh6VqVqoJ1NwUQRpu4KhL7iKzfqhD19buxpvGSVPJ34o6aisntGirZ2jLI2vvfR1OFVTpLvG7YL0T7LdUg3QG+VGczRPybvDSrkFEoyQpi3foDq3I8181MY2Nh2HUsCmgjVQUCFmsAyfvdKndo+I9jTeMlP/obHkDHnTwrVpfHx9DYUlTHUK4Tm10zg0HLClqtBAHCM4oUpbExSF92gE2mlsP0iKBqvNiK54Lt+efEtrVDGxJAdkCjeFK1AgjIlvhAoR0EeHH49h/GmsbL2tzcH+9F4VHJhA1aijRhGxX2AAycfkg/2zTMAV6xQAgAwm/0pQyX102WtwhwnQpjm1oknlz23jhkCw4xLqFFNGubvFstBkQHMjSn0qd+s1cZIbzwq7Gm8ZKx/MJuk7cXyBu1HkcpVrU5CtYyelBDa4OoY3GtJqJxgHJVSjRolCeKJqf69DmtUHxp3vMu4LBq7NTJtvCSEdzLYQqNqBpkIcC3CzHhNDnJGT8Yaxov6e9b91DU8JZB875iosKllrZVlGyrH8IMUDxZDZVtkOpPmuN9CxkTfXn6xyo6ALgql3u306rpl2gCjtKjvKyhfuA4OpL9BPcglBz1VbHGGgAAn7obAERKDpding+VADIYqI1thdQqUzrrZQnK+lx4UHEeF9dKYjogZ/O0/QQ036m5LxaNHTuqCpRJwrohfQKG8rdsupNzjFt/8zcfE2uavADg7Tu7N4+y1N7fjpnCoqpfEKn3cJbbNKAV3OhGNWv/6pOYqUTnI2KLN29Jb1aidVK0bW1SZxJYaqIYIAQI7Pr0NPVXOwCFOFoLvFmtBVoTVjtNXlw9ifEemmLCds2NigUFhN9NnD2jEhOTaI5VxQKgUHvlbxtO6C0lmrDjMp/RARPta/b9CWaNqY3xkUOH0N7qskv/pFShKlPcvX37bqxhJv4aMX8P7wSAtYB41GqdvV2j6nVKLOe6Kc9ghtysH7GJmvQAxU2AtpSH/bUGsThDXyC4pj/LAA+oDmOqWQNc/+u/tn0OZCKtb3WC4zJa8ZcxD3O9Vu+e4HftBAB0ebUUX8eDWm1oVJk7n1xOnYEmzgmawxEe9vl4jtYrr+uzKtFq+rLnaPIOZSqFli7JRMKrp0l3wsZ9KvOoDxyuGhdnfmOsedmjx1s2Rd9jL+UsT9oWV2EVzSuNWcTUnoH9vDrnL/WuZkUnW8j5vtePlaLJ8TDB04cmh9MFDQjCq5rr0bq/AdCKj2iORhBNnvgtRFOI6wub9946lqfbHm4BgJ3v7LGht90Yg6qj8joZAlRdYxncv66wmSlO68isdMMBB4CLbUra2jsklIoY23bVCBxwBi26gC+L2Mr3XjbRxo4ePRRr2KCDka/f71ofAFS7KkQU76/+0NoDUpWqbEwKI5Om1qUxADHhNh0mLKzxsURBJKdbxFjZVfM55tVjdlWISYHAV/xgiBLcTpft+JWpyS+MNaz/YIS9RMXb2Werg0gLmH6VNkDsAFIPhQFA1U1SzBLN2vMzUZuzJkYwa19AmAgPgNaTaCpU1/rM/qQx1I61tYIHM2QBqRAQsznSf5VYwwYxgH1HbN8NpQ1yUKPiUh9qOwDRLFMNlFihLOpLdQbdq/TeK254l+gB2xqgWAegeu5AVpmOp60Sa3fLeqPOIcePH//6WFM2duz4QABeL7a2v+krYF708NKgnSB79rRALFPtnl2cMXmfh0zEk2MEk8dL2dEZu+R6AmaVJ0TUIsACLiCVvzQBS/TtuUOACB0AAXHm6K/84qvGmrLTv/XbAwFgX77XiZuUp7NsUFhlleqbuDTE8woo54s1eULJg2vOB7OQKdpWbe+wo1JuscqCR/bwdzKVHFBUekSRpozlrBIYHrQmzvK+cAOu8V38/T/8rFjTa89tbm4LADu2y9wpuBydfH5OqWm3Bt3Q2SDQ2zVbChRUtSpDT9cCSHlMsak1cIohrvfX567TTNznUputMEApffVXVacHq+auXgWqXagAfPFvYk2/5fodAfCsvh4HNQsjj8oldXUFymAcQKAlqpqotGbvD50JoCqwDlBKCE3E5orv1fqO4ym/2Lc/QMWxyeTqpNiulDpkyqFM7nk3k69U63vsur+wKAuoEp9bGBp+41jTby9/8uKOALDPHTR5Hhk5eqQdMA87KitQRk8cV7ZGpZN+MkGTrTNCactJj4lp4pgGaMIGIARPJiCYdQgDAJMXEnSCsGGG+8x3F1eE0RJa2qUhzhP1I/1+cqwZZI8e7A4A+xEDcEMxit48LRah3r/q85ltpzu3ujU/mq+H8lUcKW6AwuPSoAlWk9JkByIHsCp3hQymVDapbXTjUuAAVCjaBVJh0qHlOCcPQn5rrNnOJs+d2x0AFoR/H9pu6OkNGw8lWDYz0NREeMJRmXiEvsXMWlZ9m/b+t5wGK6m7nhLDwK0HmpS+Qgq7FFWP2/BZltrch1a0NC+hVTPYA9TUFItD9CB7AieO/1Ks2cmWxsb3BgDLww9/gspiM4OV8uRhg7fpYFBoSqCAoSqsx+d95yzRU2YAq7W/CWAKzzLpkmfzd4hHMcVGKWBoCzb5rJimsAGKFae+6lGdjOnhr8Wa3SznDXsGoOy3UAxFa/PBJFG9Nkrog/eOv3obsbSfaEWH/lKiAxgPXDy/ti7PqxjrgSpAE0+T5m3sMcneFZ/9PmGDjcZTn/9srNmLjRw8uD8AWJD/ZgOtJz41qJdnitJVIgOIoAGFd0usqH08QNR4kfIDsn87rTZLgGvN7wEM964yuZbOpTFfvZ+5ZDz7B4BFyD4kufeBqkveNgge4TEFEa85VDXA/u0qy9J60LIrii+oEp3cOBcsT/YLaz2riCEVQphRzwdC7b32O49ksn8bACzef/UI3Z9Kgyo3HpGeCJccDQR7iFUtildlKdWm6DxdHgaGRYvJYcegrfVi0oD2G7FX/rfM4cXBleC+7QPioRF0713+mqDQKG2g5MRzNTrgQYZqgMOM3thWw++hXY+9+/+Y/zi5NjX9cfl7rbbPHHWhPgNI/ecK3gbOTgcwMskO7XzI8OGx5t9r/1n/c1Qs/nqtKEsMnd91j8TvCpMdzx8GHNMtx34x9s7/0//rbL99aOyHYv8Uat+l9tIbBtQj9DQkXq/nCguGhbz8Q/5+XyL//WPNf4L9lwDQLzpvmTX7h+WBxs+M6H1lDja/YXNl+RseP3r4FSmcPj3L6Q/NGcWbx5r/CusH4P+d5ezxwL8AVybGUNJfnpEAAAAASUVORK5CYII=",
    "16768": "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",
    "16769": "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",
    "16772": "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",
    "16773": "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",
    "16777": "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",
    "16778": "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAf0ElEQVR4AbyWA5QlSRZAb6S/3e5y1dq2bRsHa9u2j9a2bbe7x54pzbTd/Ss/0xGbJ9e7bd3vn5kv4914AaGUKgE9LiyWQpVBOSiBEMqL46AHhFxA/rL+ryWD888tgPsDdwZuBiwHagKKIEyEAFSoCX0w9PrtMI4PDHv9WaGJSzRd/yuwyHnCsizOVwXcB3gW8DBgjP9DIWWCpulAJiD7DCMfz+vhDT0SqTAtE5kki57n/T6O428B2ziH7Nqz65xWgAW8FHhVlvQJUAo0zcAbDlm//o/c5a73wLFtjhw9TLPVROBj6Bq6phHH0VQul5/yfe9lY6PTC1u2rP/URz/2sS8ACWfJxz7xcc6VgNcA7wWKnAJCCIbDHr/4yQ/58AfezQMf+hj+9Ksf88JXvIqXv/ot9Lo9DN3IRJnp5+zcHLe+ze0Jgu70V774+c8oJT541G2/Gfg8Z8G73v7OsxbwMOCbQIvT5Ne/+jlbN/2Z57/wFczOz2OVq0zO3ByARr3Fvv27abRazM/ewIZ1f+E+934g3/jKZ/jlr3/Lve/3gKpt259rNupvbVRrzwY2cgb8dd3GsxLwbeCZnCGN1jJWrFrN9K1uT75cY/xWd+S2d70fvjfg2rkF3MN7UMkwTX4drtsF4IqrrsXO54njgFq1wvTk5IiUckPbdb8AvOi0y/Z1rzsjATPAOmAlZ4GmaZRKBYb9HrquoxNiqoiNF13J7kNLlPBZmA/I5fLc6573Zt2ff8Of/vJXVq1aCUrhWDbVao0lt02s1AuvvOyaB8s4vj+wm1PkIQ95+GkLeBTwK86ebJKzDI0oTpCQJraC3TvnWVxY4I53uRdzV19Cu73EHe50B/bu3sv7PvRRhp7P8vQ8M5/H63Y5sGMngyRESUEYqglv6O9qtMr3B9ZzCnTSGAanzrOBb3KOEAiEYWdLnRPbyCRJE25nk5/b6ZArFJkYX0P7aJvvfPcHDLyIiZlJysUCK5YvZ/OGi9l66Q2puGb2f6nsoGkC3TDWrVk58gTgZ5wMxSkLeGaW/DlE6AZK2CABJfGCkP1HI4QQuH2fYiFHL4i5bsdhgjDg5tPjLPXcTNTqVotCKc/Sdp/aMESTAifnYFh5qtUChWLlp5dce+NjgV9yAh4Qhack4KHAtznHJFIRpC+lIIojNCuPrgnCJMIwTHy/Sz2f53a3mKKZeyybNmzEPXyUXCqm0/cIE0EcxSAltu0QxjGVvMPNpibImRZbtnV/EWDdC9jCcdB186QCJoGfc+7JJj6ZSMI4QSlFEESYtkkSyazH73Cb27K87PDb3/2ekfFJmtddT/vgAZakST/SiRNFqZCnXq9gWjqtWpXVzSr+oEexUWd1w0FUV/zcdnK3Ag5xDBzbOOlW+DLgjpwHNm1ezzVXXc74xDSh79HzfDQdSk4Op1AkCn06Sy679uzBNAyazSZxGND3I/Yf2I9t6oyOjmHoJrv37KZSLBAEAVES46QxpIrTl8I09A3A/TgG180unnAr/KHzlHzW0CQYcOc73i6dxFZjGiZCaLi9DrZjY2kGe/ftZ3TtKPd74IPYuf1GypUazdYylIzYsX0H1VqV1rLlHDh4kJGxtRimgabpWSzXdTEti5xtE4bhfZdc9y1ZPv+DbhaOWwH3AjZxCigFQsCge4irLtvKmsnbMDIyged5GIaBaZr8L543xPd61OrLyUABgigKMEyNJErodDoYlo6UMoulEBi6TpJkPUvOyTM3dwOdVNqtbn1rer0+mqZl53r9AZZpghAMBul3yyKNc3vgKv4NURQdtwI+wPHJGuH7Hvl8ARAkSQhCp9YaoZDLEYVDkiSi33fTT0WpVMI0LSzLBshK1LYdyATK9BWDEkRhQOAnhGFIFIUoYRKGAWEQIHQdKeNs4gvDKJN0w+wNrBkZwfd9VKLoD/oEgQcK4mxZPZrdSymVfm+/D3gs/wah6RxLwFOB+3ECpEzQNQ3fy6xjO3lyxQqj45PZBidJEorFIpqAw4cPkiQBtm2n/5UJgph8oZCVaoYAKRUyTjKxaGQxNRRKJiAEQtMQ/y4USmnsxfk5At+nksYM/SA7J44iZCwz0ak4lCKT3+12kVI+Rtf1RwC/JSOTf0wBr+F/CPxh1qi/lW8V8G3rSXMkS3ZMicPQpkwp44NjZmZmZmZmZmZm5nuMfWXIa1N+gYbjgOPYMfub2V5+3zHzqT81jiVL/92dnZ1dOdrk4QhJymf+zGfTurBaVtVyHmM/z9+5ZOUhYTyN2to6wtonRNOYobIr8TxZ0VjfgIamZszNztjngkSENIBiUqkUYOlAnRCQXnDLvEfJCC7IiJZp6Nj4KFOt0+5dkpqkjJ4nKmv8EFPPxURSfFKjdQsBSkUiNvKCX3eA7uv+lq335X7J/3uoKi9pYVJZC7WTr2XQDDLZOctz1y5WoFrL2F4oFUgwnkUlJ1gT0gUuenZuzvJRnxlPTuDIkUM4e8sZMyIUDIuxFXXpAEI3KAfzfZ/iJoGR4X5LpygdNdDXaxFupSLUZ4q898z0NIpMjUaWQFWPqeQUnV/LtjtrdkxOTiood2PAbs8d2hWI30bAY3+7b9eHFR2dXMpl6ElGBCSiclEuEpFgMp3kT4O23rNoTTP/wpGYsXOJ+RyNRgRH3ZiGGNxlOI8HkZyaofLTYtMIE951dQn0nxuy1EjUxfGzH/+Ya6lg7ZoulCmQevvOsoNsQLQmxIrQi7HJGZbJZqKq3kiwf6Bf0UY+kyN3iAizOHfuHOrYQQb94OMWegXd+9cR0GEkYdHMWuQzcylkyLKARZ+/pzHH35WvyrNojAahatEtV80oIzB5Pc1zxfYiMMKQeZjGyMiILXCOxyYmJoQGRdiiefTmoxgYOI90ag7Dg/0YHRnEitVb2AVejfe+9wN2r+7uAzh99gzSNCxH3XD0yBEc6+5GlQ7dtLHLnHX85m5ee5waoRNr1q7Ctq1biKQ53j9FJwYwPDz0gNraeC13/OiHP/gNBNyHu9G0IAiREMrgYBLG/IR1Q2OTRXd0mNFxwEVFFU2Rm85XfdduKm/RosVyhthfDlGeKqKEYYrwrqGCa5Az5BxzrwBZ19yKb3/zK9h97dX4yKe/BG0f/dD7LJW+9OVv4Kqrr8Nd73x77Ny5A1lyh9KokWvK8Tpf+MJXeK8ALr3kIuzZfwif5u+NTS1I0HENdWHU19epjxBSG/bvP3QvAN9Q9fBkG2yr3slyvlKRAYIqYZtQ9DWAoANEMiI76XhGmwgpllSWRELzSCbHEQ5HxfZ0SkWpo5kfoz0mgxVtHTMHLRC6YCoHqHzJQblsBqu6NqC9bRFFjItvfuE9mBjuw6rNF1P9jdGAkq5NJI0yHVYiVhdlsILYd+AIPv7Jz+PSSy/Gfe57bxregK989HOYGR/BilVr8NY3vQxp3uP0mdNgy4zum0/cRQ5oaU5U3Lvd/U5Z7qqblxQL81xgBoAruHDn4kh2g4Qkoyjoa0DBGzOXmH9FRph2Wlm0+mX5X1QNF1LosJxqtozVezpPTjDD9ebw0BBhP8DoNDCSjXKADTnWb9+Jb3/3O+g/dRCb1nYyh3O8b4wdXwiHjx/H4MgYrtt9AF//5o9wS/8guYXltaQuMo/p5CRzP6NcR7i+A1u2bCZZtts6DhzuZtdZxh1ud+nF3KUR5j0Jhe9/74cdlJFLvVDYDMnnMuIAy3MtXBD0Q0EEAz7J5DSyLIstLW1mc9C3c2hEvQwUccpJhPq0DLXFqTxJNwhZ6u9zREEdneiSwd0qBEtVGUOUYDpNaDt+BHd/8NNRpGL85Be+hb7BUeRU51MpY/1fXnEjBm45hXqS386tm0xIdba3miqdnknzvnWAl8eKlcst1QY5VMnSkV3r16KSz2z8xS9/bgrYGx7qU63lFbQ5KkOEbUo8YGpNOdzU0GRRnEpNocTUqKGBgrjJ1FJWlUDOkhEqNSo5YnwZLKeYhNUx5Vx23gjSqklzU5O6QPEII1QiQQ1burS0tmDN6pVoaF+FiO9g544zGBr6KZYtarfxeZU1PxYPY/vFl+Jud7wY+w71MCANTJMhfONb34NPTgoQoc0spatWLMEYSfHQ0W46l5xEj58ZHsWqDVvVJe5x+ULRXquoS4AUCjnmfpx7TEKB+V5Se6qIyiCKj6UmbmS0mGvo/KBYV4RHA/NMlQwdkLQUkA5Xzp9nWRob0zlFQZwGtjLaksoZkizTjbtSrFmDjmhU7yvXqfWP4ReXX4GVq9ZCrD2bTktDkEAbrebnuX/32z/A/gOHMF8oU/xMI8UZ4bxVoRmO1ydx8uQpDI0kuZYC+5Usq8sYx27n8IAHPHotd3j8T1FfKpb3QxZFGhoUGnhyvwmcCJk0FAwSekUafBosIqgwRcpumcdilvcqZXJQjOcGgzWEnfJWbWnZrivECJ4BGlvNVVBHJ9IIStozTKmM5WmUKaNUk5zt7+8zMTVP5Xns2HFs3rIVa7vWI+BojlhA1+qlqGGglnV2YnttDJs3jiFRG0VnR5tNl2pj90bxVyXYgYsH3u8+FGKzloqXXrwLuXRyqVU8vtDPlkgsQUbPWz4Xio7YXc2CiEIPJyy31VwoukKHJjOKsCSm5wnqVUVNMNd7QpXe53uONU01NCxPhAgp6uYyTAWd6wYce18oU6WQVhC62ts7xB322QkueseqHehc3Am2tughEd7+DrfD+q4uItSh8Okjehp5jRKJVI/XMrh9NGKSfYoKcXxsTBylADGVhtSniMBbzAG1MV8kF1UEpyfH4QdDBrNyqUxDQlyUbzCdYl4HQyGKk9UmbjIXarudSypQTgv2uokMEa+oA1N+63NSY+oJiKABS4XFnYu5wIi1rcmJpFWYhsYGa1zS6VlDi3TGNK+xbMVyrOR9CSabAeyyRqtKBxXI/iWJJDqtYhUmwKAFfEXdYSplNSRFa1ub5gN6TynM99XEBSRe4IbULpYLfqmQY+RL8rgRYLFcsMGjSG14ZBhe0KMhQaWLGXmq54SpOUVU6TLO5qSXgwur6+k5Y/Ok6f3DxgNysM619hRVY/IQCbZM77W0t4up6ZzzpvsXM9KKnK4TjkaNHybGJ2ikcZGdm06ltTaln7SL+If5n7JzCT5LwRmKJSNrInNmeoYcsbBeYHxiIsgdnv5jOapoSpuoS5A4Umpo5DHB0sZNAUK5vqHBFJe8J4iqjKnbUiUQHwwyZ9M8lmBNV54JNSpN4oPyBWTYaEt8kGiot85uZHjEzovHY0RfEkMcf23evMU0e56pONDfjzY6R51kmBVp2dKlhpLJZBLzmXnESYy1iVr09/ULXVxTrQ1KRnnd+XyOJXAF4R5lsE7Z/ZuYJuKQQaZBXX2iYinAFwCC82WWs3AkTMI5ggwNXb9hI2ZTKRs9yVDB9AT1eqxOff+KhTaTF3bo+RkupAFtHZ1YaHbCcBAlVNesWc3rRsTsdAZh6vuKmJXGYRosaSyYiv1DJM3kVFLdo9Bjjte5WX5WkT1y9CjOnT2HNUyHBNdx4sRJHKdxF128w5x8HZ/1pZg+uyiVVYZv2r3HIr9j53bUhsN06ACCnm9pWwXmzAHKQQ42JnNk29m0DG6iJ6uEX5rR8UzUXOj3wfLVbiytxbj0ZIQXlYyVM2LxWjNeMz1tZ06fFPSJnEYBgXuVRiUNPdovEKDH+t2iZoopNE4Jy3uTrAa5UMG8mcfEJ+KLaabE29/yNvQRaQ96wAPQc/ocDhw5AYfc8dCH3g837duDibFRos/Hgx/yQJw9dRaHDx9FDZ3/tKc9CQcOHmS5PIBt27ahhbPFwwf2Jc0Br3/Va1H33tBQY1sb4dUsGEmZEUph9uqnjXUXMSfF6E2s3zJWBqginD7VQ4guEuxN9qqEVssVkSE9PwUbfPCa01R/wXCNhimSvyx5HVZVlNftvO/y5cvlLEuxFIcm2pRyekokR6gc6vP1XFuG70+w7zh1+qzJ2tXLF/H1aabFFK/bpnSi7hig3j9O46PsChdh3/59uPqqaw2JZAT1BJo2D5kD+IJsHD7re0Erfa7nwkNAOWQMbGWNsCFCGJnz9iiriZGRIxRxOSM1M61ICSSqDnICDetg1B2xueW0NVHUEW18n2zNPWgkOpfNyBl63KXe3mSyDURsmhMgTwwZi0dpWPviDuqDAT1PJFrYO1RSVnp1bmtLk5ViNWpam7hBqei4Do/7HL93svQxsFx/xg/g6S9+6VlzAF+gtWPJMX044Hr05ISYVmNo1uLFuqAZqcZIBGitLiFZLAiay1g1wnIEIX/GnLB8JaPJ8pQlkUYjMeYzHRjw7Wsv8oIWK4N17urVa6gQR00CAw4XnZAY0vUI5wmh0XK5qtTy6bRgjZFmwAtaSfQ9VSafRFfHqjFFrUGUNjTSYc287oiQaMar/JmE5r/cr9L5hmtuOm4O4Atw7/nulz81q9o4I7EzpXFSQjdT7upCKh8kv2XyqohFBCjILxwzaSvNIMKS0FETxB9W6s5RetJo5nQz4JrxWpDISNC32q+HHAtjNyFEUJW2kBZI8/gsyS0qcRMK0uCIhtDa6Bxr4e2asWiNaY4KSSeiCsU18bBQwmNR1HVQarMCOUWHHq8OmgOe+pj7i7XyMzNT+wjHu9Q3tZDpGxQ5G0GLoRV1TXzkEN91tWgrk2JelShFrL2jwwwqVsrM+Uk6IovW9jahx2AYoSFylNJkjjVc3lEPILmskpqWTA0ETGXqvDijrwGq78CqgkvHNjY3Mg3ajXzpLSlI5nWr5T351eq9pkOpdAb9yXmmRSPCDKBHZLcmWpANVNHJQU3S9fbK+Ac+7JFh98EPfUSQO4nkzA3DI6NarAkOyVkxu7x7lGJGpa6QLygNjL37z/WyjA3ZXKCGC5JhBcHLcbRgcYH4Q0SmyNsoW1FSSFQNRgh9QTjGxXuKHqGuyiK2z2QzhgIHMLnteK4JsbHBCRJnCiPj0yjlXZtY1bAvqef1LTDWjM0jSsIulF0MzeQAOrmefDE4yoGNFya5EtkebuBOdFekeSsw1m1s/Alh+oY5wq2OuagoaDHFoqk3PYgwRFRdwOEOmwY6FuELj6UcQU0LFoOr2VGa2OTIUFKqyFlGUB2LOpRKVv6Emhq+Lw8WeUwiR6VWaBBSJLJaiCTdbTo5ihK1SbC9ncgJoKO5DdX0HFPsLIVSDH5ujgErseaTi5oiODuZB823r+IMs1X2I6z/XMcl23fZlzyKWRKuRA83ios1ByeSY3uo0y85yHpZS1g20XMcdLIMLtb6pAyZuzWWd3U0UsaoL1B+C37q7iSXHTuXM3rm7IU+wqqJafpoOGKvAbPZDBbbSzTN57K6r66rh56Wfg4dYFJ3vgCPRret7uDToA70EIHZkoel5J0wwzlYniMhswuMxpl+86hQn0SDEcyXmHLzORpbwISfRmI8efnYePI0uO2M1sObtHptm9TaNxmZS0Regrrm7qr/dIrY2/S8jBQ5KYcV4VAwRFmaRd+5W5CgU6QcFV2lgjE/oPesiqhFGRoatic69SIje94g2E+RIyKq05rZaYiiOQQdWCOEaV0mq1ev6WK+J0yxbtm8HhPpHBJk/kaKt0JNkUHIIRyIohQMoH31MizyWfeJpCJRWS1ZCcRYcuIbC/bOZlPwZjhDW9gyueznmHuv7lrf1SQBohSwVjbsid1N48voQTYtMojnmrEqlbHauDlmgSCnGFmhok1E6Ps2XS7p3JJKKmS84G3ntrS1GsQDgKVEwA9pqCFyVSoa2cYZWZVmpwL0DQ1i05YNiOnLlaxaU0yLW3VuA5eBdDaN5o4WdEhv0OBZOrePc8Pb3/VO5IlAX65Q+OKCvac5Qndu7j7460+HZcBrKYLeBFGDC7XBWoTxwsLztCSdJsPVY2vBUnAlMTCqIjZzkhyocxRhlaaSTXDyNidUyZRYKuino5IVsQcpktiJC8hQaqhNt8/Xk+j2ctT9ve//FPVchxxSCbgWBKVjsVxEWGTsBawrfcELn4dHP/pRbJL6kM/OIZMvqjTrsbse+31gwdZUaibucSL7W9+fPf8hiqLnkrSaFSnPZQpUIWOUBspflS0jN+2OosqLK1XUgroXniYtzAXkPA0k5Ci2uYtMZus9g4F5FEoJOd6OyfEqwRcerQthRSPPnpNnkJrNkIPCVklsDiChxF2PxUTePl9nmeulYtkmUUrlgF+Dhlit1t3LIchHft1WKUxPA8xf20RSqZnC9OvI6h9XJEROmhkoF5X/MipeG0NmatYMDsbCxuaURVxMHdNEuZ/hDYsmkmSIyptmDdddfyMlbwunN010ygRivA5zw5AjwROORtTWimuMGJU2UnojnOONjY5i8aIWOsAnAirwSiHjn1g4xOvXUSxViIIalVUJMo3yrJvUVsjlJL1fy73067aKnD3d/Lc2PZv7BCXxw5jjdxQbO4BqPaGeRT/1+jwd4XARs4RpxzK2wJ4vyKqXUBlk374Eq1avQmY2jRSJsLmNAw8quVN8Pc32174QHXBs5CatkZkUCYZVNTQjYL7HlCr2MFWKdM/um5DjdTUMLbEqub4DFmRLGaWfOZCOMDi5Do971vfr+IVxnvujUqH021/0Mg5jCtTh92z6BubTOGM7eex0f6CxqRadDSxPZNdRRvedr38bJa5HQzuxbu1a+3Lz4SPdyNIxnW3N+soaHbAWt7rdrdFM+KamRzBIpHWxqnTw/GG2vlHCskIDk8eOIk4HzQYa+T3gX2JmakrfIGXtbsfWbVswQALr7j5hyINIk6iAw7znawoyvu/ZSD1AtNo/vq8nSFKZ0ieFXD7NHucZf+CravD0ePoPbGdzmeKTagLVL86QTPzJKKpEwUWczW9k+3roTB/WrFuHy6+5DsvJ4is7O3C6bwBt1NxXHe7BjbsPYs++/bhd12o0Mdd6U7O4zeYNuOOd7oQf/+jHOHZwP7xQjbH6YQ45vvPdDyHAvNVoPJmcwd3ufRecZMs7xUYp6MnQkBkupSrDPHWiZQdBX10jybaYkxRFsETHiGBzBZPA1UDlMQBGfm+QKaK8d77tffgj25fe8a53bPBd52Uf+/gnWE6GcY+tG3HnXdsR4XDywL5DKPJGkySeWubZ7S7Zif7hcSSYh+tXduLcLbdgt1Ri7xBS7OFvc9vb4OSJY0iNDWLj9h34zg9+gr2HDmMZnXdbPtc7eeqMyeLF7OEDToBDiyN45APvhDNspso2bIkwPWNW3s6PzNBeiSSrTAiGfbh6CBPiT16j4kAD11dz/9EfMq7VJYnf9U53+JN/MfLpL33+K4986CMffdNNe8AV4vlPeowxx/d+eQU2rd9og4cEU+Txj3k4h6BH8cmPfgo5ysxHP/kxWM+R2Lvf/X509/TgMY95FG69YyuCATZPy1bbA0094n7Fy1/EhQfxwQ99nAOTYYkka4Vvc6uL8ZB73QaPevzzMF/20NRI3c/00MS5b3gSmVKRzo4aKdbFPMTJGxNEz1Of9DiO4lZ9AsAz/5hdk5l03Ln+ml/+WX8y8453vOub7UuWPCw3n0fCHnu5WLdxgz2E1DS2sTGBdeu7MDM5jcsvv5ICqBX3uvtdsWfvfpw/P2hzeymF2kS9qchxipkm5n5LazMa+F4P543TbLNNT2jERqeGI5LCReTyLmcGmgrP0wkJ2NCl6soADHFiHSgF4PEzN5/sRorHXvr4J3wGwFP/lE0/231T3Lniqj/PAdo2rF3++elM/glaZGE+ZyXPZX6OjgxZLa6jTI3HqAhDnkbQNGjW2DxBopUstoejM9MmszWB1rDDGq+pMdSFXPiJZrgw6KLIV6fO9FjDtXxVF0aJjGo5jTjPt36k6rA8TiPL1BsaOI85Xr9vZADTqfSHATzvz7HHK7tx57obrvqzHQBrecuv4Mjq7UF76lOyh6dDjKbK4OoVqwhfTWemTdRoC9h3eCRsgmqM9ASYjqo1pSixElbJY0owa5F3POsDwi4/4wTMuQHugzQwQqjHoiH7ZkhTU4sNZY4epYN4/fO9fUzDMNZuXP9cAB/5c2355Ce/EncOXv+Tv/ivxqbz7u2pFn9ezEyFXcBG4/rpygDCu1QumITVnFFOkooMeL4pNB1T+gjCRf1Oh4TCYnhHnaXON2dJ5uYLevpUlcQ1EqxIk1RKPOYx0nzocuwk1m8m8fb0zHCWeDcA+/8SOyrBYNx73zevwV+xXbtreVPia9ce/Upt06KHlgoZylUaW/VN4wfc6q++Lqea7ds0yfccuQiolgC+LFY8FBEg2+vXqnWcdIuNs4quB1OQdI5EDk1GsMrrsmZmEUQRHlDJonNmEuvWZT9H1fjUSDhS+UuNuPSOt4Wz8gnv/pv+bvDWS2O3PjOT//Ro2ety4IMugO/CICxjUGEjFeDCvYiMkbWMMs+RO4oks1AUchXNQ5B1Xh/Jm6McpkbVGqMineiVixorIx8Kg8UOwXL+yI7UnicDOIS/cnvYfe4ad3a96KN/lz+czFWce7LbeiuXvE2jqZI9Pg+huTCMzloPp5wO+DSCyKZjGO0qGZ7ixdUXmuESJXQf94qUEfcKT/QcOqrCY/oWKCDPERnunkLAfzWAq/7mv+6c3Rd3tj77A3/PvxwVdHetawo+nUOL++VLTnNrkMOS5BwOjAUQD/k0ah4eI18K1KDshS2yKo9MdVUJpY/QoOZKJZC7LuqPVnKZ74ddR7W9G3+nrWP06riz6Xkf+of98fQzL112h0g8fPcfHB7YenBganN9NNrh0GC/TAe4QXMCq59p8rwCz9wJ0QmkyUGnWu0OlouHCo59tXU3/gHb/YPH4862F37wn/bX454bWsrWeUWwkmuvun6iQP3nukwVBHKouNOuVx31qs45AOfxT9huXzoQd7Y8Z4EE//e2u7in4/8HGs1don91t8UAAAAASUVORK5CYII=",
    "16779": "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",
    "16780": "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",
    "16781": "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",
    "16782": "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",
    "16783": "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",
    "16784": "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",
    "16785": "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",
    "16786": "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",
    "16787": "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",
    "16788": "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",
    "16789": "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",
    "16790": "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",
    "16791": "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",
    "16793": "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",
    "16800": "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAayUlEQVR4AcxWU5QlSRSMyu5Xr8e2bdu27d+1bZu/a9u27e39WhtjG1W5MffcfJkzzfHEOXGqk51xb2TeF1lrqwDYiMOLmKxKFmh7q55hBw4vquTj0KMDOZzsTbYj65E1yMpkhoQK30yuIZeRP5Bfku+Sv+AQ4lA5YAi5iBxHNscBQQLwOvkQ+dnBdsDBDEBMnkCeKqIPDX4mbyXvIJOjJgDc43QAV4it9xFRFMFCNkEE6UA5sI48j7z9SAdgHNc/CKAOFGmaiigNTKhURHLM9yssGflgkkFvJJ3SshokaVnp/iu16WIAH0Kwz8E/oAA8TC4sxg1OpAQDYb8xMLkARJwHmeMcIAG0oszNEbE2lTEVrn97EWzIlTh2352b7nsAeOC2/KfvkQ24VjMEJ1rnWHBzPag/bV6eKcYlkHVCN9F6sc4RYSBEszeJC/pvWm3+3hcHGOwbJnHRjwBEPKGH8iIoTujG3YENxXOt0BgT3HUnioSSDf0qIXDf1AfMBy+1Lcm/yGEkysOdO3aWvwwmSbJY77tm20UePpMu68H1dfOdVVSUuERTLYK0KEO2cF4QcY4QqOv8fhDnIUkTiBONDM4gn0MZiDOZ8l0BzllIPkz6O57LvlVBgXj4e2p4IBOZ4PARoB8XBIUXDWhgUpfd4OGzyM/PR8WKFWTNzl27sGXLFvkfOt+5bCqAF1EKPvnww3L9EhzLDR/OPWwkyAgSbba9sCDjQu0mjQjwpg8sHfmHUffxc5LdmbWQrKZAnM0gjmMZ//HHH/Hvv/+iZo2aaNW6FSpVqiTBDvACOQjUiRLwwccfo6wAtCKfd/dZsyGRhvVWDYWptCAIKTOdgAjLo1sn4v1iLXK57MsiFGRjPqB5IPD000/j5FNOxtL/lmLMmDG46cabkKEjTjnlJCxdugwtmrdA1WpVUaVKFVSvVv35Ldu2dQKwAsXg6quuKjMAT1igwB1crG4TwN1Ta30qHXLCrTYNdEGYedf2AZQsi/jc2oKCrOy1c+dO3HjjDbjiiiuwdes2dOvWDffeex/GjR0LAqtWrsIbr7+Bn3/5BXuhNvkkOQzF4OMPP4BBybiW7AknElqzd9P3abb2yL0PAuRx0upA6vqwPLIt63VfsXE2GzPrWWzevBknnXiS2P788y/AosVLJBiFhYUifunSpXj77bf5JuRJxgnUrFlTvlmu176h5PkoBl27dCmxCgwiP/IirTDZfdgkdcdXi6qN5WsQusWtcfDBDOboS04RubX//PMPzj77bDz22GPIZDK47777sHDhQtnr5Zdewvr169GxY0c0btwY9erVk/mvvfKKXJM777oLn372mQSiYsWKMta5c2e0atmyO4DvEGD61KklPoJXk67mimgXhFA45PAGgIjnAZwIXw3yjFQIEaqq9ab7spmJM0h2JXjzrTdx6aWX4osvvpD+uXPn4vHHHweBe+65Bytp9ebNm2HcuHFSBTZt3AQ5Y5KgTu3aqF2nTu6t6N61KwYMGICmTZsKGYwrAUxFgMJvCwMHeJvPpYjHrVoe7seNDX+GhjXeSFlKkl0yEsdZ7KBNd+3YQWGxE5z76WuMc4nH/5SaA3Rk+dbFTydVSaVTSipsG2PbM8+2bdu2bdtm9/fQg7Zthh0VwqrKpCff/p1Vt7rW6M3816oV1MX/aO99zr0jIyP2zW98wz7xyU/Y2Ni4feITn7BXvfJVlmpK+ffLly+3Rz/60faVr3zFWJO69uDAgFXJ2Pb2duvq7LS1d91lrN7eXksmk9be1sa+2DfXDwTaY81slZXWYP/gfTOAzk6ip0KX87/AAdhTCV5EL+QRqNHNfvijH9kHPvhBbfTLdu211ypig4pIyCaLk6rdSe8FQto0UVJdK5VH7MTJk56uF1x4kd1x51ql6kI3YERp3nnqlLW2z7JqXXvlypXG6urosBYZjeMDN/I9DskXCtagc6cUgA4dN1PUGAqHSk1YtbJs6s2VDogn4/dhgSfoc1W5WfFmhPTnr7JeDbIfoHHDDuzfZ0uXLuWmHq1bb73N4rGY6rfW8hPjlp3KCtSivtEpCRcwI5fL2dr1G21YP2+55WavZ64/lB7CGFLWjx8fG7WXvfSltnTJEjkl5/+bGBsj4xSUKjfaoKpInT4R7SkipshbXV0dGcCmFSACqCBMTj4yVFMDI9xppL0y494l8Ftt8BlkQNC+BpEPFF+QGTN1A1C6Q1Hq6elWyrVbq9KuuaXFisWifzepn6wJOYEN4jAuBS5MqeYPHT2mTYzq3FY5cLEVRHEYRJZ4qeg40r0p1eRqb3R0lMzBiYAjKR3oTf0dKvcg/MQG9sB1yizkjGQ/NLOXBd1gZQbMAiRKB8vYCg0etOV8SsYfE+d6Ora2CInbqEc2B02R+qSbRXQckRxTFPk/m+EaRW0QI8OhMIb5RjOZrN9jIo8DHFf8A7hms1nTwugS0BrfYWRZSFXr2ix3REmwcY+QzqkqXU9loywoPln3ZYAzEle5VDrg8dBnoMLOVljZeNKFSFK7Tkfzha5Lli1VzU15pNLptEd7Wp6ujURIOesfGdF3dyslZ/oG+A68mHYwK5JVOidvhUKR8/WzYE1NKTmrWoEginlLxGNsgsjKkDC7Ic1xjup8ppdDtY4nOGRWXMdTDoCxO8PoDSZxIHqjsVgcBwx/HYs7BpRna7eYr5IaI+qBfK1oUjBgbHzMbrrxRotGo6QlbSXppJvUK22J0DTYoG6rxuq1QYwHjIgehpId9ACzZ8+2FSuWuyFkRzY3bDXaOI4lumRPXscjhUuagogjlnTsiP+eSMR0rynfJ+A3TJmo1Op1LlvHYVyrUCySccrGMRx5Gw4QKN8TIuvMl10ViJ4A40tS3AIUZBFNOHdcN8oKwGqV9mwI2CDtuDGeLUlUcfo2+8tf/6Lm5QgYIAGz0k739QnQRkhLNkMJkDkeLcrpkY98hIPeHXfcYRmlP1QXj8XZiIyLuEpkcd9kskHAWO17bGhowBn6aI/NTW4LTqekh4aGLOQgfDf/u9LMKON8aM1/19gtt95C/c+3ijrnU27nzk7iqCfqVtw67M6gEWnSzQAqsiaTztrfVB7/XLXKNm3caMePH7fycpXXZQNC+f7+frMKLdEmI2fNamezbtS27dvtU5/6lD2ctWjRYt/niRMn7F4LdgCvYCdw4Tw51MF/xvXX32B33XUn8/vVBkDB2VMOWETHqRA0xno3fnzCeoX6dUpVDD8jitm3b5+tXbdOymqn/UfaXBTHjWTQLDuktpXVpKxZrA1ec+014v2Ug+Z5555rCRm7TDgCE6QzOWpbZZJHBxAEpXhC199r4xMTMnCRHJyxzZs3eXYQACJaK/GVbEja/PkLdL0kdElJsHP26BRLOZ7q7KRs1TEuUON04mqeM4Se8MQnu9iqaObKNU9tUtslxYqo4W9vQnbK2LVr19qWrVupK7JCNT2rjBlo9Uc9+lHi8QnPnAsvusguvvgSM4xSqsLB2WzGzj//PBuXU9/1rnfbi170Qs4DyFTPk84irAULF9hP1P396le/snPPO9/e/o53eWd47wU9skh1AgPdYlD/wJDt3bvXFqusZgl35s+bC94sdwe87GUvsSD9yxhQBsHpSm3vABhVZOHqPqXwosWL+VB7LjfPVUSX6G/AjbotKJtGpdc5h5THEdlM2j7+cW9rJaD22xe//GVFqcU++9nP2A3XX4cDRIUTNqXo4ggJF6fVD0ph9p7uFUa0m2ftHWuUCVvUFv/QWJ/+9KeFTc32spe/zGcGGzZssC984Qt26NBh+9s/VqvzO1dqcgV7lSN/bSOjI25z6He/+6109ytbrJL0ysBfnrG5M4qTk0LmerviiivsQjUb85VKWoryGEAm4GmWc/LoASnAgmuFdDZLY6ImZp42vFWguFnt7G6rE1gOyDB6/pjSsiy9yy216EnZFhUDIG8BOhasEo8nHNTWqex279mvvZxrpzpOqQ/oMy2+U9nsN3TSqPaGRGhrbZVg63UH7N69y1at/r8WvxcafPeunX8sDRLhc+ZsbKLCH/zuwOhSlBsMDQzakqVLbErwD/qfOH5MINOKBEUoEUW4nL9Fm+NEXMZvda7ftGmjNysA6SvV9CjPZMR59te//dWe8Pgn4EyQnPPhdEqMlhaprTReat/73vft5ptuMBYCqkZOikr3cxzZyZjM1ayPzg7Zug2b7YrLL4GhhAdzKREcw4D3haH//Oc/LqDOlkBZXfrPe2cGwJhQBBAeAFm90JVefq64GzchknbQZppZi2QxGwLIcASlsVD1/KxnPQNQ4jkB2aI2eE0Q+QCISu01myAL7z1nMLpGYUQEIUS5SPR4/cNKBBAZDu3iGPZHORE8zkdP8KnxEuAPrcqpBUYGk9yABcqoimdpUJCraaUwc7jRktQt9eLi/X/YZZdeYhdpdHXa6W6Gp97+AwdtjqguEY8TOXCD/r48Z6CHYDEb4PeqqWqUJyDp1wgWooqFAHPV6lx/hr3BXkSx7DRYAQwa0zXQL2FlCz2HssFtDumX4AWFsrcxGGPIAC6M1AVhMZw1OjpiJ092qO46uBnUKYMytlR0NkdMMG/ObDlohu3bvxcW8Ci3tTTZoYMHFa0iQCcx1O8pyQI7OAaVyJpiAOOYYAAp+h7RUwZpjCSjgoARcYxHT3AcDuqX1ojFotanAPVpRqDtWFNj0jZu3GRJZeTcOXPG3AHo9YH+0TS9M3clkqitQj5Pn1+eBSJfqWUiScDgezj80aI6xtMjqj8kKMbxOSBjoaLlkrp9Mnbt2nVqc/ud3qJKW9IcYBqTohzJZVUurS6QyBJ0BGoPTYBCbJWAmTt3rgscsOPwgQOWVzAIDq0uDmqTjqAMaLzIjHQ254DZ3dllQ7pvPFpvxwXKgCMYoL0OObXjfeZlkpC30pzQnzNzmxh3zUz6of2F2nWKUkQsEFF0w7bqn6s8CtfdcIMk74Cc2I/zXOSg6U92dNpOYcFf//o3ywkXZmoDz3/+890p69ZvROLKoJNyTp91dnXZRRddTMTkqPXWK4cel7Fbt25RmYw5ui9ZskQS+dE2D6xRdnbo+kkFA5Sng2xMpaynu8efI3TJ6FgiqeiftgbtJ1Ib0TlVpWwKK2POYONv1HhtDdFqCiSO0UgAEmQCv08qUkSAusdgUg/FBQX19w85AHFuvwygzpJCXtTa3//xTzlx2GXnFVdeoZTbYD/9yY98QnuDnLXynHM92gltMEyUJ6estq5ex7dbrSixKhT2pmVKHV5ezocaC8WCP/hIiecPaviCMsNZRDysoJzu7QbktN8JXafNBtMZPmSGAhd1gBtSgKLRmK7RZPPmL7Qjhw8c8xJoaEjSwe2Lx2Yyz3PwmcIRqk8AplrGw9UDivK2g7usXfJ2//4D0u6zoBRq18GsR7UGAgNwRJl2NK4bvv3t77AVy5bZnXfdaatXr7ajR48qwr0ut6+86irUpahxCCoFd3C0HNxnKNTHPu5x0GspZetU2zXSHov0/WkfgELwVTo/om5zKJ2GhhXAqK2UIEOup1LNVoduSCQILq0w5e3ObWpp2++Y96OfQIdmz3nW04czQ+k4KUWdlwcg5pGn8xOoHZDXz/imxqXwzpXAueqqKygbsUG/tbY0u3wF4NavXwcAKeIrSVu/XjKZcAf8+le/lBbY5Bn0AEszxevs1a97g67RqwwMgfR0nqSwP/mhaUJOA9g4G8PpH+6Rceh9fUHmkI0q4zGyiiEtbTrf95rZbHeAVFwtDKTU/zd9crfqkQtiCKXgnKmL1ujGg0Np27Ztpyu4nCQt+v9FL3mJmpqVwRNkN37vvn1KsaNEk+uQIS6FAT2GG0SKaN915532+c9/1u5nybFX21ve+nbbrI4SLGLiwznDEk8XX3qpI/6enTssImyCyS+65BI7fPCADeo+4E0slgQkYQXRYJy9CmxzJQap/ZOZPXX2vAV1ISm/Ghygm6zTl7fhPSQv7MCNoT8MGS+OW1gbSKUapM/D6qjmWsfJkwKoHhwAXvjxUNt5YoH58+c7VXZ2dnJzSkr6e1QOOq1J8CldJ2XnX3Chvfktb4OvXf1llcbcd/PWzQCsg9W0M5D6AgYe+SkwyHv+rq4OUpnf/ZyTJ445Bk3rOKlOBS9tRWS5grl0hWYQAtZRZQhdYzyR5KEP2RuaIRoKhqKX6rMNJMfoYH6PLmCVuFf1f0gXrbVUYwPUCGV5XS2SwhOq8igMXUBNKuoDRI7fvSnKKGs4Pqxapq7BGxyBg/Pa/PBwDoWJCENKE12iBnXqGH/S5MjfKjHFw9FxZRYpzQCGKI+NjMJeMBZgR9fKHEAZc5lTYo0CBxbEkik6wSPTxXxshqIWOACDNmpTV1WrXmh7K2XpZLHAjcTvh9mIhMQsn+U1yhEdnd22YP5c+nPYg59uHACJHMWpiJxNeuJDtPzBxmBam6rjd/H/IAzgEpvUhmG4R5canHCoxv+GovUdT5EkqecQRcsMDdqpUyctpvOiwoBcNs2YTKxSp79jXJOGDRMYiTGTQKr/m0f+rjwLhViIiJQW4uM3cshVYXGmzC6/m4MD9CtGqc1tc5FEB1evDw894qIk1Bg3AisQMdOxqKKRh29xiGfHUrXKPAQ5pikRGoBhBsc2Czx1HuIEJsJp1DsbdOelQHyBHs5tV/RbRaOdHR1C8hYyQlTcL96P87iMIAWjfLXqi7iHq1SCFfFrh39tpZXUOTOEnEEGYID+U3VcvzRhNAYRCRUCEeCalAEKEcHBJssPR12KcoKfZGgLj3qPZKjL6FK2oPZyuWGkKCmqxmknRlMSZAzXoLuDfmEXRbFG9wTUoqA4TuF6CkC9i5+8nNyr6/CEarJ4N5nKyAtH0VM4ey0QC/ESRXdPz6mhdGZJMAjOZTKx6k9+6lO1WpP6EIGi+DliZjeffTHJLYSvqaHyS060quXXVsqdXPC0tzzCZnRGlEsPUTpdJXKNluYmHOQY4zSrKDHGTiZdl3g3Vy+jATmeLsFI0OCEsi+nrGJoWu+jdqNEfD9JORh8gR5xEsdy7zlz53hneWbyzEfi0ehGfYyPNELtvR+NUXNf1UXfQI+CYSyMISpEHkrDGZoplrqxM+YlUpEt5icyxp5ySk0o1YgwootUJDtGBIqD6TQtM+KJ73AO0hWjGLcjrLRplVg8hdO8TMYUVf5fqy6R9E80JDR4PeFT5oJUKfuIohJ1XkYCa4b+Ie3AJOpk9XT1161iVYWr7/f9AADj1TLkWxhBFEH2fqVZRhvmwmQAsnKOUou6o07vqXhhqvINL/4uggGKRr3Stk4b7+zuJqKwhYaTx9mgsKWV0hBtdiNo5NTp4PGXSmHElqmp4lqHNCBNNDbqWnGGJdpflUZrB5hA0aXq+rWaIS5Sjgsz8gUEkOzJ08k+31/urFht7bMf8C0xgGuNbn4zKZrRBOjYkcPS6agxfyDK01aeBaL5qbnyy42soB/HUUSrV5S1dv0GUF4RbwYX+M47uJgcyXlMm9f8+7/CiH4yhB4emYusFr0Ng/4oSZ0X4r0AOSvjOkAhV/Y0Im4kkvxZA3v0+ld4UZCUAS9MPek+Y/Slyx7QAURnicbgh1RL1bSfpVJgs6Q+zQ/cLSe0AzggdPCMDvtBXzpJR3QkaTqTdVHTL8prSjXy4ALO94kOIzTEy1e++GUbVhQbldp8B0YUJguKdJzS4n8yMoeggt/JMHABaUt2AcraU55eQvunQ2zimNEqM3j/tN1rxRKJB3xDhPd0jkkGv1Ta4CekOJQXvMBUE65FYiI1UVve2LCoWwSPa3O43Jy66OTIKDiYfkG9gZqoUnpDn4Cf13xt2OrP1AOm4IfO9uZFhvtjdR1bpPOkEVI2Jc1ZQendrEys07D2bp9CD9MrlBQiY7Dw8+/PeNa8hfMe9C0xovlTJTOvmb2TDUBXCJlUc4tuUHTdHZHExfNMjYg2Awp+0opyPEjM2IwNyeHUiTuJxTFEP3jRkmvQzITCTIqYAul7OZ7xW94fuefVOWadEmcqKwpSfWRjYnJKmVQFZUqmp1QGNcYaGx56H+8LPqB9PIG2B1/w7bvk8dl6W+N5LXialNXn1Ik+5nUAUUkDGJTHEBInCPiKPiIH/Ih2SsDFaJu2F4OJfFh/o+7o9khjlBqipUr4wuaa57S6kwDeegnTSFjdnzIDRqLOB7I5MoNzVELjltQ9GpONrlV6O3u+HalLfNIeZBUnRh76u8I7tm/7TSyefCbpNyawQdfPnTsPOiwPIyvfGdYPp0fhCGXDRjmOOi4LKA4G5DCIkTbTIMikKKexEqJG9D0awutbP7keFOjDEzOpwVb97lJZJRSBqiWFI983s1fY/1i9Hace1uvygNKP9ArLi++RMagwDGJj0BWGBzyAwZUr+BuBTarc+3sQnrLYvGkLlIsRwpwYAxnwgLLDwCB7cCb/RgdQbjABUhi9RuP1NTN7oz2EJQwBBB/yYjL0Esnew3ra8yn6/AalnIshaK88RGeTVWff9694/T14x6zy3dpAPUN9GMm8H+fSxmIoAMr5tNQTyoBCfoKIl4ASkJ1yhxUGinSBbxDufN0e4soLQ0L28BZPfD99/MjRjervV+l9oDocQGRwPxFwOVyykfgFbglSnt+DJT9hXPl7hp0hgFZGDfT1keo0WzANzwjR7saaGf3/sYCz4b/3f0ETraCB2g+/v/92+/3j12mSPMNM/rY50MQmm5qGxhJgARUKjknIyg3U7S8gcehYAmIPAITFCF9HDBYEZSdQWwG2EhU+AfLjO3hFCZjNzALBfyEzP9DpL8Z57z9/TAWHN4lAVlIWfxlAZLlgDcyrs4GxqAmfSUa0CGGTFXDPY26mgm6hAWcxDuRFlLCsBRODrQCDmXkButrrHFkOh3TvqbZvENTJ8WRkBC+xNYSuDkWsMIPz/8OX3yH2/MBTBUINopBAWV4M1XQCGDCg+n0fhU4G9V/QAoByABobNAUm+XSgR0FL7kSBjkakAHgAYG6bwxRA2SoHmvdeD2TOANKXqONScMqjMAAIZw8HoPnuQD8bAB2vBypDwakBsfkJ2cPIs9BPgNxL0OS9Hbzrg/oAVIbw0nP3OGgaSx7YEFKCbrkTAJYd7NAC9AfQ0++BQfMC6Ki74K1vtASIHi9SAIw8AOqB8gIALsIn7qmA4K4AAAAASUVORK5CYII=",
    "16801": "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAcHElEQVR4AbyYA5D93pPFs2bWRmHtLa9t27Zt/W3jZ31t2zbHM2/8bORZM9N7PrfyT0397Ft1HpKbm+7Tp/t24l2/fsMXvNcT3W77kyuV4hcUCrmvCILaV7Tbzc9vNIJPFrzXE7lcyvdG7o/4gvdaodNpfWO1UvyrSin7ZD6butpoNuZbzXq5VMr35Pxqs9lYrVRK3UIhWy4WC3NBUL2cTqcei8Vif7a0tPQ1gvdaodWo+jKw4Qveq4lMJvV9a2srj/T73eVmo2rVSsEK+bQVCznTMSuXC1YSpASrB1UTAQ4zMzOWSiVtcmLSbt++Y/FE3AqFwnxQrz3Q63W+U/BeTZiZ7w2HA1/wXin6/d4nF4v5fyzks8s9OdbvdazdalirGVizWbdarWw9jrUbcrpiUoYNREZQq9jc3Lxt2rzdduzeZ+cvXbF3vON9tv/gUSuVSu5aiII4jblisfhXTz619RME75VidGzU95qNwBe8V4LBoPdPcqpZVRT124bDvnNeue3Q0u9utxMR0Ok0zc0TglrVzpy9YG9487vsP9/4Ntuwdbc9tXmnjY5P6pqWI8tszRgrKz179LGnbNOm7bXhoP8XgvdKsGHDNt9LxOd9wXsZwPGfkLPFarUoCedtRY7jGNHCeJztOcfbDh1HiMgIo1+v15QOZRsZGbMLl67ak5u22569h21icsYpo90oOaUkk0m7efOmbdi4xXbt2ocidJ+uUqucEKnf93JToFwu+aqESV/wXiJYYNtADuNQUIsij6OSf9d6nSaQoz1nME6r8jpJ90JJK2Usnc5I6mWppGW5fMGWlpZRilKnYfHlBZuYmLBt23fZO9/9Adu+Y6/WqOG8W0vFlLkce1TwXiqGKwPf67brvuC9WIyP3f+6druVxQHlvQx3RpjI4FvHhF5LTjZDQjphDaiQDpDhjvGbwqcoyIE6kXYONerMrVpsdtZuqRDOz8/Z8nJcRExZNpshfdx8CGh3XHopNQYcWxwdHftKwXuxUJr6niLjC96LQSaT/JnF+RjGE/HQ4W70O/wv51sAUtzcTDaN3N055kACDrdbTRTDfxxxmJqasjt37tmsCED61UrFmnK4VCqIrKJIcsQ5rK4O3DVXrl63ffsO2NjYOET8gOC9GCgwL3obFAGN322rog8k+T6Ohk4T5aEc6+g4ed8n33FeSuB8Khm3XC4TkkQqIH+dE0iVwbBnnVAZzFOjZJOT01JBTahEjkMgSioWira4sGAamjdh//mf/2dveOPb7apIUE/BPbHvFwXvhaC5Pj/8F5iI879d117ebQW2ovwjsi7ywBU9cl431/l2oyrUcNIZnc9ncS6KskiIlODSSOtRRyBuOb5k8Xhc1wWKcNGq1ZKpB3Apwbh8+Yo9+ugT7AqqHUl7wxveZr/2639gJ0+eMsZwiC0iGoW1Wz8neM8HqdP3ZIQveM+FQa/1441AeRqUVeW7NgwdRgHh74iMHlW+RZGj4FWtUs5HOa/cjfbzCAO+3Tk2OVtYmHfyhxBqCzKvCjIU0rVbjNpDDz1mF85ftN2799qB/Ufs6pXrVi4V3fV913+49EKNUlnruwXvuSCSn5+Abq/91ZKntvAmDsKwMLA+DjWrpqKIhEkDHOemOKbIlR3oBfjfjQxyUQdRweQ4zjKmp2fs2rXrVHmcQPoqitVou1xcXLJCsWjHjp5wqYIyKJpOiawniPyQ6DYElKS4LxK8Z0OzVX9+AmTkvV6PqPdtRSDiOMsN20EBAtjmREbgDG21m5J8zm1vTSf3DvnNd4jI+UgZzWbNQb253b17N+oYSReIgGBFwG2XD3z0UfvgBx9QGjylYjnNGlEKUhDXhH4XRTUgF6CIS4L3LIAE3xUCwXsaIOCdQtixASd/EC4sw+RQs64qXclpK+pbKrFkC/Pz5CERjPZ7IOKiQugiJTAHmSNfqviePftNzxCh8V233Y2NjlkqlVLUT9ov/MJv2H/+1/9ZMpEwxorIYVATSIOctsliIY+iUGtopyu4/yV4T8eAIigjfcFbDxn6PcI650FEBsZxE0mzqugFrpoj5cTSvNUkfeco0Qkdp16Q58yX02Ef0HIpEgQVze/bkSPHJeubUTGrViuusl+4cNk+8KEH7I/+6K9sx449ThUMoo3j1Ij79+6rU7wtFS1aOpOiRwhthXxIh4T2twveeuA7zvqCtx5y8CILrIdTQFj9XcMSOs+5hv4nEstIf32FD6/rQ4YMLTI/Io5KX5OTyJjrYrE5Y7gC1muR23L+kr3jne+zd73r/TYyOhpFW0OSH9qtW7ds27ZddubMeW2hOchk7XArDNOsL/RaQvvwM+qA0t9bWR36ggdAsxX8OsZj+HoCkFPYdsI6OSpTVq0X7t80OxQ+9zwA8+uuZa57qtP11IhkMiHCltx8urjx8XHX5THu3b1n585dtL1799u73/Uh27lzr9TSNga7A0MvUmz3rr128OBR1Y0Ry2bSrO/uAzGoZzYW41khrCNR8f0pwYsAAXfvjfiCB4AWuiGjopzl20m804x6eeRM0QmCqs3NxjCIyJJryD66DhBRCiJEsZ2lUmk5n1CDU3RSX1BTc/vWXdMQiSk5vMcefeRJO3r0mApf2hhEslDMOcIuX7okcg6IpMvuMTqdSvHgBDman2InUYM0qZ5imXtjy/qd59TT6pzvvee9H/EFvjnwc8P1sscBZ7giKOdhmGMUrVqNHL1md9SvB0GNxWE76hK5IQ43wsiwXl1rLC0vmlpq/XcEyeBpKSjvev1HHnlc2+ANtrtI6lwLWXzPz83ZW9/6HrukJ0carLTWcXY1AxXBgnuhQq+AyuQHtgg4H4FjPyB4DhDw1MYdvuABGbRb4GKkHBa7Bs4SeeQKGUSNAsVbmyjvhzrHN9uicitMlTLFjv+uT2CLK5fzFEpSSgbHkLtkfF8Fbq8dP35aDz5LUYstKcuZPMdEyoJ7NpgUUXFFV6/ULEvBUy8w6Dk7KaooEIQ7kDDoPJ2AJ6MOlyJ4+fI1X/DM7MvkeG9VjjBwFueQVafT1n8XLZuJxZSzU3ZNjQisEynnfNSItGUUnWNFRjVDZfQonHK84B6RGWNjo7Zz1x5XwG7cuKU1J3GQuZQ4WmGlSlzOLyqq9znnen2IgEiURe3Bae7B6zaCs0b6fqxmCfqOlBA2YpXeoPtZgtelFZarviBGWn++trZqjKXFefXd15VLM7qgL5k17MSJU3b+/CUaEhFToIJDEkXH3aCl6gsaAs5T8cldztEJ8p+ewWzocnfH9t124/ot99DDepVyEUfcekRTL0mlkGkbHR2lZoQpJTUq3Tr6rpYL1ARqkwpoWkVv2jrs/2GvEaahu/9ACHsLAH5T8Nw2uLY6/HTB0413KoeVi5N2TFKcmoqZhm6etA988AHJ86ScaLr3dA05s7Y25GakhmtZA0WlKdk7KUoxSN91gV337C9Jd41Br79l6y5k765D6hRXnGM9ClepmFN63eYxV87l3F4+CO+FwzyXNGqCinBeKoAAlEfa8h1uw09zWkSE/2XTE4KnZ5HP4MNBUo6zHZ04eVZVu0V0tc/etn//j//TfnwRRsNiVDeIovGh+lKMSJVKtcy5aMvDoU6Yl+wauVxazc4xe+CBxylWWqPDfEhgvlsPwpD+jZs3lWK3eFMEQezlzFPxzEA0b5kpfqwt5RRQnJyn6DnFCS2IQgkgejjqC12H9oTg6eHp4/lABV9G9HgdVa3Wwr02b6dOnXNyZfAQRE9Of7C6MqTYkeMco8cn4rDL4pwLmya+B47MebXIp06fcykUDnYC5lNH1NmtaN6Qx1h2BV23YgyOcT3r0xo7NWht0pVrzKWt4L7XQrhzbs5Q13MfAVvC3z1s9AXP40P5+RNsZThDlIvFor1GQzm+KsJ6cmrFnj44BvCh2WzRAEEEJMghHDQ5tQaYJ1UOpI4Bc/QtMns8OJFGSJ5zODs0TV8/NH/I0+V3Cp7Hhxz+e57GqtWqIj7ntrlXa3AzXnjWagFQNU/b3MKiTav1HdeWNjk1Y9Mzszai11lT0zH9n7ax8Umdn7VZqW9uftGpJqftMJPjSbOk3wWgHWHZUjoXBLw7qLqUKeh8UXWKewX1Bvd2hXzF2dGGVM2t8MrtDwTP4+P0qbPvP3b8hC4s2q2bt1AADLMwVZqFuRGQPAuWLygfs3mLq0CSNjiUSKbU5CQsqU6vqPkYWgsCB4xljby+caRULltC867rAeayXmjcun3XrqgBmhEpca2zIMfSmazWTIukaVtciltB98zmuLbi7KrLOe5TUdDYHhuNBs5JAV0A8agten7odDq6pg4hBJonzDcInsfHW978zi0L8wva52fVZh4U8wvIlEXkQJ2bY7xkU+F/iIB6QWsrx+MiJKcdIyUkIUHGJ3Usi/NERLndcddgPBEhHzvdLnUEwzEQJ4gkhmJkGADnrKQ8QNaRXawx0Bp84zDpQJoMw0izFuvwAgW7+M09Gexm8vuBiIDNmzftHx2dtD/787+zd77zPbZ923ZFKGNPH+QerIKn/wcMjCEiFCCM5WbDwQBFhfPXbCCjOdfQOb5xjDlhyoBnqx1cH933aUPr9F3uP320mi1UA1FaY2VdDShsFjyPj5GRkSN/9md/Z1/zNd9iP/IjP20f1PP3uctX7fips3ZV2xGSJAKkBtFeWFqWXGdRhZhtOsbn1b9f0fM8MkYNvMtHwuVKhXRARWyvEIQxRDyMfJd85dgLFs+wcEZko5bY7LwtxRN2Sh3lhx98xC7KbuzD6dV1RFEQUSxYjsdprnYKnsdHpVw59P9sWoWxJFcMnEIn4QiciDNwEs7ARce4zMzMjPeZmcF4zMx8crfKY54qveV9T+pWS9raDmp0q9WRWXxBdzCWSrMjNrdf4umcjCam0GzcYx6DWi+l1R1IKJ6WialZWYDTFK2NrV0Ea1nF7Sq0YG1jS9Ywqu7tH6o2PIGWwEmTCf92ynz8v6z7O/LmexjkqZk5CYTjYnF6JRRLij8ck4tWp5y+cFnOW+ySzBZwrm2KK8WUOoWgvyHzqF05mGFwuX/vXgGUNbeEyN2Hk0NpdvpSR2CINllAbbiKaDO36XQGvXwsmZEsRthEJi+VRls2t3chjjdVsFSIPn1GZ6iom07yvkl13jeVWl8zXzdz3bz9d6rdRFO0srYOsEZidXrEg0kygrPwHFHcOr1BiQCkSr1FP1STzOvZs2cA9E4IZhhcHj9+5GV7y46O/TVFhyUG1IYa35XeaIKKTTXGphuknjLikt0tjXZPUd/e3ZNOf4hgVPQ5Bo7lbWV9Q/qjK9IDq4ja34Mgiirvv6OjGgiWKDMgKnSqH//VhC0E2g2n3f6QeIIRvW/3+MUbjEo6X5IyHE/lihJJpJXBg/GEtHtDKdda0kdqX7t69RzMMLhg8PiBww17cjZDRHl7Zw9O7dNpUH1GApGEFKtNqSI12Knx2kMNn5yelV3U7uOffgblN+moImJxuBWFUxDVSzanXLA4JBhNot7vmc6zSdEU0GaHTPmjROG5/xU56s/PKLnTcwvcQ9MzX66K3eWTUDShDpeqDamCiQ2gDsPrNQ1IDecu4D5eh278xB9Wv4cZBhf09N/dv3dX8OcGjr/I2wMVsKvXb4DO1zV3BmCBwxvSfCtW6lp/H4EJO2hmmO+k3gyGF/YE3MzlC2n0ed8fijFHFSkePJUtEBWwao1ppU3Q8so692EZpZNIpR0ZT07zfWDWCADE5aLNhfy2yPnLdlA+ArQjkitVGXjVg+W1TQZY2XoFoFHASf9aqwsWTuh7M4Uyew8OY9/CDIMLprVvMGygA/xJgzA5M4vDZ6joFDCqtDY/qxubdBAMuSGzC0uacxNgAJiCw85oY2JeDE4CjrZ7AxUnq8sLJIri8oeQOi45ee4iKUvqqlgxqBcgYEEgaQWiZy5aQe+wCu7s/BIoPEn0NL/p0HBiGp9pKOo8A61Ua6o18RnuS2BiYIk3FJUAvjcOkHgmZUS99TXMMLjQMAs8v337Fud5fNkMAwCqLSKPj9XZI5QbihHLG//AwPJDx+cWlvXPDfNLK+o0L+Z+HYf0AXmnL4gAxJUhGWxMZ8kOB0rWZYdHEbWAFb3hGGzalw/YgwckwhTejc1tZUAXr/P5cDylTuRLNUmk80wrPJfGfj3sUdBzFxDMbLEqsVRWQQqDiUzhdK4kxVqLrLoNM2jGvTu3voKhHF4b37xxXcvg2bOXeMvJTOeCRCr3e/lmER7JbkVhhbGSbZiTXZgZVuFtGDdh3ISZV2FmZoZBMw+0qcFtN4/bHqYwVv5fGn2Pmd9bnK/cVSqV7rmgqysZs5mxNIW5HSQ+LBPlhyX5Qzmyd5TqzjKm3ETwhvm7tUKC1CJ5/Wp54CDtl3xuAXPg2h3LanjwgczTtUCNouiC2+KGxFg8qTB1zc0vWO211g8JB5l1lum/TvuqlSkryd7zt1Ui+/T75viOhee61TxTYBWXSs9ty+kzD1/9CgQ2WG8X8iGp4ebwAxY9XvnK15VfI5JWqyuuwXmhSXHigGUpOqmXw02Sm1gq6/sRrGG17EHMCVeRVHF8fpi1/xGwjbAK7abnEoQMBl0FTJUdy2ZY2ykPSRw7bDEFUpapOo3Z3jI5O009t8etOts37hnrAY7LOoB/08cp/45FlDP0wbYYwfR0rEnav3CX2QqTNUTrEv1e5+0gDAa9IsB8AcL8/MIjv/CFr5afIcip6ZMM0E1J1/GuEAXn/soOg8NiLFmbT1uLc5/Akpb3HTj3B6BvtsV7aAT2O+11B+lM4zuSYzUHwgYWVTwJQkV4Gm1XojV4Dw2h3Xb6DqS3OJzhvSGCCNtIjrVBLcs2wv695mcI6nj8hmVz+tx4EAjr62tFGBsbK0AQaHTOOIAGeCkJoHn52yMrmt4mHVkzPIhp93odtS2zDowBNh28biP4YCsS0FpfK7eHAwem0F4FwrM/wEDdxJiamool7UX6NRg7Dk23iwsYmA9hPWuNmoIrrIKpTQUDg0wCK9ZBbmNRR2HLRnpPd7ISvRsEEQlAwwUIAr9768TkpD5syTua/RraoyEusVw2IEAWF6jXTU5OlF06P9Tv4gLtyHKbgfvOCklRBWvxb7SmyflcSKBaZ9A9fTHW/v74xz+yLzjr9IuQjbhrZOnbAfc6LfslzixqjVqYwimQsD+uA6fv81uHsKKM0lYRuurfkqElvxoEAWlawHgBghgdHb/T7j0jx8aZBXZSG/wNc7j1OY64qgXZdoBq1YxR09fMtAAH5QAcLB+tenwlflByJMBnthvShxruR0IG0eclQeEU2HYDyJGEAeR2scBms2HAdAvdPUhjiVct0LZZYMcntAaB1TZQWtUxefrEe11iyi1AEHyrCL/+9W8KEDIW5ve/b8eOPRxJ+7k7tjJm8dGCZQxgpxHcnRgruPlEaN6I+Nf5SuB/wddPEMA86Oi7Fia9GldOpqxTISXOLTY3X3JF18BnjPAYLYHtTNxIOXYYk0YRtpV8A6HQ1xU2E4BQ+e9MkvAdv/1WEDJwwcLVYAFCxu9+v/POX/3ad46CpOl4lA0wKP3WqCu8771j+JkDzIHQSnHarjpjhPeq4JKYcI5I27uv6IySybWSax9uiHhuQFIkyu90W02sp0f/kCK5RHbbCImQSIX2anDknpAMr363w3duCUIGBzuKgPkVIJwPnqF9rdOX21lqQ/9RsLTpccpNEUlwGjKIJZNzBoiBbkt30c9zpPeqptKZH2eLOEVyn3a+Lxn27yzSIHcw6Fqctb3vqVXdSGFyRLff9LtLX84SR85PmkrIY1MG+38JCOcHx2kungDB9tOo2hsSXCokIg4yC30a9iXCQTsH+9Ez4PgxI3uXwNSDjCR8JsDBqF1/b6XB52fGCv0fwRQoBTOtTbOVTLXqNU9v9uPahX5ws21ItVYRNa7284yQ3cHrb0G4MDjJbhAcLUC4MPjgA0hQ/uM5Py0gDZaONwegZ1KiUGmgbGbor2qiyZRjsHOQDlqtag1OY1qI7fMz+6yurhAEF5zvEU4BopA50vuukV6h/LZB101XhRKOI7VJgTjDMeCe27rnWYi8KwgXxlkPSk5MTBYgXBzQzsu3zqcprw7cv4UCe1Uo/BRhz9O27STPBMgpT/jMszxah9PZcY+3VCrMOLtjXpFK80dNmMw1fD+5Vg5wuKVQcH/rDv1e19/nF1xCJE+itc7ng3BxIDAXgf34AoRLgCR8KgmZtG3nScgjmmEiBvhhhZYIiYqW02k5leV3JAzB2tQPu2nZyzTlzvD4xEw5OzdP7j5Hylwxc9TndaWcNwAJSNNjDnY+U3itQ3jPtqbpw0TIu0G4JEQCSHgKEC4FkvADzdfOFTRpwoEJtIGQCmz2li3E+5JhmwHCeNXP3WpbqiyUB2ZHy107/lT+gsOO4+PTEDFf7t6zh+24PSRP65Jo/IFAtUwu0d3Qvc7FiqRxrSprP/q6SLmAidGXQbg0xPMBM9MzBQiXBQT6KdCs8C0XKmgIoSVEZC1tAcnwd722gmDTWELK7Fpov0Y2uecPvyx//6sfl3tHKVrMzOoGJkNmoGaQCqSvI3Sr7KzXU7aJKzXrq+5D0FefuJSSIUlIqa/YFLrG10G4LDBrFKG6ulyAcHmAVr59ZJtovK25D1PEdbBoSzLqTGErLoNXV1k270f4WXNvBqw7dGMG6BJ2P0FvPwXNZnPdZxlmhmg+LXCc3jYarDQ3yDzR/BqZZX112dWpyZlB0wRHEoBaj34vPgfC5QFkFWq2AOHygjn8nbpDDoz6asqzzbvTOl/BXAwZ7LaHQwMV6Wg7rsVr1bg+dzXpASc1aVuFgqy07oim30PAdhOhl8qlA/PlknUFrMP1vmQhMOj5PogE4h6tN4JwecFiqgiYdAHCFcHWsP9UCPibZj5w4dLt6P9mcArpYkhhQB3Nb0iUWlJQc3oHbVnaq8QJz/z5bzG+d25KI0iyiGlWVwiWnBRhMdTqtEx47EtrUWDNXTJPsXp9NAhXABCwVQSSnQKEKwqC3a2pG/zM6crA40DU4ji1Of8DbAdlLIU1IDVJebPW+lw9+ORenUJ4Iky/dgo0ITKaG2N0szazRAvhXVXWalWDqkQni2k2tTz6Gn6TezcH4YqC71/4/wWuOBjME9FYHUYVUAtgTq9o6pj9htVX/TYmOPq25m3W5nkE9iNibn8K+NxAZlzR76P2cYc6gltjMG8w81TrrvIItItY4CNAuLLgDFRhTlyAcFWBUM/aWG9VNGWTGk6elXt2jzp4BVYAXcR4AHox3x9yz5Uh1pTyCgmKwY9i6+Q41aEDvmMu72amV2aS1hzW8AwQrio4dVJoygUIVxcQ/tFE+G9wvOZopbLsoM3pzcjUsK4SSTFYavZajS50BovwP03WaytMh5MURg8qvMS4qtwmpf0S65GHgHB1gWm5CKzXCxCuCTD3P42y1Cc4GL2D9fdQDevD3NMF/IeouICxKHr8yGZ56hh1QIRmYIcIdn+EuI9Q0HwCCNcEfv6LXxeeECtAuDbw5zOn7s26/On8k9WLKZ68nqNrbyOOvO1ffz32ur+fPfzCMyePP41DmfcE4doAi64icHKzAOGmCA5yFP8H35ZQ6JdZp4QAAAAASUVORK5CYII=",
    "16802": "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",
    "16804": "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",
    "16808": "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAZWklEQVR4AbyTU7ocWxiGv1Jrd7m2zcaxbc3h5DZ2JhHbtnkZ27adtG13VdYUNt/1LOsndeDAIR5AGiNIs8yb+BqbsHnXAcv1ew/R2d6e/+W7r9IAShhBFs6dxbM0RWM4uXH1qiuSSP4u8vavv/rY4VBluZ6CIYejUXs6X+IUWYXVYivRDJONpzKx975goE5Vnrj6Oq9Lov00gBcYJgzDAKvrOoaaY0eO/KJp2qhPXD3/1Wpyx2uPH999/jEcPd0IRaIwcSzuPfYgVyhDUTSYLFZLKJq0kLkqCmKvKPK/CELNGF038Pqd74XHHzmaLRS3A7iCIYRhGLAGDAwFD+7cMpXK5Yk0qGmffOTo8PojePjkJb756lOQMRgaRPkI7Lwd7/whPHn1DhzHgSiKpvo6ciaIfLEEi9mM7vZGUKScvngTZK2H5209qXR60t8/f/P860+di957/GsBVDFITuzfCppYAYOtGzdsmVEoFKM9XV2LZFXtyGZz+PxTJ4oVHR5vEM7edgiihFKlgldv3+Pa7Ycok3EylURrUx1UiUcwGEQ2kwb0KkLhKN6894GiKcAwEI3FkcvnoevVXvLfSpqiIheuXh9HKgZTGZoGXa1WMdC6ZPma/9Zv2BJyu3oXfvKx2y6JIupra2G12WHmzGhrbkQkmoCmalBVBclsAWcvEa8W8igW89AUAXWKjHdeP0g0EO9bUNUNpDNZsl+AJPBobKglRuZgNtsAMOTfCmiWkRzOj1c3tna9/fq7n34hFQOpVosFrGEMLAUuX7qyo1Qp/98g1MPtdOBD72YB3Tqy9PlftcAYB27g5vLM7HyPeWgf08dMy8zMvIeWmZmZefcxMzPDZcwNJ2ZL6lq5TnT6xCcDDyvn77ZbsqyqLm5ldXWF8WRCs9kkL+CwNwT1tFotdg767O4f8tXL16g12uyVn4fDIb/wUz9C6RzZKFd8fX2dyTjj7JkVXvKi53D58k1u37tHrVZjrt2GKGGcZdj9lnDO4SJ3AZEPLCwu/FPgt/MtUj12xM45vhVqOv8Di4vz7/tiq7F+/vQai50WV0p7vlvacBTFqAjmXV3EfGeOdjtha3eP8ThjoT3HylLMQXdAHCelOdylM9cqz+uw3x3youc/m4cfOM/laze4u7lDs1GnUU+p12scHnbBe0QcKCZcEAQQkd82GvTf+JZ/+bdeC9ziGZIXiwLKMyUn7se96pu63R6veOQlvOKxl+FVKQpPluW4KGLQ79Nut6g3GsRRRFHOr60sowJpkjAZTxgOByBCHMWM8pzhYMSLnvsQZ9bXGPQHdFotXvn4S4icEMcOX3ie9eD5qbDMPNTrEfNHwk5rdG/feLB3sHvzm1duvBZ4P8+ALm/sEQvCM6Ekqf2aPJ/8O2M4L0jSGi5OAFBTSaHRaPDlL24yGg5YWjrF7u4uUeRMjZ2LGIhYFBDEmJoUYxYX5lloNe0a3cNeiS4LC/Nm+3mWgbdrl0JcZDyeUDpb8wNCRUIcpexs3OJwd5soTt6XIz8L/G+ehqLCE8szSIScc78K+HcKqPdo5BhnOWQFIhiJCJNJxlppy+PxmDIk0pnvEMUxThxpmhiTqpDWa6Rpap+9VxSxaJKkCaunVwHY299HFJwK4hQEANMqrwoieBT704LdjTuMhiO8ml78r4VW46eA/8dT0J/9Hb/r6U0gjqMfAv4DItjKeY8BEJytTqUFJWy1a2nK9s4OIjFgK2hmYqQeFPI8N8FMJhPEObwTxIkJxq5feByCijk9BAGwefXerunANGvU73L/5hXLI4aZsNhuTq/7f+MkeQXwETiZ4kaNGPSpMqWHgP8DoABijCB4iARHQaGCyBSgGpkWOId5f4yULMtwUWQr1G63bRVtLnWktZrNR7XEhFfOm0AcIAoIKALeBIFGmICEI4HV6uxv32fr7m2GWUGWY8LZP+ixtrzwf+r15HnA5okZ63ve+dRRQET+K1BHpPpsKluo2SBeQBAqM3Ku8srOzGA0GpkJZEerPB5Nw2SD4cCcIHmR2/WmiVNtUqPTmcPnptIozry0eAE8AmCqD4X3gJkWLo7ZvH2Nvd0tcjWNNPMrfE6WTZYj0f8GvIYTaOnhx4inqniy00v/EshLJRK7eZEpElQEX2SAAGrHoLDj3hdmBpGPzOaTJMbOatSJ46PMUSJSC5eACIpa1HAiFgHMxhXEeZyayREfd9VmAvVmkwkOFHbu3WL/4JDeREAi8lpEY/r70fS3olffuLf5J4G/xAw98SteSSwiJ9j91Hb0T2BMKT7PUMVW1I1HNGsJZreAgiU149HI5uLpih8lLI16g1ajbmlslmeIYg5sMhmbibTnOvii4LDXsyywUathTtEJ5vcE4sSRpm3QI00QIUmmOcQ1epOCve0NNm5dIy+Uw+4QF0csNWPajcSQ5wX3d/f/Ym84eQvweQIx+sz7ntQE/oKIM6985+5d7pWI09Tse6WVwFyTrFBUAOfIs5w8z0wLskwwlRcxwQ37fXL1+Dw39czyAl/kiIgJKhJBTG1HeJ8DQoQnchGqniJzTEYDnGmg4JyY0CLnSsBk2CMbdvGqFplqToicWMUZRc6yU7Ac5M8BP0Ug1k+1rRyeTXZ+GaqvMcbynMXFBUtFLfV0MT6fcPnKFTt26cK5cvTEDUctikwAHN0kiN30/mGXbr/PpfOXEEt+Elwk9j1Vj0jl4U3D2N7dZW15GZfEIByZHoi9YIySwrPLxOj+9i7D/U1qaWJZo0jP7L9RTy3pisSRFwVpJIwn+U/mXn8UeCtHdPH0GrHqcQFIFP/ByjZRTDVdMwJVRKBeP8Veb8Qkz7jwwLMsfxcXIkFlUoKpKun2NvH+LmfOn8MXChyd5wSqMxGLEr1uj1EOZy48YNpnCVZ1XUDB5uy3VK1g6h7sTBfFssROo4uXiKX5DkkE9TSpwhexEyL0DwQBQDtOicERmHc/qegTSHA6apmfqaxhqr4OT4Si5vTy6kdQL4hQMUl+5NGxa5hfQBFjCgVRjATArpjjBIpiQlSoMekJEai6n6PkzDDY32UyHlOv1Sz+x+VYb9SoiVo+kqQ1MxctMupR9EMvffazXlOlyqPRECeEP+DXKlQraQhUzZljNOfi7LMSThMQqDyYlFC1c1HvArMAGlafCkBeZIhgqObk+JfMdCwyacHezn1GYwuvtFsNxHuG07wijnACaVqn3awR+bw0rVWeeNnjv64EU9zf38EhyhQSR2dE5KfMKXIC4wb7caujW82G2SM4VB0yhYABQDFB2cosdFClhNiIBpvGRltZs9vV1WVbWZRACIGq9NlZOTvu7pIX3r5TS9w09nPQHxIniQlhOldPohIp62tnp473Z0bDfqcE2wd7OBVhCufkJ0SkxjE6rgUKjCcZqysrnD9z1tJYCPYZ7MYB4H1h/YH10+smOFQMIIAGJqsSOo5ZW101ZipVD6QoHEUCZw2ZyeAQign1et1ygywb06jHlh57MA1t1GIrp9Nmh1paw08mS800/bESNBo1a4kVJVD1rwcNKmfj8c94IayecJwUNDAfTAi7WRGOq7Y6bECDjYO1ylAMFalW35FwrhZ093fRwtMfjLi/vc04K8xpx46qxrDEqt1qEddSxllm0UeUN5YgqaXeuc+/d1ACVJ5AHaig/mgsQbiBo5AUCqKno+C4joCnWv1wTQMVmUUyS3qkEb4SaAlPFcHu3bnN/Y1NXBSDOPb39+gPh3jFQnGn1bA23Jdu3WIkOjWZx0sgyjAWheLFbzijqheDQ8LGShjVqikWgo7bZAhNhpPnqygB4hQQmFUiBbU5NcGLQvi94ACtFilyLEmaDOn3e/S7+4hM5zP29qdzXZZPLWCad5QUiXg+fuUm9TTldS94zvNXy3bVvY3Nbly+sOL1BdUPnUSCHGPKuZlVE3kaDVDEwTEBH2mFabNXEOy4zaEwwzhU1yosZ8hGI7q7W+zcv0u7M8d4NLRGzEF3mqNMLBsdW0bqrMaYmkczjs3xfe7adZYX5p8HfMx95voNgGfBjOlJNRzXyVnGJbyfdVwz58mMc+VIwwSOC8bmT6Lq+lEUWwq8eesqSdpgfn4RAazIUsi9oEVu4XA06DEeD5jksLqyxktf8KIygz3P1sHhs0oQT1/EuYt2cQFDxYwIuKe+GfkWm6pBiEogCd5ObLS3JlSEKnZaNwoQVQ4275gZtNtzbN29hgCnlhbojzP8yFklOp6MiVHLAhExjYiTOi986AGef/HsRYD4J1/5OIquqgQV9Sgu2DRVckRQ6RPUXhFxlSYYgBNNJRxTwFXMh4UXkCCU6ssGEceof2Aa0OzMs3HjKriYlTOXqEfKfG9CrZGTxJE1X9uNOklaJys83b1tzrdjXlFu0w0zvwrgHnnRi1HVlt0AClQQjJmTkpHKscmRMMLxkxh/inmpPHyI9NX7KgQjYS8gjkkbLYp8YgmPABGZxXgvMY1Gk3qJdr1OJGIaU45WuG3s9nhobYkffuVjNDodDva2OyWIpy8ydympVE4ru8YEghDUtbolB4CrVDacdYzJEDFmfcRsciUQFvpoUhwoSkXZZGxFT1ofM9jbZPf2FTaufoNao2X9gps3bnJ68QJxhIW+1rRhMslBPQNrlsIv+6FXc3r1FLduXKfVmU8BXPkGEC/iAAktLnEhAlS2aO8rPREQZwjHgwlUqe8xDZAgqON6FSojRSCYva1iXGvQ6JxC8Nz47Pv55iffxeHOBqPM0z61zuJ8myR2Fgk0H7E412R+YYEsy60WuLNzwKued4nXP/ZSNrb3TFM6S0u+BPH0BS9DmCUJmE1zxYXgpOF4ZReCh0pAeEIkMJ2aNYtKrkHLRKnmknqL/uEuu7e+ybC7w979WwwHQ6Jai6WVlGa7jeQj5psJ2XhALVLrB9TSmrXERnlBu5byE697JQUOdTGZwtad2z2AuHyDnl7eOTGRgeCFBVMtQYDwWpmJCcIcmTGOq0xJ5ciJuiruz/iEcE7lGNVjQkxa8wx7B1z/zHsZl8yj0N3bo1ZvWx9x0O9SKKir02g28eOxNUcisGJofnGe/cM+L31OueVWPpuQSUQsWPVYby1uA8RxaxERuXOydw/ZWDAFQqJSZXiVEQfnWM2FDFGPjqEnaNqs1D1xvcFk2GfjKx8nEc/c2jm6u5u02i0K72x3am3tLHv7u/T6h6bWeZLie2JdoPF4Yv5hNa6XD2b8AJI0phphgkmXV0jml41n1z73ICJy+alj9vFV02NQm1fBcKwuCmEUOz5znfA+QDFvb23tO1/+GOODLZr1JtmwbwXO4uIKS4vLHBx2p3He+gCjQR8FE0Jaa1gVOhqPSNOYi+unWT19xkyiPjdPY/U88eIarta8XAI3fSmK4ksKcBKz1Uh14EQpGU5O5GaZD9cPgAAlTuts3/wmh5u3IanRnzKokKQ1a8zOdTrUGy3u3L5tGV9UNXC8t77iOMutC73QaHB6ZZ202aQ216E2v4yrt4kbTXqD/pdL4KYvD85FXxE4RPXJkxYw8uptLggiMGMkhDkJzAc6uZiqKIoTxsMuh6WzixNrbuLi1MrYKEpsdff3dqilMYNBj6vf/Brjfo92o2Gtu42tbfa7PWL1rC2tsnhqhXqzQ9xeApdYOB3s7dyNiux2Cdy1HrUSAJ/QsEJGGuJ3hWDT8nRJT8jupFLu6phKtdqGIERvAujvbVmrO603EYmII0ttcRIZur0eC0unmD6RsrN3yLhQGrWUw+4hdzZ3GIwmdFod5heWaZZjfW4J4pThaET/oEvvzu2Pl+CX/Zpf3oiBFBh71Q85cW8EB1p594oBOZHR8BHkxDQ5ZDpa9fKQWSuyeUVwdp4yONxHvVV9Np9nGQ47Zk4siRP29w9L2z5LlDbIB3vslUK7cvMujVableUlkqTOXGeepbV1XGOO3W7J+P4ed65f5T0f/OCHAM6fvxS7yn6dRG8CdyzjAwdeTmTOVnTGDHgaVfeVJuGBsPIhHRImoyFZ/8B2lQAEj4VUxXaOQa0nKYIdiyb7jHqHXL65gUtqXDizTE09q0vLzLXmSNK6pcLj/oArX/sy/+hf/3P+5Xs+/KYSPHjpIo6wUJ8GPgZKpa5UjUyvx1dLMcFUQlAfVBobjxfX1bFAwuycgPUE81Gf8aCLczGCgvckzoV9xyhGnNCqJ9y99hV6h/v4uEWt3qKdCndv3aW1/hzqy+eJ4hRVbKPWT0a86X0f4MM3tt8JfANgfmEed8wbo/8FCU1yAHGgwd5nOkaOEMWqFlr1BVA/hVBJRUNFeaITFefIxkN8kZm2SAmOGHfO2ZaYAv3hmM3NDXIVOivnWb/4S2w1712/wUvf+Mv4Q//4v1F/zmN88/Z91k6f5tyFC+AcN+5vEsN/LsEUkc+PPyXmnPuXwJ9WdFlwqAAa7NuYcWDTAmIvhGwwmEmYOSKR0Be0eZltnQFgJiDeIwr9wYB6EpOIVDtN9n44HDIYjtntZZx9cIVTi8scbt3h4Zc8wa/5fX+CMx3h4OFnMTq1yse+doW9jdsUmjGeZNcd/BuMsPL42Oaoqh4i8ncF/iwyE8gx5kPaKorNclJlp4HJSnCi6LFGRzARREIv4qjMrdVT8sLaWmTiLBL43JOkiT0/uNvqMNjpMpjkrBw9SPXEG36K5bU1Pvf5r7F+7izrD1/gVb/xN/Ghr36Gh1ZWESd/58LaWsERJZGv1jNA4O8CW7NOLVRrWmnGib5O4eRuuTLrR4L6e49X6zSTZxNAQaBZb1guUAiW3AzHY8ajsaW584uLLJ1atWcMszwrPy+wt3ufbrfHs8unVIeTgv/5X/4fnyqZB7iytXnt7tb23y9BBc1yol/45b+2BkzC/TKOItcFfqJS/bDpOdPGtjG8r6aF6hyCiYhCEBzgZ/INtbDX37lH/2CLKI6JbMcZ6+1HLiIu4UogwlyzycrSIt3egFqaWnF07/LX8BIx9Ckf+h//gf6tq8wlNeYbdZwWv7fVqH++BBVe8ryHazEnUF74f+yc/DJUX+ecC6qNhkUPM8HaQ8wH1GaDFmgo+yVECgl5Bhb77RiW8tp1PQAW+6PU2eYsOHOKS80Gm+0OG9v7POvSOvPtJoefeief+9yHObs4z7Ne8Hx+/A2v4Pqde/8X+A/M0Nevfp2YE8l+8Ld5X3xNlUgksEqlzlKxbgOeqiwGL4o7snXz5tV37CwHyswGiRKeQMttRR0RKMRJdOQ81fr8TsRMyB6mUnCiXL91j3NrizSSlNNzDdbWz7CwchZXa7K9udmN0d/BCZQ2GjgFTsJoMrmc58VvOsnQK2HM1gtU+4wKQnB0oeKr5gDzAxpQOU/vSaKYKI6O/aYguDhCjh7UsOboJLOHrZvtFrfvbdBJhFqzBbUW4wLbCkP119Tj6F4JZqHe43gK8vBvVfWvVvwx4/FVA6r0uXKSNnoF5TgpFcMcP6imAQJEkeDEnKPt/Fr8L8fga5zVBNUeZafTZn9zk0acUGu1iZMakiQU6J+O4uj/luAkxHH89P8xMvH+j9eS5Kwqv1pEqjB24i5RiAzHQ2I1ISewjSgOgaowUo8TkCjC420OcSBYtSeVbmmBzXmlEQmpU+rWD2haHaDIPxb4izwF2cOYPC2ZKv0aVf6roif0CwwVBQcXqrygGepnCynUG+N4DVGluqazKCDVauFcVPkK8wfY9zxJPmR9YY601cLFaYnknzvvf2cJngoRghMRngkmef7LUf61BuZP7AdIcG7hvEoIzOYCIbcI1zHVr37XmMUYNY+HitomxyQvmGQ54+GQJBsyP9cirbeI0vrfG44Gv7UET4coiXDeK88Uw/HkN6L6J/XEzY4wFzx8hZA2e8IcBC2yI96bans1j28qmqaJMT6eMjyeUJSoO8dCa56V5XWiPCf2Oe3OImlS/735cPD7SvBMUKiGp8WfKY0m+V+u15KPKrxVoDGb9oZ8H2RG3UGCeaAYUYVJZ9vbToSF+Y7tACHC5vYuvf0DFmspC/UardYcjUabtBy9i9j6xueZa7X2643WD03Gg0/yzMkEHPNt0Gicvb9RSxYQ+ffAL3oUCdoe1DrMgShCiTB9fDcJy/jsMfkr92+zfdDnytXrNFV5zYuez2qZ27drNfPwqBIp3PzGlxke7v7L06fXf+vB/q7nWyRN5r79/xkalIkC8MvmWo1XeNV/JiLPOXYtH57pAQ2rHk6Z9Qq02nNcvrHBm/77f2WU5/QGI370sZeyNt8G1EKiOa8Iege7n7t98/JvjqLkM1tb23w7FJ1phWeFv10qb/LDwHPbzfqPAn8BeElY1WN+orL1UEYHgdlzhINBn1f+8E9x4YGH2Lp3i2985UtE2dCKoE7TI+Y48485V//T9TR9zy994rV8J/TxW9eJle8OdQejtwJvbTdqj4L+doSfQlkJ5nC8onTHngkQGyajEfVWixe/8g1okfHS12zxlQ++m/39zY21paX/pVr842w4+EIJvhvkPcSgfDepNxx9EpiCdj19LV5/WJx7sSovBD0DemynuHoVAZyzpzcno+Ft56IvrF544DOjFz3yVuAjm3z3qdj9IrH3yveKDgfj9wFTGC3ONS6qFg/mWb4uygJoLYqEotCR4PeSJNnIi+KKh1veF2zduUVj8RTfKxKREAa/H7TfG98ASlQkkB2NRDDxgPD9oiiC/w/dwAEEaRFnaQAAAABJRU5ErkJggg==",
    "16809": "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",
    "16810": "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",
    "16812": "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",
    "16813": "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",
    "16821": "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAACcFBMVEX////////////////w8PD09PT////////////////////////////////u7u7y8vL////////////////////////////9/f3////////9/f3+/v7y8vL19fX////////r6+vv7+/u7u77+/vs7Oz6+vrv7+/z8/P////////p6enn5+f4+Pjk5OT09PTx8fH////////////////t7e3w8PDp6en39/f////////////////////5+fn29vb////////////q6url5eX////r6+vg4ODm5ub8/Pz////z8/Po6Oj////////r6+vh4eH////////f39/i4uL////////////////////////////j4+P////////////////////////////////v7+/////Pz8/V1dXa2trZ2dnY2NjOzs7y8vL6+vr////e3t7////////////d3d3U1NT////////////Q0NDb29vX19fc3Nz////////////////////////////////////////////////////////////////////////////////////////6+vr////////T09PT09P////Pz8/6+vr+/v7x8fH////////+/v7s7Oz39/f////z8/P////////////////////////////////////////////Pz8/////////+/v77+/v////////////7+/v////5+fn9/f38/Pz8/Pz+/v78/Pz6+vr9/f39/f3////////////////////////////////////////////////+/v7l5eX7+/viNDEpAAAA0HRSTlMNAAYUHBwTKWmdxNvs+P3999rCmmUkPZjf//////+UOAZw////////A3Hz///////vZ0fq/////+GlmSbm///dHUv//z9c////UFr/TUb//zoj///rFs3Bh3k7/y/AslZJx7mqnRr////////tDmb/WAqo//+cC+D/////0wJuX41+o66is7GmlYZ6ayoc8eUHu64Jf/9yMybHunBiDuvfA31wD94EaFu+/PIZXk6JpJepm5+SeGz27zWdAtbPMknOQjXnli5At+O1gx9BWmpxjaY1TwAAB/RJREFUeAGU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",
    "16864": "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",
    "16871": "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAdXElEQVR4AbyXA7Q0SxKEv8jqnrmLp7Vt27Zt2zxa2zaP17ZtHu3RWs+27nRV5u6pqr797PfHxbQ7ERFZo2OOPGE34Bh2ISzZimD3ILYCiIgTegwbdiHc2W0wifMThbi20J1MupnENU12SY/Yy8MvHDAGQU3c4ziZHW7SgcBfgvijR/wU+AfnEwTo2KNOPM8ZIOn2wGM9/J4RXCkIcAgCCUxWPz0CDxBgJooHEYFJS4TBPzzi+5I+BfyO8xKy3XT44cefJwVIxMrMnpNSemFEXCmiJePuBC35CPpfkEw1aQI8HGQI8OhXh5DUt0ESEn8H3gP6OFDOdcxJu+mwQ4491wUYB3sx8Hrgwi1Q1UTCHehJ4xQHJNpPIEVLUsK9J2ogqPsws0EEHQFIRyJeCnyMc4Eh2W7DajDOKTzinjJ9Mjwu7jOXmSltVBYQgBDGkFgYIbVPDwxAVISLIOZMe769irSdUnzPlPRRSS+fcn4c8Mtz1rgVAxLnDPFp0GNECziXAiZGs5o8gmSJEoWImLPY0T4OUitAjrZj/RozESHm26In700pmEHO9blXyLn8wmQfB57J2UQZg6F4ObsGd41k9rMIXTrVQFvAq3EgF8c9aPkLmRgYCHc8YmkigAJO3lggFu8jcF+8YC6CoiXv7pTiTBsnJX/Gemu42ziMdwL24SximjJDIM4qvJT7jsPwLZORvQUhqRVgldBU2J4yKgWrTOj6DbDmOgCLOUagNJsdmEQgSn32fA39WfTngaSu4URWIWfHJl1lHMe9Jd0J+DlnAT45OvCAo86SCa5X9jhCnzQTw5AgYJomEDhACBkt8OhljRa0gADSLI95InTH9+iK73/eut+LtxR5Lt5mk5mmwmo1kKdCnpxhNNJgRECZyoOBr3EmGFfDboNwzgxpsMfkUj5ZSgs8mRjHASS2N5tKyZRS/UNB9Hmes8/3Q0BKhkntWjNa+p0RMX8GptZ1CaAxaSlIkKcM3R9kqn+WDICSC8X9q6X4A4BvcgYY1olhtRo5IxT3e5Tiny4lU0qjbTEjV3p67UApjlktwsn0Gt4+uxJq58wSQ0DWYo4CJEMSuNfuIkhD6ufEIp2oyYZH84LSDXjjrLdG1hdYsX3ixDSVb2QvtwV+w+lgK68YkhmnB3e/qsHXXdqpvtRpHJ23CC+t25JjppOt5ITYTAVJtTsy791kNszKpmTCwymlsJlyTTANpXUYtbHq/V6JcPBculycE6dmiusLjM2EBaX41939usDBnCaCodL2dGCmLxTXlopjGrt+qZ9zZ0wT86qvuFOy4xLej0kAgn4exLTJ1cCGcagJbW9PlUHuVc89SSgbR6KjFTYCvPtClZroBRIh2GxnDKtsHJJf7MScvwjckVOjvkvHHnO63wXeEhEvpSdCNEMq7svSFFpSAoia/PYm9zHFjhcEQAR0Q1xG5wiiO36j82yiqBcYKNEnBn0kEosczEhdPjb0FWUJkEgS23nC3V8OvIWTg9Ww3k3HH7t9qgKIuG0EvwpALC+c86AHyJIMknWP8Pq5mUqdElMutTAKobSMMVVjcwh2tj07ZR5/ArEgl0J0Bs0SDAXWJWmoXlPckSCArXFVmdBH9o2AP7EATLsNo8QpEbI3Vb0RjOsBQTWe6cRcNUqXgCHQsmghGRHN5a2PLllmItPNtiYnIICpur63jkEfdyCM4gW690B0tgVTybgH45DYWq9IZgvL1CZU8Sa3yTLF56LoDcADWECKxHDq5HlEku5oWytIcMC++3PAAQewxx57ctVrXJWxJBBE7hqnoeB41XkQqOq7n63B9nUv7i1gEFIwTW10VQhMjSkqoL7myFPZKRASOWc8fE68FQv1Rng15HBn6gWPOjnS/Q3dG/guHcUc5e1yMgkY8VtMt5IZ7vC+D74DYez9n7152ctewcUveQkO2Gc/Ln35y0IADqRWELrmvTT25O7ypQQnnLDdutEDNIkhGUjVuDZTbjO8GWefNqpmCUEuXq9hR4pxsvFYSmnvrWEEisDV1RpUpgxj+gFwTzpSst2GZGIHEfdnTLc6+uhj+PY3vs5Nb3JL/vnPvfnr3//CBbZWfOWrn+YKV7wq//j733nqE5/JsB5YbW0BoEEQQgFKInmQ5u8Aph5s9xSHTSmU5H1B1QkiuhE60NYVpS6yxDCOmFTX78V9ZyIJcCAXr+Yrel8i6n4u3swWUOEeKdkd+1K5FiW99hWvXhNsCHCLN8rsukcfdTS/+sXPOODgA/nhT3/Ev//1Nzwdy6//+At+84dfcvjRh/DVb3yZX/7qZ2xOyBy0/97/L8yVUBMw9Kqrjy0IAmpApTjFqZ/zXPey0FlSTXjxi2aYRNCaFXiwsGD2o51P0X5qh2dP6GO6Msmn7N+YsjNNef0/qswBSpLk6+K/QGYWWjPduz3TXlt/27Zt27Zt27Zt294e282qSkV8dV7EyfPttJWZEfHefb97x5Jp5F/NjDbcafl/y3z6s5/ml7/9JUeOHKLVSYblPsVgkFPmGWtlzu8P/IO8yEWBP/P5L3C9618dmyXMzZzB4hlnSAXICeQVShwjZFkiD9GrBwT8lgeK/dskRrIgqxF3KePU+2jEnLyhZQoEHYiBCwGjRag1hOvWNMgtcBUQGeAueP9UYM0pUAd27RENmFlaeBTw3k988mM85BEPY2R0kqmpLu2O5eTRPt5beYDR8RYOLzDTHWlRVgXKeAaDda53rWuwuPVcLrjoMh7yqIeyuTGQU1aB7WUcVlUlc70oagGgoixxLip9hEulRTgDPdZhEzQEo+ORa+R5ITgeT7zxBlqIUqzuVSokbCYQNOK+wGcSq0ftPe92jxrg1re71c1uf4c7cmDPHrZNbWfxzHnWi2O0shZjleLIgXVc5RkMCsYnu9LHG6t9vPS0otXusmv/Xv722//xs1/9ghvc8kacPdSLw0eOC/9rfdWYLE0M0b+Evq5p/EMlLSGRVby+p1Y+YrejKEoKmQQeqlDqVhsJYJLUNtowKEqKvIxgFlA+AtYtgM+UZe3U937wZwAecNdb7m63ksWpqdNQxpC2NTUDKl9TiKBUVJVi5VRfdrXdzhgmyqK2WTcjMdDJNBkZKMPTnvUc7nq3e9Dv9+n1+sIHQCRJHx7a6ODuai+bYEwkvdpLlYTURwVKjARaVhVlLOcIoRiryJJE2gYIUBVZIC/K4VtNVUetwQP8A7hEK63Vt7/3J974ymfPeOcODAYDNAaiKcmsoXSl9KlNKjAO70q8KvFpyokTBesbFd56JjqGhWyCzZ7jP8MpcfXrXMFnv/59qhJWV081ZkoWEgUqlHko62JQAEhbZYkRktzczOW0lQ4n388LBnkp49XH68RxKhWVpQkKKOum3IM/CWZNNhVP9CmMAetWG02/17ukdp4YU5KIeCQyR61t00ksvnb0NjZoZ20S6+nnFTPjLfIsZ7VfChXqRNPKNGfNzoGuedmbX8B97/QI5maWWFk5TpZZWq20mQQCLFHkjA2ChfNyatEpYqwWJmi3U0ZHO7i6pjco6A/KZmJ4kGeO4kiiNIQWkIMsS0dVx/Knga2LgN+oH/70b7zsWU94UlGWbw2jwzSxtKi589KrSZpI36O0XMzXtWxYZoPK9kSYNjm92yL1CbtPHmDd5rztTZ/gWte8Ed2OZaSrAFhfL1lZWWNYcVIRWunQEonBBq2Q52ilCbXzIpSAnHCSmHC/Xs5mr6BsPIKSa8SRShltdZ5XRActCxcgMgZt9EOAj9qxbhuMXqQiqqlgI0oFulJGyyaUZY1H3Jc8sEpCDpA70MbS0hajHCpLGJs6nTPHO5xc2eRtr3k1U1Pv5axzzuGss88ajsklFhfP5PTpOdqzk9QVrK4WrK2eZNAvRMSsVnjtcXg54ZZJwhiUnnZEipPWqPOonsGwybhNk0R0g+hhpPxrKf/GVaapXQRQO5cP8cAH3OvjeB6AczQAEz25PIRScSQFskusRStkDMWwQnrNWEtVDmhnSn6e55q8LNncWKfX28T7mrHRLtPbpplfXBp6iwuZnZtnZm6BCy+5pvDBysljpGkmi5VxaDROtAOSJMZjtZd7x9gtHI4PozNNZeLIyE1TS7eTEXs+tF6cMNqodwJPUAcPHOded7vLl5Tzdw39qPH+KtZTjE0tioxYS6XAakHYxqs3ya424Cqqoo9NWqRZFk/M4qrA+/2iz9rqCv3+QB56bDTjwiuuwXNf8gZmts+wa3lZNlMHkmtoEQVZavEIEjcGyflwEFkmLSK/b+VvAyJba2UzsjRjZKxNfNSPAw+y22cm8VWdROQMszUCBfF7QPD7TpIcmQreO/kcrwPDN6SlREB1apAcMQam3jkpW7yjnWZ0t89DROWqKPnOV7/Bwb0HeM9HPsllV5zNlf/dF/BW3F8cic4zGFToZny66AsUqQmuscktxS5b2q0MD3Q6bTrdjP179/HzH/+QfXv3pwD2dS9/Ba52zmst89crgho3Hjw4rEQrEhvKMXpwMTRZlknbDCpHYiyeuAmymTqouYXS1VilMUkSbHNVoqxFRft7+dB4Xfm/f/GQe9+Fd33wo1x6+UUcOHCcIi+wVqN1KsIWKtHhUdH61gBirKyppRKa1Gq8w8z0BDpNAfjAO97JO97xFg4ePEhqWw5AzW7Zyuzi2Z/RcO+Q1JgoNjnddivqgZK2UEaFG1dOyk5bI4IoNy1LFGBTGy2oosajTBBNXPibxCbS6x5xfkFbFBiPiNeeIYmC51VvejN3vccd2bP7OHU5EPBSSslm5EUlKC0pEUSBC4seFJUAUbedSdnPzZ8GwAuf9jRe8eY3Mz81zfZt21CK9wOPsnNzUoonXFWL4NR5Tmu0y9zSEvt37ZLYKbUJyhlqF2hNWy3BhkL6s2H9qq4wjvi9gLKlc6DBRI9WVWXoWyL4x+yr8h5VKeYXFjl+9ChPevTDhy70eTz9WU+hLGpOnVyh22kFXejnZGkUM90QpsTuE1oxMdaRn42Mj7B31z6e8qhH8Mtf/ZKLzzyHhZlp0aX9hw8fB7C1q/CD4kCapcGJZTYI00hXFl5UBbWv5RQtNowX7dFKtCBuQk2apVBrOVU88j2JyAElhsigggSQD/Lo73VjdX1kD69rJia3krVavO4VL+fYkf286nWvZ2xsjLX1Nfl7PAJVWWYwwhBG2qOqakmQev2CrVMTDJ0t97njHTk2tPXnnHsenSxlfnaGfw5J1eEOAGjJbhK1jBLLKSqeD0r+8offk1e5lCwO6bsQeQHu//F5fKJ+r4+r4vRQAWSUWNcmyhbtyFoZM3OzWIGWOmZ/wfRIyh9D0Va7zQUXXsy73/ouXvK854otrysXRLSd0GolYn58IL4mbd6Mi9+9vJuH3ffeHDp8aDhuz0fjWZqfZWV9nfVej06rvTx8w5y1sIA2qcfzeCDGVpVoAdFbaxXHm6JZEDEP9EpJNQR0bSYJNk1xBJVGCcs3HD7S7VIWZUxrG5BBRa/gIFzLwcTEVv71z/9yvRvekLPPXWJzoy/3L6paTro3KCliFN8Z6TA61uWvv/sdD7//PWXxZ593Pr3NHt2RDjZN2HPwQKRd9VzvWVPXu+KKeP9s1Xk3VsdxpRQRU00YY2IjJTaS8SaTAOGAhiAjbEcuADxoG2wqcXGCqUUhJa4TK5Ohrgqcjy7Oh01VHinntJUNtWDXMHS5Ph/79EclY1hfXwdUBDMpT6ZntpMm8N63vJU3ve6VmCRldn5B7pXYVKK31bU1CObpIDALYLadPpM5r2qcv7lWnCnqLbDjyZI0ggZhAfHUxYnFPF/QyfsGjMJGaeFuqZLI36jQNgpHInAUKTK10fY2/50lmxbAW/BNEum//PlPZK0O17/hdTh1aoNS2EBqhfmlbayubPCsJz6Od73tTWw5bZrxLVvFr6AkZRJXWdWBSaqq/oFz/rOTW7e2tfYqHb5R1NUvJD0xWma7MQmlCxbSGCVi40pRDMT8a0J5R6dR+0oWH/g55nviKaCSLN9FIEJ4Q4GcfG9tQ0xLaBWNNmKu5H7eR2tbVQxzCt75trfx61//mW2z09GbKKaHn//yZ7/nfne5Fd/46hc47+JL2Dq5hZgdygTZ2OzhPTIWQVryF7HErW21x4JDO3boG9YmL9HaoBwy/vI8l9MkleYVCEGBzVK0EV5ocmcVyx8ZhyXOK7S8CSzi6hJlE1CWui7RGPHpRuLvAFgyRq2B2jdthgnuc2RkhJO7T/Dm176aD3/6c4yOj5NmLb4+zCSf//THyX0XzjwbhWSRwhSx3RCxs4ay9MI0SWK+AVDWDnXdK64hmWD4hvm11+Y6gzzHKCv2VKoCha8r6SMtOFtjTRINUiWQE71A7HVP6cL3tUeqCohTQcvkUAGgpAoCKERcjkwgOWCoLtlwXLj28o7/8sRnPIvnPv+ZlDXc5w634dc//zkXXnoJeT5AayPPXlYlVVXJeO5k7cbJlmXxfeBWINU1as/r7Kf5l4x/1tjkOt5kcoG8ysV+ehRV0mVts0fZy2WXN52nUlZMjndhWlibACb2XSJTQGmPRspZTl15qRJZqPaOGiOLTQm6UblKTp2yxsUJ5PPYXloNbfQMb3/TG7juDW/MRLfDf/71L84571y5bvp/5ZsDYCRbFoa/clVXM+nOWM+2jbVt27Zt27Zt2zu2J0YjXW5t1Zlee/f5/cM4uXXuOT/u1czDXmAnlilmmxalQv7waB2KolI+9wmGGJ+YRL/XQx4HQ0zu2vi++fn5Z0ehVzUNAxVEm7e9Nk2vgaf4dMwIx3XlKTXqrcPmpW3RAzqdnjSqZiug01PQDRNVN+kpKsgY1Ym7A7p9hQ4qSV8R6auoKn4coasqA1Uj6YAmC6NIpfSTHrI1dRUjV8Z0Al75oudgqANs06TguoRBRN5x6Sl9un1wbUe4Qq/bwdQ1+oe32f5O0v0gQxy1aiXKZz7+ub+Kxh7/6Ec8Nwi8F2XSkcxOij3uf9+788CHPITJQ/sY9BPK5TK10RE6YVvKMgz8VF3tI4lDCq6NoRl4jYYIo0a9zuTkIfH6O0kiM9v3feJOD1UTMYQfBLSaTVp9l4Fqk+ssoNl5BopGmPSQyaJlZa3IAvZNh/n5RZZXyyxZsoS255N3csTZT5417EH6R9jqMER1ckMGmjwReANDjFbsgv7kRzyMv8Sdb3flm2wn/9iW79Uy4+NLX/wGQc/lpAuuoHhgltFalW98/eu85UOfYJ2EIBqVUpFb3Pp+jFbH0gxxH5vW/45c7SgZO7UjK5yRMrAo8FDISjGhm8QMOjFJ7NNL/+0nAcqgz2827SKOQi5N5XCSJCwszMuoCwNPCE5WwvVmgx/8dD16ZLKiOkq9tSjcvh1FBEmHomOTxJFMLnpd8RHn5iN8P9yXdJO38BeYXlDRzzjnHP4Sh6bbrUc9+KbP0wzt7dVahag1h2MqeK2AsN3AXjLKb3/xEz7yiQ8wRCoyjuT2t7kpIyWHH+7ewQPTUCRn5Ak6Ho984EN53ZvfyuTUlMx4FFi2fCXf/e53eP/7P0KlMsrSZUt43vNfSDLyHRl3MzNz/OrnP+Oii+/ISKXCshUr2Lj+d+m4+z5hOGDVSZeRmx7nV7/7LVHSw7YswiSWLVe3TQlr4iBmpJxnPgzx/Dh7GM8FuvwFgriDfovb3oK/xd7Z4B1jRfVu6Z67PAgjlucL9ERsdORPRpAyFIqjtBfrHH30MTKSUmNjaDrm6Kb/ZigXiyJnI7/9J0s8bNcJ0o9rLsyzMDcrCxumCx0HbVxzOT/41jf41ve+x93vdjfC0KdcdPnZD77Dy1//WjI8/YlP5pJb3Bq/3ycKfEmp0ubNxNQMu/bs58STjuXYs1dRzEs/Ynx89kvAR/kb7Ni1D311+jT+EcZq1sNsg+2qgiYmhtBBZCGiJEHFQGQyGoVCfni0pS+nQgwhVML5hIOnq/8nGpz+Eh2Qba+xkbJMidUrlxNGoYythWaDc884gam9G3jFS17AXe5+91Qir0CjRy37elYOb7HFYqPBbW93Z/L5HNMpv/fCmO99+zv8fssm1q09kpvf9FI6Scy2rXvaB3YfeAR/D+kberPt8Y+Qvn73b77/9Qdt3773g2ddcisgayiG/IB92VsFXNcljgJhjghxighDT0wRFA1TF0vqT/5ir98RAua6OQ6OT/CTX/6aYiFPpzdI/y3QHfr4htqn6FrsmWuy2GwQB570BNux0XMOjeYCfuBzTHWMSqVCtVolihO2rN9IhmKxkJqt65iamuWo45z7HHXcSVP8A7zypa9Azz7wnyBtfFd+6H0f+sSJ6Sd8Wkog6GeukPj6Ia12QL6yBE1zQDMgi7LiUORy0oWBlllsKqblCiVNOlE254dRdVaymcWl0kVHMywk8EwShgcd8byA293+7oxWqzQbDSSfMORYjLjM9fq8VFUQBqIiq6NVRmqjWCCjMcksOst5dsVyvsQ/we6J/ejHHrmSf4WvfvvrT9+2fc+KtHzvnX1jzcUWFSfhZmevZaQ6xsxUj7Lhi+1tuRVspceVp60lXynKmOwHk/LNiivc6wID6k2PghZxs7NWkMsXqY5qHNi3G0WzJDGOwzYFq8vM9p9gJMdi2Q5BGAl1TgmO9KG52Sna7cU/OdaGH3LFlTdN+9E6nFyB2bnGO4CX8S/wnKc8BX12ej//DqNl7T4g93vuNjs7kxqYp3HumSdj2jkiSV8SqQozF6ZCZSWPevwTsihLSEgQdzMLXAhSRypIxfc8sb7u/cCHky8U8INQtH2SRLQXm6w68mRuU1uBt7jIQDXQlYzFqSKTkYRHE7N0+44tnHTSafK2QwfrVMeWcOIpZzI3M/0e4JH8G9z9vg9G2fT7rf/xjRGvPf/+Yqn8gLVHHj889qdimBmFBX/RIwzalEYrWI4txGN40Iv5qXE8b1HKX9Dvki+NYNou3U5HSn5uepLPfuZzLFk6xnHHHUunK9Ec7WaDzet/y29+8xs2bdxMqTrCaK1CEiacc/6FnHDiKZQKBVqtZspB9rB23dFvBh7Hf4Bd+/YUMgvwP4ZVqT5wcmZyx29//auXZ85s4Pt/MkaSyKfZbBLHfTEyojgiihLRFGEYEIfZyyEo4HkhfZGnpjS3pdUKURKwd3JKkmGDPl6rSytosebYGhPjCyxMBJQLDu4yjWYyy6E9bZYuPShUXdSeOkgd5J2PTf+8hf8Mkmsop5146n99Z2j9lg2XAl93jPRZ21mj06QKgjgLLSXZHXp9GoYYKuIXZFNBOIQXdaShqYDj6pTzOcn/NFfDC3zyVh69b6DafSprLQaJQns28xQhv1JSaBb2JXT9PkXHJRiEzSNXr7kZ8Gv+C1RKYwUF+J8uTdXKVfPEU5d/BJW7Bq0EW/a81DyKocust0wb3RhQ1Ew6ykAqw0CRhVBzBlrGG9QOg4w8xRrBwKOrJiTRgHwuT48uSbPJksoYcRfGZ+aIlIRKxUWJddqNCNPW39fqhQ8F+vyXmJvoFJRzzjvx/7o1dvTRlQvVSH+3142OV3t9RvIlOkYPM4urFJUltRojxSIdJaHtBVTMvGwFBn1pgBMLs9TrLdalAelMa4Gp+XlsyxB6G0ddmlMNHM2lp8NkY14OUI+NFMHU1jfrwYOB3/E/YtdMs6A85hG3vGouTg4Gt1xarry04OZP90OfkuuKlHUdF8/3WMg8/YzwuDkk4kr/6IqOzH0k+sa1cvSQg9NkvKNUKmWER+gsWpb5J8w1Wr+wVO3ZwPf4P3HwUD1dgPvd9Cq9Obpy1dKzgyh8ePrD3A5Vq7XaPlESEgaZ+usKSSkW8/SHkXvmAbiuje970tAcyyGM+sQZ8QIZjelWmo6i4PNLl4+9A9jIVYQdO3cUlEfe8xZX2+XpZNC7LIq7Nzds87TUOT5l0O8tl7h8MBBpazuGBK4oGkEcYhkqpXw+mxLjzWZ7o2KZvzMt4+vAz7gaECStgvLoB9zhGrs93mg01zi53BGapi2zbafsB4GVhD6DQSfSTL2xdvXKabdg7QEOcQ3AD9It8KB73FYWgBsh3FJS+ANvfAXjDoNjwQAAAABJRU5ErkJggg==",
    "16873": "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",
    "16875": "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",
    "16918": "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",
    "16997": "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"
  };

  // lib/anim/CircleSpriteB64Textured.js
  var CircleSprite = class {
    constructor(parent, i, userdata, normalTexture, hoverTexture) {
      this.i = i;
      this.enabled = true;
      this.enabledSize = 0.1;
      this.normalTexture = normalTexture;
      this.hoverTexture = hoverTexture;
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.o = 0;
      this.r = 0;
      this.tx = 0;
      this.ty = 0;
      this.tz = 0;
      this.to = 0;
      this.tr = 0;
      this.material = new SpriteMaterial({
        map: normalTexture,
        transparent: true,
        depthTest: false,
        depthWrite: false,
        color: 16777215
      });
      this.makeTexture(userdata.id);
      this.el = new Sprite(this.material);
      this.el.userData.i = this.i;
      this.el.userData.data = userdata;
      parent.add(this.el);
      setTimeout(() => {
        this.to = 1;
        this.setTarget({x: this.tx, y: this.ty, z: this.tz, o: this.to, r: this.tr});
      }, 500);
    }
    makeTexture(id) {
      const b64s = CIRCLEIMAGESB64[id];
      const canvas = document.createElement("canvas");
      const size = 64;
      canvas.width = size;
      canvas.height = size;
      const c = canvas.getContext("2d");
      const image = new Image();
      image.onload = (res) => {
        c.drawImage(image, 0, 0);
        const texture = new Texture(canvas);
        texture.needsUpdate = true;
        this.material.map = texture;
      };
      image.src = "data:image/png;base64," + CIRCLEIMAGESB64[id];
    }
    setTarget(obj) {
      const {x = this.x, y = this.y, z = this.z, o, r} = obj;
      this.tx = x;
      this.ty = y;
      this.tz = z;
      this.to = o ? o : this.enabled ? 1 : 0;
      this.tr = r ? r : this.enabled ? this.enabledSize : 0;
    }
    normal() {
      this.enabled = true;
      this.material.color.set("#fff");
      this.setTarget({x: this.x, y: this.y, z: this.z, o: 1, r: this.enabledSize});
      this.material.map = this.normalTexture;
    }
    hide() {
      this.enabled = false;
      this.material.color.set("#fff");
      this.setTarget({x: this.x, y: this.y, z: this.z, o: 0, r: 0});
      this.material.map = this.normalTexture;
    }
    focus() {
      this.enabled = true;
      this.setTarget({x: 0, y: 0, z: 0, o: 1, r: 3});
      this.material.map = this.normalTexture;
    }
    hover() {
      this.material.map = this.hoverTexture;
      this.tr = this.enabledSize * 1.5;
      this.tz = -0.05;
    }
    unhover() {
      this.material.map = this.normalTexture;
      this.tr = this.enabledSize;
      this.tz = 0;
    }
    setEnabled(bool) {
      this.enabled = bool;
      if (this.enabled) {
        this.normal();
      } else {
        this.hide();
      }
    }
    update() {
      this.x = this.tx - (this.tx - this.x) * 0.9;
      this.y = this.ty - (this.ty - this.y) * 0.9;
      this.z = this.tz - (this.tz - this.z) * 0.9;
      this.o = this.to - (this.to - this.o) * 0.9;
      this.r = this.tr - (this.tr - this.r) * 0.9;
      if (window.app.mode === "free") {
        const v = 0.1 + Math.abs(Math.min(this.x, this.y));
        this.r = Math.sin(v * 0.1);
      }
      this.el.scale.set(this.r, this.r, 1);
      this.el.position.set(this.x, this.y, this.z);
      this.material.opacity = this.o;
    }
  };

  // app/data/students.js
  var DATA_STUDENTS = [
    {
      id: "16777",
      studio: "2A",
      name: "Alexander Fagerholt",
      theme: "3",
      title: "In between typologies // The future challenges at Refshale\xF8en",
      email: "4003465@stud.aarch.dk",
      mobile: "+4541296962",
      stub: "alexander-fagerholt"
    },
    {
      id: "16789",
      studio: "3",
      name: "Charlotte Lyberth Jensen",
      theme: "1",
      title: "FRA V\xC6RESTED TIL M\xD8DESTED - a new frontier for socially vulnerable in Aarhus",
      email: "charlottelyberth@hotmail.com",
      mobile: "+4560583664",
      stub: "charlotte-lyberth-jensen"
    },
    {
      id: "16790",
      studio: "1A",
      name: "Christine Steffensen",
      theme: "5",
      title: "Det stille LANDSKAB - Jammerbugten",
      email: "christinebergsteffensen@outlook.com",
      mobile: "+4528431201",
      stub: "christine-steffensen"
    },
    {
      id: "16875",
      studio: "2C",
      name: "Clara Lange",
      theme: "3",
      title: "Nyholm i forandring- Tradition, kultur og uddannelse",
      email: "clara@holm-lange.dk",
      mobile: "+4528933986",
      stub: "clara-lange"
    },
    {
      id: "16810",
      studio: "2C",
      name: "Daniel Nielsen",
      theme: "1",
      title: "Shared Forest Allotment",
      email: "dandollerup@hotmail.com",
      mobile: "+4550414245",
      stub: "daniel-nielsen"
    },
    {
      id: "16768",
      studio: "1A",
      name: "Eleanor Margot Gibson",
      theme: "5",
      title: "Reimagining the Company Town:  A Model for Future Landscapes of Coexistence",
      email: "egibson@live.com.au",
      mobile: "+4531270480",
      stub: "eleanor-margot-gibson"
    },
    {
      id: "16723",
      studio: "2B",
      name: "Elias Hamann",
      theme: "7",
      title: "RSDO-1-29 ENVISIONING THE RECONSTRUCTION OF SPACE DEBRIS IN ORBIT TO A SPACE HABITAT",
      email: "eliasjohanhamann@gmail.com",
      mobile: "+4522270143",
      stub: "elias-hamann"
    },
    {
      id: "16764",
      studio: "2C",
      name: "Helena Feld",
      theme: "1",
      title: "Veteranernes Hjem - naturens heling af krigens s\xE5r",
      email: "helenafeld@hotmail.com",
      mobile: "+4522905638",
      stub: "helena-feld"
    },
    {
      id: "16801",
      studio: "1A",
      name: "Huiru Huang",
      theme: "5",
      title: "Architecturalize Greenland, Re-Envisioning Marmorilik Mining Landscape",
      email: "vianahuiruhuang@gmail.com",
      mobile: "+4550320293",
      stub: "huiru-huang"
    },
    {
      id: "16791",
      studio: "1C",
      name: "Jacob Mikkelsen",
      theme: "3",
      title: "Ankomsten til Aarhus fra \xD8st - Omdannelse af silokompleks til terminal for skibsturisme",
      email: "jacobhaugaardmikkelsen@gmail.com",
      mobile: "+4525533006",
      stub: "jacob-mikkelsen"
    },
    {
      id: "16772",
      studio: "2B",
      name: "Jens Toft Madsen",
      theme: "2",
      title: "New arrivals -  Establishing a connection between sea & city",
      email: "Jensmadsen1@yahoo.dk",
      mobile: "+4541406830",
      stub: "jens-toft-madsen"
    },
    {
      id: "16804",
      studio: "2B",
      name: "Jesper Asferg Scheel",
      theme: "2",
      title: "\u2018ROUND AND ROUND WE GO\u2019 - The velodrome imagined as an homage to the legacy, sounds and emotions of cycling",
      email: "jesper.scheel@gmail.com",
      mobile: "+4530290401",
      stub: "jesper-asferg-scheel"
    },
    {
      id: "16802",
      studio: "2B",
      name: "J\xF8rgen Steen Holst",
      theme: "4",
      title: "Disappearing Snow - The Norwegian Ski Culture in a Changing Climate",
      email: "jorgen.sh@gmail.com",
      mobile: "+4790063843",
      stub: "jorgen-steen-holst"
    },
    {
      id: "16873",
      studio: "2A",
      name: "Julie Holk",
      theme: "1",
      title: "Interaktion til Motivation - Et ressourcest\xE6rkt f\xE6llesskab",
      email: "julieholk@live.dk",
      mobile: "+4540820961",
      stub: "julie-holk"
    },
    {
      id: "16800",
      studio: "3",
      name: "Karl Henrik Kobbeltvedt",
      theme: "1",
      title: "Knubben- The rehabilitation of an old essential",
      email: "4004118@stud.aarch.dk",
      mobile: "+4560166904",
      stub: "karl-henrik-kobbeltvedt"
    },
    {
      id: "16786",
      studio: "1C",
      name: "Kathrine Grundahl Hansen",
      theme: "2",
      title: "ET MARITIMT CENTER - En transformation af siloerne ved Lilleb\xE6lt",
      email: "kathrineghansen@icloud.com",
      mobile: "+4560628667",
      stub: "kathrine-grundahl-hansen"
    },
    {
      id: "16781",
      studio: "2C",
      name: "Khadar Yusuf Awil",
      theme: "2",
      title: "Livet mellem reolerne: et lokalbibliotek i Aalborg Vestby",
      email: "khadaryawil@gmail.com",
      mobile: "+4531160731",
      stub: "khadar-yusuf-awil"
    },
    {
      id: "16773",
      studio: "2B",
      name: "Kristoffer Holmgaard Gade",
      theme: "7",
      title: "AN UNWELCOME GUEST - A PARASITIC HABITAT FOR A NUCLEAR REACTOR",
      email: "kristoffergade@hotmail.com",
      mobile: "+4551364317",
      stub: "kristoffer-holmgaard-gade"
    },
    {
      id: "16758",
      studio: "1B",
      name: "Lisa Sippli",
      theme: "5",
      title: "ZECHE GNEISENAU",
      email: "lisa.sippli@gmail.com",
      mobile: "+4553806080",
      stub: "lisa-sippli"
    },
    {
      id: "16787",
      studio: "2A",
      name: "Lucas Edwards",
      theme: "2",
      title: "Song to Song",
      email: "lucas.e@protonmail.com",
      mobile: "+4553624123",
      stub: "lucas-edwards"
    },
    {
      id: "16779",
      studio: "3",
      name: "Malene J\xF8rs Nielsen",
      theme: "4",
      title: "Night Tide",
      email: "malenejorsnielsen@gmail.com",
      mobile: "+4528910408",
      stub: "malene-jors-nielsen"
    },
    {
      id: "16760",
      studio: "3",
      name: "Marlene Hindsted",
      theme: "4",
      title: "A Production To the Seabed",
      email: "4003711@stud.aarch.dk",
      mobile: "+4526118224",
      stub: "marlene-hindsted"
    },
    {
      id: "16784",
      studio: "2A",
      name: "Mathilde Ballegaard Lehrmann",
      theme: "1",
      title: "In between life & death: Spaces of Transition",
      email: "mathilde.b.lehrmann@gmail.com",
      mobile: "+4528555112",
      stub: "mathilde-ballegaard-lehrmann"
    },
    {
      id: "16864",
      studio: "3",
      name: "Michelle Skov Justesen",
      theme: "3",
      title: "Rebirth and transformation of Randers harbour",
      email: "michelle_justesen@hotmail.com",
      mobile: "+4520696502",
      stub: "michelle-skov-justesen"
    },
    {
      id: "16808",
      studio: "2A",
      name: "Michelle Rosenvinge",
      theme: "1",
      title: "Perception in the absence of vision  \xB7  Rehabilitation for the visually impaired",
      email: "m.rosenvinge@icloud.com",
      mobile: "+4529277008",
      stub: "michelle-rosenvinge"
    },
    {
      id: "16766",
      studio: "2C",
      name: "Morten Aggerholm Andersen",
      theme: "1",
      title: "EN MENINGSGIVENDE FUSIONERING AF TO KOMMUNALE INSTITUTIONER",
      email: "morten_aggerholm@hotmail.com",
      mobile: "+4524433931",
      stub: "morten-aggerholm-andersen"
    },
    {
      id: "16769",
      studio: "1C",
      name: "Nora Dyrvik",
      theme: "2",
      title: "Fra musem til mat- og musikkhus. En radikal transformasjon av Munchmuseet",
      email: "norarsund@hotmail.com",
      mobile: "+4791822829",
      stub: "nora-dyrvik"
    },
    {
      id: "16782",
      studio: "1C",
      name: "Patrick Bunke",
      theme: "3",
      title: "Immervad - Et Klimatorium i \xC5dalen",
      email: "4003780@stud.aarch.dk",
      mobile: "+4522464872",
      stub: "patrick-bunke"
    },
    {
      id: "16754",
      studio: "2A",
      name: "Rosa Prichard",
      theme: "5",
      title: "Decentering the Visitor, A Critical Reframing of Bornholm's Extracted Landscapes",
      email: "rosaprich@gmail.com",
      mobile: "+4550188279",
      stub: "rosa-prichard"
    },
    {
      id: "16780",
      studio: "2C",
      name: "Sarah Ghobadi",
      theme: "1",
      title: "Den N\xE6re Arbejdsplads: Et Bokoncept til Fremme af Hjemmearbejde & Lokalmilj\xF8",
      email: "Sarahghobadi@hotmail.com",
      mobile: "+4560527247",
      stub: "sarah-ghobadi"
    },
    {
      id: "16728",
      studio: "1A",
      name: "Sebastian Yeoman",
      theme: "3",
      title: "En Bydel Forankret i Historien",
      email: "Yeoman_66@hotmail.com",
      mobile: "+4553633954",
      stub: "sebastian-yeoman"
    },
    {
      id: "16809",
      studio: "1C",
      name: "Silja Nordv\xE5g",
      theme: "2",
      title: "Alfheim satellittuniversitet - En radikal transformasjon av en senmodernistisk sv\xF8mmehall",
      email: "siljanordvag@gmail.com",
      mobile: "+4793214265",
      stub: "silja-nordvag"
    },
    {
      id: "16788",
      studio: "2C",
      name: "Simon Smedsmo",
      theme: "2",
      title: "Sport og naturfaciliteter i s\xF8omr\xE5de i Holstebro",
      email: "simonsmedsmo@hotmail.com",
      mobile: "+4530661262",
      stub: "simon-smedsmo"
    },
    {
      id: "16778",
      studio: "1C",
      name: "Simon Rode Gregersen",
      theme: "2",
      title: "Krigens lag - transformation af Field Station Berlin",
      email: "simonrodegregersen@gmail.com",
      mobile: "+4526374616",
      stub: "simon-rode-gregersen"
    },
    {
      id: "16765",
      studio: "1A",
      name: "Simone Stell\xF4 Stels\xF8 Lauridsen",
      theme: "5",
      title: "LAND & VAND - landskabet p\xE5 MOLS",
      email: "simone.stelsoe@gmail.com",
      mobile: "+4560110460",
      stub: "simone-stello-stelso-lauridsen"
    },
    {
      id: "16813",
      studio: "1B",
      name: "Solveig Paulsen",
      theme: "6",
      title: "Deichmanske Bibliotek",
      email: "solveig.paulsen@hotmail.com",
      mobile: "+4527630027",
      stub: "solveig-paulsen"
    },
    {
      id: "16737",
      studio: "3",
      name: "Stine Skovbjerg",
      theme: "1",
      title: "The New Old Way - A School for Self-sustainable Farming",
      email: "stineskovbjerg92@hotmail.com",
      mobile: "+4561318779",
      stub: "stine-skovbjerg"
    },
    {
      id: "16762",
      studio: "2C",
      name: "Tanja Haugstrup Hansen",
      theme: "1",
      title: "3 generationer under samme tag - p\xE5 kanten af by og land",
      email: "haugstrup24@gmail.com",
      mobile: "+4560678768",
      stub: "tanja-haugstrup-hansen"
    },
    {
      id: "16785",
      studio: "2C",
      name: "Tanja Tofte Thomsen",
      theme: "2",
      title: "Et naturvandrerhjem p\xE5 R\xF8sn\xE6s",
      email: "tanja-tt@hotmail.com",
      mobile: "+4525332117",
      stub: "tanja-tofte-thomsen"
    },
    {
      id: "16783",
      studio: "1C",
      name: "Thomas Maagaard",
      theme: "3",
      title: "Immervad - Et Klimatorium i \xC5dalen",
      email: "thomasmaagaard@hotmail.com",
      mobile: "+4528432906",
      stub: "thomas-maagaard"
    },
    {
      id: "16997",
      studio: "1A",
      name: "Thorbj\xF8rn Klitgaard",
      theme: "3",
      title: "Kystsikring og byudvikling i Kerteminde",
      email: "f.t.c.klitgaard@gmail.com",
      mobile: "+4542309760",
      stub: "thorbjorn-klitgaard"
    },
    {
      id: "16793",
      studio: "2C",
      name: "Thorlak Solberg",
      theme: "1",
      title: "T\xE6ttere p\xE5 naturen: H\xF8jskolen som m\xF8dested og mulighedsrum",
      email: "thorlakk@gmail.com",
      mobile: "+4551512563",
      stub: "thorlak-solberg"
    },
    {
      id: "16918",
      studio: "1C",
      name: "Tonje Madsen",
      theme: "2",
      title: "'Arkopolis-h\xF8yden' - En radikal transformasjon av et kulturelt landemerke i Stavanger",
      email: "tonjemadsenb@gmail.com",
      mobile: "+4527606545",
      stub: "tonje-madsen"
    },
    {
      id: "16812",
      studio: "1B",
      name: "Tora Walseng",
      theme: "6",
      title: "Deichmanske Bibliotek",
      email: "torawalseng@gmail.com",
      mobile: "+4745868872",
      stub: "tora-walseng"
    },
    {
      id: "16871",
      studio: "1B",
      name: "Vibeke Vildbrad Kristiansen",
      theme: "6",
      title: "Restaurering af Klingeb\xE6kg\xE5rd",
      email: "vibekevildbrad@hotmail.com",
      mobile: "+4522818216",
      stub: "vibeke-vildbrad-kristiansen"
    }
  ];

  // app/data.js
  function compare(a, b) {
    if (a.name < b.name) {
      return -1;
    }
    if (a.name > b.name) {
      return 1;
    }
    return 0;
  }
  DATA_STUDENTS.sort(compare);

  // app/fallback.js
  var checkWebGL = () => {
    const c = document.createElement("canvas");
    const gl = c.getContext("webgl") || c.getContext("experimental-webgl");
    return gl && gl instanceof WebGLRenderingContext;
  };

  // index.banner.js
  /*! 
  
   *******************************************************************************
   * Hi!                                                                         *
   * Drop js@dearstudio.dk an email if you want access to the un-minified source *
   * (CC BY-NC-SA 4.0)                                                           *
   *******************************************************************************
   
  */
  var balls = [];
  var numballs = DATA_STUDENTS.length || 20;
  var camera;
  var renderer2;
  var scene;
  var clock;
  var group;
  var eraser;
  var targetQuat;
  var originQuat;
  var timeout = null;
  var speeds = [
    0.1 + Math.random() * 0.4,
    0.1 + Math.random() * 0.4,
    0.1 + Math.random() * 0.4
  ];
  var TITLEB64 = "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";
  var main = (selector) => {
    document.querySelector("#title").style.backgroundImage = `url(data:image/png;base64,${TITLEB64})`;
    if (checkWebGL()) {
      initAnimation(selector);
    } else {
      document.querySelector("#fallback").style.display = "block";
    }
  };
  var initAnimation = (selector) => {
    es6_tween2.autoPlay(true);
    init_scene(selector);
    init_balls();
    update();
    timeout = setInterval(() => {
      randomize();
    }, 14e3);
    randomize();
  };
  var init_scene = (selector) => {
    window.app = {mode: "free"};
    window.addEventListener("resize", OnWindowResize, false);
    document.querySelector(selector).addEventListener("click", randomize);
    document.querySelector(selector).addEventListener("touchend", randomize);
    clock = new Clock();
    renderer2 = new WebGLRenderer({preserveDrawingBuffer: true, antialias: true});
    renderer2.setPixelRatio(window.devicePixelRatio);
    renderer2.setSize(window.innerWidth, window.innerHeight);
    window.renderer = renderer2;
    renderer2.autoClearColor = false;
    renderer2.domElement.id = "three";
    document.querySelector(selector).appendChild(renderer2.domElement);
    scene = new Scene();
    group = new Group();
    group.rotation.set(0, Math.PI, Math.PI);
    scene.add(group);
    camera = new PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1e-3, 1e3);
    scene.add(camera);
    camera.position.set(0, 0, 4);
    camera.lookAt(group.position);
    eraser = new Eraser();
    scene.add(eraser.el);
    targetQuat = new Quaternion().setFromEuler(group.rotation);
    originQuat = new Quaternion().setFromEuler(group.rotation);
  };
  var init_balls = () => {
    const normalTexture = GenerateTexture("#eee", "#fff", 10);
    const hoverTexture = GenerateTexture("#fff", "#000", 20);
    for (let i = 0; i < numballs; i++) {
      balls.push(new CircleSprite(group, i, DATA_STUDENTS[i], normalTexture, hoverTexture));
    }
  };
  var randomize = () => {
    _moveto_ransom_path();
  };
  window.randomize = randomize;
  var _moveto_ransom_path = () => {
    const paths = [
      `<svg class="svg-icon" viewBox="0 0 20 20">
			<path d="M17.684,7.925l-5.131-0.67L10.329,2.57c-0.131-0.275-0.527-0.275-0.658,0L7.447,7.255l-5.131,0.67C2.014,7.964,1.892,8.333,2.113,8.54l3.76,3.568L4.924,17.21c-0.056,0.297,0.261,0.525,0.533,0.379L10,15.109l4.543,2.479c0.273,0.153,0.587-0.089,0.533-0.379l-0.949-5.103l3.76-3.568C18.108,8.333,17.986,7.964,17.684,7.925 M13.481,11.723c-0.089,0.083-0.129,0.205-0.105,0.324l0.848,4.547l-4.047-2.208c-0.055-0.03-0.116-0.045-0.176-0.045s-0.122,0.015-0.176,0.045l-4.047,2.208l0.847-4.547c0.023-0.119-0.016-0.241-0.105-0.324L3.162,8.54L7.74,7.941c0.124-0.016,0.229-0.093,0.282-0.203L10,3.568l1.978,4.17c0.053,0.11,0.158,0.187,0.282,0.203l4.578,0.598L13.481,11.723z"></path>
		</svg>`,
      `<svg class="svg-icon" viewBox="0 0 20 20">
			<path d="M9.719,17.073l-6.562-6.51c-0.27-0.268-0.504-0.567-0.696-0.888C1.385,7.89,1.67,5.613,3.155,4.14c0.864-0.856,2.012-1.329,3.233-1.329c1.924,0,3.115,1.12,3.612,1.752c0.499-0.634,1.689-1.752,3.612-1.752c1.221,0,2.369,0.472,3.233,1.329c1.484,1.473,1.771,3.75,0.693,5.537c-0.19,0.32-0.425,0.618-0.695,0.887l-6.562,6.51C10.125,17.229,9.875,17.229,9.719,17.073 M6.388,3.61C5.379,3.61,4.431,4,3.717,4.707C2.495,5.92,2.259,7.794,3.145,9.265c0.158,0.265,0.351,0.51,0.574,0.731L10,16.228l6.281-6.232c0.224-0.221,0.416-0.466,0.573-0.729c0.887-1.472,0.651-3.346-0.571-4.56C15.57,4,14.621,3.61,13.612,3.61c-1.43,0-2.639,0.786-3.268,1.863c-0.154,0.264-0.536,0.264-0.69,0C9.029,4.397,7.82,3.61,6.388,3.61"></path>
		</svg>`,
      `<svg class="svg-icon" viewBox="0 0 20 20">
			<path d="M17.218,2.268L2.477,8.388C2.13,8.535,2.164,9.05,2.542,9.134L9.33,10.67l1.535,6.787c0.083,0.377,0.602,0.415,0.745,0.065l6.123-14.74C17.866,2.46,17.539,2.134,17.218,2.268 M3.92,8.641l11.772-4.89L9.535,9.909L3.92,8.641z M11.358,16.078l-1.268-5.613l6.157-6.157L11.358,16.078z"></path>
		</svg>`,
      `<svg class="svg-icon" viewBox="0 0 20 20">
			<path fill="none" d="M16.888,8.614c0.008-0.117,0.018-0.233,0.018-0.352c0-2.851-2.311-5.161-5.16-5.161c-1.984,0-3.705,1.121-4.568,2.763c-0.32-0.116-0.664-0.182-1.023-0.182c-1.663,0-3.011,1.348-3.011,3.01c0,0.217,0.024,0.427,0.067,0.631c-1.537,0.513-2.647,1.96-2.647,3.67c0,2.138,1.733,3.87,3.871,3.87h10.752c2.374,0,4.301-1.925,4.301-4.301C19.486,10.792,18.416,9.273,16.888,8.614 M15.186,16.003H4.433c-1.66,0-3.01-1.351-3.01-3.01c0-1.298,0.827-2.444,2.06-2.854l0.729-0.243l-0.16-0.751C4.02,8.993,4.003,8.841,4.003,8.692c0-1.186,0.965-2.15,2.151-2.15c0.245,0,0.49,0.045,0.729,0.131l0.705,0.256l0.35-0.664c0.748-1.421,2.207-2.303,3.807-2.303c2.371,0,4.301,1.929,4.301,4.301c0,0.075-0.007,0.148-0.012,0.223l-0.005,0.073L15.99,9.163l0.557,0.241c1.263,0.545,2.079,1.785,2.079,3.159C18.626,14.46,17.082,16.003,15.186,16.003"></path>
		</svg>`,
      `<svg class="svg-icon" viewBox="0 0 20 20">
			<path fill="none" d="M10,0.562c-5.195,0-9.406,4.211-9.406,9.406c0,5.195,4.211,9.406,9.406,9.406c5.195,0,9.406-4.211,9.406-9.406C19.406,4.774,15.195,0.562,10,0.562 M10,18.521c-4.723,0-8.551-3.829-8.551-8.552S5.277,1.418,10,1.418s8.552,3.828,8.552,8.551S14.723,18.521,10,18.521"></path>
		</svg>`,
      `<svg class="svg-icon" viewBox="0 0 20 20">
			<path fill="none" d="M15.898,4.045c-0.271-0.272-0.713-0.272-0.986,0l-4.71,4.711L5.493,4.045c-0.272-0.272-0.714-0.272-0.986,0s-0.272,0.714,0,0.986l4.709,4.711l-4.71,4.711c-0.272,0.271-0.272,0.713,0,0.986c0.136,0.136,0.314,0.203,0.492,0.203c0.179,0,0.357-0.067,0.493-0.203l4.711-4.711l4.71,4.711c0.137,0.136,0.314,0.203,0.494,0.203c0.178,0,0.355-0.067,0.492-0.203c0.273-0.273,0.273-0.715,0-0.986l-4.711-4.711l4.711-4.711C16.172,4.759,16.172,4.317,15.898,4.045z"></path>
		</svg>`
    ];
    const parser = new DOMParser();
    const index = Math.floor(Math.random() * paths.length);
    console.log("using index", index);
    const newPath = paths[index];
    const fixedPath = newPath.replace("<svg", `<svg xmlns="http://www.w3.org/2000/svg"`);
    const doc = parser.parseFromString(fixedPath, "image/svg+xml");
    const vb = doc.documentElement.getAttribute("viewBox");
    const width = vb.split(" ")[2] * 1;
    const height = vb.split(" ")[3] * 1;
    const size = Math.max(width, height);
    const S = size;
    const path = doc.querySelector("path");
    const length = path.getTotalLength();
    const inc = length / numballs;
    const positions = [];
    for (let i = 0; i < numballs; i++) {
      const p = path.getPointAtLength(inc * i);
      const x = -1 + 2 * (p.x / S);
      const y = -1 + 2 * (p.y / S);
      const z = 0;
      positions.push({x, y, z});
    }
    applyPositions(positions);
  };
  var applyPositions = (positions, blendMax = null, blendMin = null, hideTrailsFor = 100, clearTrails = true) => {
    if (clearTrails)
      eraser.clearScreen();
    let delay = 0;
    for (let i = 0; i < numballs; i++) {
      delay = i * 10;
      setTimeout(() => {
        balls[i].setTarget({x: 0, y: 0, z: 0});
        setTimeout(() => {
          balls[i].setTarget(positions[i]);
        }, 100);
      }, delay);
    }
    setTimeout(() => {
      eraser.blendDown(blendMin);
    }, delay + hideTrailsFor + 100);
  };
  var update = () => {
    requestAnimationFrame(update);
    balls.forEach((b) => b.update());
    eraser.update();
    const speed = 0.33;
    const elapsedTime = clock.getElapsedTime();
    group.rotation.y = elapsedTime * speeds[0];
    group.rotation.x = elapsedTime * speeds[1];
    group.rotation.z = elapsedTime * speeds[2];
    targetQuat = targetQuat.setFromEuler(group.rotation);
    group.quaternion.slerp(targetQuat, 0.01);
    renderer2.render(scene, camera);
  };
  var OnWindowResize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer2.setSize(window.innerWidth, window.innerHeight);
  };
  main("#animation");
})();
